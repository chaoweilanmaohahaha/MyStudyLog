# variable_precisionSWAR

这个算法的目的是计算二进制形式中有多少个 1，通常如果使用遍历的方法，时间复杂度是 O(n)，对于非常大量的数据而言是非常耗时的，那么该算法是目前所有同类算法中最快的。算法主要如下：

```
func SWAR(int i) {
	i = (i & 0x55555555) + ((i >> 1) & 0x55555555);
	i = (i & 0x33333333) + ((i >> 1) & 0x33333333);
	i = (i & 0x0F0F0F0F) + ((i >> 1) & 0x0F0F0F0F);
	i = (i * 0x01010101) >> 24;
	return i;
}
```

一般而言这个算法处理的是 32 位的数据，从上面的代码可以看出，这个算法一般有四个步骤：

* 第一步：计算每两位中 1 的个数。先来看 i & 0x55555555。如果每两位中奇数位为 1，则最后结果中会记下两位中的 1 的个数，这个非常巧妙。比如说 0100 & 0101，对于前两位，以为其中有一个 1，所以最后结果中会记录前两位中有过一个 1，后面则记录前两位中有 0 个 1，最后获得结果 0100。那么加号后半个是计算偶数位置上是否为 1，那么根据位加法，由于每两位绝对是 0，1，2 个 1，所以每两位相加就可以得到一个对于两位 1 的个数的统计。
* 第二步：计算每四位中 1 的个数。假设现在我们已经知道了前四位统计下来的结果是 0100，那当我们计算 0100 & 0011 与 0001 & 0011 时，我们可以获得四位中 1 的个数，注意值的运算过程恰巧是被保留下来的。
* 第三步：计算了每八位中 1 的个数，原理和上面的一样。
* 第四步：这里运用了乘法，如果手工去计算这个乘法，可以惊奇地发现最后结果地高 8 位恰巧是 32 位数据中 每个 8 位数据的和，所以最终高 8 位就是 32 位数据中 1 的总个数。

