# manachar算法

manachar算法又叫做马拉车算法，它的应用场景就是匹配字符串中的回文串而设计的算法。

### 回文串

什么是回文串？从后往前和从前往后所形成的串是一致的就是所谓的回文串，比如abba和aba。很显然回文串就是我们所谓‘轴对称’的一个字符串了。如果硬是要这么说，那就一定有一个对称中心，比如对于abba来说，对称中心在两个b中间；对于aba来说，对称中心在b处。

这样定义对称中心有一个坏处，那就是偶数和奇数出现对称中心的地方是不同的。这样在计算起来就相对麻烦。

### 算法

最普通的想法是遍历每一个字符串的元素，从那个元素出发，遍历所有可能形成的子串，记录当前那个子串的信息。这种算法的复杂度很显然是O(n*n)的。有没有更快速的计算方法呢？

##### 回文串的处理

首先针对在回文串中出现的不统一问题，先对回文串进行处理。处理方法十分暴力，就是在字符串的各个字母之间插入特殊字符。例如#a#b#b#a#和#a#b#a#这样一来，你可以发现字符串的长度必然是奇数，也就是说它的对称中心得到了统一。

```
string process(string str) {
    string tmp = "#";
    for(int i = 0; i < str.length(); i++) {
        tmp = tmp + str[i] + "#";
    }
    return tmp;
}
```

##### 回文串信息的处理

我们首先要定义几个比较重要的参数，这几个参数就是之后要使用的标志

**回文串半径：**如果就把回文串看作一根轴对称的线段，则这个回文串的半径就相当于这个线段长度的一半。例如#a#b#a#，如果b是回文串的中心点，那么长的一个回文串的半径长度是3。而在这个算法中，每一个点上都需要记录最长的回文串半径的长度，因此需要一个数组来记录[1,2,1,3,1,2,1]。

**回文串右边界：**这个值是一个全局的值，它所记录的是遍历过程中遇到所有的回文串能够到达的最右边界。还是以上面的例子来说。对于串#a#b#a#，我们从左到右遍历这个串，那么得到的一连串最右边界为：0，2，2，6，6，6，6（下标从0开始）。

**右边界对应回文中心：**也就是取到上述右边界时所对应的中心坐标。

##### 算法流程

OK，我们依旧要把算法的情况进行分类。因为定义了回文串的右边界，在遍历的过程中当前的元素可能在该边界的左右两端

* 如果在边界的右端，这个时候由于回文串的右边界一定会超过此时的右边界，则只需要使用从中心扩散的方法，去更新回文中心和右边界。
* 如果在边界的左端，此时要确定的是是否需要更新参数。此时如果我设回文中心位置是C，则当前走到的位置P一定在C和R(最右端边界)中间。那么根据回文串的特性，这个P轴对称于C，绝对在C的左边有一个镜像P‘。此时就分析这个C和P’。
  * 如果对于P‘而言的左边界点在R'（R对于C的对称点）的右边，那么可以知道的是，P'一定这个串一定包在了R'到R这个范围内，所以它的半径长度就是P’的半径长度。
  * 那如果是在左边呢？此时就需要重新计算了，那么我们设想一下，此时对称点的位置的半径长度已经落在了R‘外，所以对于此时的P而言，它的半径已经可以延伸到R-P+1的长度了，它并无法知道超过R的位置能否构成回文串，所以半径就是这么长。

```
int manachar(string str) {
    if(str.length() == 0) return 0;
    int radius[100] = {0};
    int R = -1;
    int C = -1;
    int M = INT_MIN;
    for(int i = 0; i < str.length(); i++) {
        radius[i] = i < R ? min(radius[2*C-i], R-i+1) : 1;  
        //这里包括了三种情况，其中2*C-是当前位置的镜像。
        while(i+radius[i]<str.length() && i-radius[i]>=0 ) {  //对当前位置进行扩展
            if(str[i+radius[i]] == str[i-radius[i]]) {
                radius[i]++;
            } else {
                break;
            }
        }
        if(i+radius[i] > R) {  //更新R
            R = i + radius[i];
            C = i;
        }
        M = max(M, radius[i]);
    }
    return M-1;
};
```

最后分析一下时间复杂度，manachar算法其实可以是O(n)的，因为其中的这个while循环在很多情况下不需要执行，并且在执行的过程中依赖于回文串的长度，因此你可以看成是只遍历了一遍字符串。



