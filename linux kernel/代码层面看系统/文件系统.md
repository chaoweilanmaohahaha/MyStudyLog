# 文件系统

这一部分比较庞大，需要分块来进行记忆。

###### 写在前面

Linux0.11版本使用的是MINIX1.0版本的文件系统，MINIX文件系统和UNIX文件系统基本相似，由6个部分组成，从左到右分别为：引导块，超级块，i结点位图，逻辑块位图，i节点，数据区。

引导块：还记得在引导部分，在第一个盘块的一个扇区装载着引导系统的信息。如果一个盘是用来做引导设备的，那么它应该在引导盘块中有对应的引导代码。如果这块盘不是用作引导则仍然需要有引导部分，但是这部分没有代码。

超级块：用来存放盘设备上文件系统结构的信息。也就是存放了该文件系统的一些全局信息。

i节点位图：这是一个bitmap结构，如果某一位被置1则说明该位代表的i节点被使用了。

逻辑块位图：这个位图是用来描述盘上的数据块的使用情况，其中每一位代表的是一个数据盘块的使用情况。

i节点：是一个结构，存放文件系统中文件或者目录的索引节点，每一个文件都有一个i节点。

数据区：存放文件真正的数据，而要找到这些存放数据的数据块，则需要通过i节点进行连接。在后面看i节点的操作时可以看到在i节点寻找数据块的过程中可能会出现间接指向数据块的过程。在MINIX系统中使用连续2个扇区（1024B）作为一个数据块来使用，称为一个盘块。那么逻辑块并不能完全认为是等同于盘块，在这个版本中这两个概念表示的大小相同，但是逻辑块的作用是用来寻址，还是要有一个和物理块地址转换的过程。

**这里有一个关于文件的概念还是要说明一下：有一个概念是符号链接，符号链接就是使用一个不同的文件名来引用另一个文件，而这个文件是可以跨越文件系统，这个链接并不影响本身的文件。但是还有一种链接是硬链接，这说明链接文件和源文件可以说是同一个文件，相互是有影响的。**

### 高速缓存区

代码先从这边开始，高速缓存区也就是所谓的cache，它的位置存在于内核代码和主存的中间。cache的存在是为了协调IO读写操作和内存处理的速度。因此在这个版本的内核中，专门在其中开辟了一片区域为高速缓存区。那就先从这一片小区域开始讲起。

###### buffer.c

其实在前面的块设备等地方就已经涉及到了一点高速缓存的知识。整个高速缓存区被划分位1024B的缓冲块，在0.11版本的内核中，高速缓存区使用了hash表和空闲缓冲队列来管理。在初始化过程中，会从缓冲区的两端开始初始化缓冲头部和缓冲块。缓冲头部也就是buffer_head记录了缓冲块的属性，并且和其他缓冲头一起连接成一个链表；从尾部起初始化缓冲块，当两端相遇，已经没有空间再分配时就停止。每个buffer_head被链接成一个双向链表。我们先来看看初始化(这个函数出现在main.c中)：

```
void buffer_init(long buffer_end)  //buffer_end是初始化到的末尾位置
{
	struct buffer_head * h = start_buffer;  //buff开始位置，也就是从缓冲区头部开始
	void * b;
	int i;

	if (buffer_end == 1<<20)
		b = (void *) (640*1024);
	else
		b = (void *) buffer_end; 
	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) { 
		h->b_dev = 0;   //设备
		h->b_dirt = 0;  //是否修改
		h->b_count = 0; 
		h->b_lock = 0;  //是否上锁
		h->b_uptodate = 0;  //更新标志
		h->b_wait = NULL;  //是否等待
		h->b_next = NULL;  //指向同一个hash值的下一个缓冲头
		h->b_prev = NULL;  //指向同一个hash值的前一个缓冲头
		h->b_data = (char *) b;  //指向缓冲块数据（1024B）
		h->b_prev_free = h-1;  //空闲链表双向链表前向指针
		h->b_next_free = h+1;  //空闲链表双向链表后继指针
		h++;
		NR_BUFFERS++;
		if (b == (void *) 0x100000)
			b = (void *) 0xA0000;
	}
	h--;
	free_list = start_buffer;  //空闲链表头指向该缓冲区头部
	free_list->b_prev_free = h; // 完成双向链表的链接
	h->b_next_free = free_list;
	for (i=0;i<NR_HASH;i++)
		hash_table[i]=NULL;  //hash表初始化
}	
```

从这个里面可以看到，所有的缓冲头都被挂在了一个双向链表上（free_list）使用b_prev_free和b_next_free指针指向。已经被读入缓冲区中的数据块需要存放在一个hash表中，这个需要使用对应的设备号和逻辑块号进行hash，然后将这个块放入hash表中，而b_prev和b_next就是用来处理hash表上的块的链接。

然后我们看一下获取缓冲块的函数：

**get_hash_table** 

先看这个辅助函数，这个函数其实是看是否有指定的设备已经使用了某个缓冲块，这样直接在hash表中就能找到。

```
struct buffer_head * get_hash_table(int dev, int block)
{
	struct buffer_head * bh;

	for (;;) {
		if (!(bh=find_buffer(dev,block))) //这就是找这个缓冲块的函数，根据对应设备号和块号，找不到就return
			return NULL;
		bh->b_count++;  //引用计数
		wait_on_buffer(bh);  //等待缓冲区解锁
		if (bh->b_dev == dev && bh->b_blocknr == block) //验证是否是正确的缓冲区
			return bh;
		bh->b_count--;
	}
}
```

**getblk**

```
struct buffer_head * getblk(int dev,int block)
{
	struct buffer_head * tmp, * bh;
repeat:
	if (bh = get_hash_table(dev,block))
		return bh;   //如果hash表中存在则直接返回
	tmp = free_list;  //如果没有则开始寻找一个空闲的缓冲块
	do {
		if (tmp->b_count)
			continue;
		if (!bh || BADNESS(tmp)<BADNESS(bh)) {
			bh = tmp;
			if (!BADNESS(tmp))
				break;
		}
/* and repeat until we find something good */
	} while ((tmp = tmp->b_next_free) != free_list);
	if (!bh) {
		sleep_on(&buffer_wait);  //如果没有空闲的块就等待
		goto repeat;
	}
	wait_on_buffer(bh);  //等待这个空闲块解锁
	if (bh->b_count)  //如果这个块又被引用了就重新寻找
		goto repeat;
	while (bh->b_dirt) {
		sync_dev(bh->b_dev);  //设备上数据和缓冲区中数据同步
		wait_on_buffer(bh);
		if (bh->b_count)
			goto repeat;
	}
/* NOTE!! While we slept waiting for this block, somebody else might */
/* already have added "this" block to the cache. check it */
	if (find_buffer(dev,block))
		goto repeat;
/* OK, FINALLY we know that this buffer is the only one of it's kind, */
/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
	bh->b_count=1;
	bh->b_dirt=0;
	bh->b_uptodate=0;
	remove_from_queues(bh); //先把这个块从队列中拿掉，以免有人使用
	bh->b_dev=dev;
	bh->b_blocknr=block;
	insert_into_queues(bh);  //将这个块插入原来的空闲队列尾部，同时插入hash表中
	return bh;
}
```

以上就是块的查找过程，所有一个设备要使用到一个缓冲块就需要这么查找。

那么对缓冲区进行读操作，需要使用这个文件中的bread，bread_page和breada函数，其实都很相似，只要看一下bread函数就可以了。

**bread**

返回含有有效数据的缓冲块

```
struct buffer_head * bread(int dev,int block)
{
	struct buffer_head * bh;

	if (!(bh=getblk(dev,block)))   //获取一个缓冲块
		panic("bread: getblk returned NULL\n");
	if (bh->b_uptodate)  //如果这个块上数据就是最新的，则直接返回
		return bh;
	ll_rw_block(READ,bh);  //读块
	wait_on_buffer(bh);
	if (bh->b_uptodate)  
		return bh;
	brelse(bh);   //读失败，释放块
	return NULL;
}
```

###### bitmap.c

从文件的名字来看就很好理解，这个肯定和i节点位图和逻辑块位图有关，它们代表了一个i节点或者一个逻辑块是否被使用。先来看一下关于逻辑块的：

**new_block**

```
int new_block(int dev)
{
	struct buffer_head * bh;
	struct super_block * sb;
	int i,j;

	if (!(sb = get_super(dev)))  //获取设备的超级快
		panic("trying to get new block from nonexistant device");
	j = 8192;
	for (i=0 ; i<8 ; i++)
		if (bh=sb->s_zmap[i])  //zmap保存的是逻辑块位图
			if ((j=find_first_zero(bh->b_data))<8192)  //扫描是否有空闲位置
				break;
	if (i>=8 || !bh || j>=8192)
		return 0;
	if (set_bit(j,bh->b_data))  //j代表找到的位置，置位j
		panic("new_block: bit already set");
	bh->b_dirt = 1;
	j += i*8192 + sb->s_firstdatazone-1;   //这边有点蒙蔽，有点不知道在干嘛。。。，应该在计算逻辑盘块号
	if (j >= sb->s_nzones)
		return 0;
	if (!(bh=getblk(dev,j)))  //申请缓冲块
		panic("new_block: cannot get block");
	if (bh->b_count != 1)
		panic("new block: count is != 1");
	clear_block(bh->b_data);  //清除缓冲块上的数据
	bh->b_uptodate = 1; //置位更新和修改位
	bh->b_dirt = 1;
	brelse(bh);   //释放盘块
	//上面四步目前不知道在干嘛。。。
	return j;  //返回逻辑盘块号
}
```

**free_block**

```
void free_block(int dev, int block)
{
	struct super_block * sb;
	struct buffer_head * bh;

	if (!(sb = get_super(dev)))
		panic("trying to free block on nonexistent device");
	if (block < sb->s_firstdatazone || block >= sb->s_nzones)
		panic("trying to free block not in datazone");
	bh = get_hash_table(dev,block);
	if (bh) {
		if (bh->b_count != 1) {
			printk("trying to free block (%04x:%d), count=%d\n",
				dev,block,bh->b_count);
			return;
		}
		bh->b_dirt=0;
		bh->b_uptodate=0;
		brelse(bh);
	}  //如果这个设备和逻辑块占用了某个缓冲块就释放
	block -= sb->s_firstdatazone - 1 ;
	if (clear_bit(block&8191,sb->s_zmap[block/8192]->b_data)) {  //清除那一位
		printk("block (%04x:%d) ",dev,block+sb->s_firstdatazone-1);
		panic("free_block: bit already cleared");
	}
	sb->s_zmap[block/8192]->b_dirt = 1;
}
```

这个文件中还有两个函数是用来更新i节点位图，分别是free_inode复位对应i节点位图的比特位，new_node为某个设备建立一个新的i节点，这个会在i节点获取一个新的空闲i节点表项。

###### inode.c

i节点是文件系统中的一个非常重要的概念，i节点存放着文件系统中文件的索引节点，每一个文件都有一个节点，一个i节点是32个字节，其中包括保存了文件类型属性，文件用户id，文件长度，修改时间，组id，文件链接数和文件占用的逻辑盘块数组。i_zone[9]代表着占用的逻辑盘块，其中0~6直接指向某个逻辑盘块，而7是一次间接指针，8是二次间接指针。

这个文件中主要包含对于inode操作的三个函数，iget()从设备上读取某个指定节点，iput()从设备上释放某一个i节点，bmap用于将文件数据块映射到盘块上。首先先来看bmap的操作：

**bmap**

```
static int _bmap(struct m_inode * inode,int block,int create)  //create代表要新申请一个磁盘块
{
	struct buffer_head * bh;
	int i;

	if (block<0)
		panic("_bmap: block<0");
	if (block >= 7+512+512*512)
		panic("_bmap: block>big");  //判断逻辑是否超过文件系统的承受范围
	if (block<7) {
		if (create && !inode->i_zone[block])  //如果需要新申请则new出一个逻辑块
			if (inode->i_zone[block]=new_block(inode->i_dev)) {
				inode->i_ctime=CURRENT_TIME;
				inode->i_dirt=1;
			}
		return inode->i_zone[block];  //直接指向的块
	}
	block -= 7;
	if (block<512) {  //说明是一级间接块
		if (create && !inode->i_zone[7])  //和上面同样的操作
			if (inode->i_zone[7]=new_block(inode->i_dev)) {
				inode->i_dirt=1;
				inode->i_ctime=CURRENT_TIME;
			}
		if (!inode->i_zone[7])
			return 0;
		if (!(bh = bread(inode->i_dev,inode->i_zone[7])))  //获取对应的数据缓冲块
			return 0;
		i = ((unsigned short *) (bh->b_data))[block];  //这个不懂再干嘛但是你要知道它返回的是逻辑盘块号
		if (create && !i)
			if (i=new_block(inode->i_dev)) {
				((unsigned short *) (bh->b_data))[block]=i;
				bh->b_dirt=1;
			}
		brelse(bh);
		return i;
	}
	block -= 512;   //以下是二级间接块
	if (create && !inode->i_zone[8])
		if (inode->i_zone[8]=new_block(inode->i_dev)) {
			inode->i_dirt=1;
			inode->i_ctime=CURRENT_TIME;
		}
	if (!inode->i_zone[8])
		return 0;
	if (!(bh=bread(inode->i_dev,inode->i_zone[8])))
		return 0;
	i = ((unsigned short *)bh->b_data)[block>>9];
	if (create && !i)
		if (i=new_block(inode->i_dev)) {
			((unsigned short *) (bh->b_data))[block>>9]=i;
			bh->b_dirt=1;
		}
	brelse(bh);
	if (!i)
		return 0;
	if (!(bh=bread(inode->i_dev,i)))
		return 0;
	i = ((unsigned short *)bh->b_data)[block&511];
	if (create && !i)
		if (i=new_block(inode->i_dev)) {
			((unsigned short *) (bh->b_data))[block&511]=i;
			bh->b_dirt=1;
		}
	brelse(bh);//释放该缓冲区
	return i;
}
```

**iget**

```
struct m_inode * iget(int dev,int nr) //返回一个i节点，给的参数是设备号和i节点号
{
	struct m_inode * inode, * empty;

	if (!dev)
		panic("iget with dev==0");
	empty = get_empty_inode(); //找一个空的inode
	inode = inode_table;  //定位到存储i节点的表
	while (inode < NR_INODE+inode_table) {  //找对应的inode
		if (inode->i_dev != dev || inode->i_num != nr) {
			inode++;
			continue;
		}
		wait_on_inode(inode);
		if (inode->i_dev != dev || inode->i_num != nr) {
			inode = inode_table;
			continue;
		}
		inode->i_count++;
		if (inode->i_mount) {  //这说明这个inode是其他文件系统的安装点，但是这是要干嘛？？？
			int i;

			for (i = 0 ; i<NR_SUPER ; i++)
				if (super_block[i].s_imount==inode)
					break;
			if (i >= NR_SUPER) {
				printk("Mounted inode hasn't got sb\n");
				if (empty)
					iput(empty);
				return inode;
			}
			iput(inode);
			dev = super_block[i].s_dev;
			nr = ROOT_INO;
			inode = inode_table;
			continue;
		}
		if (empty)
			iput(empty); 
		return inode;  //这里代表了对应的i节点已经被找到了，因此就释放之前申请的空闲的块，然后返回找到的块
	}
	if (!empty)
		return (NULL);
	inode=empty;   //没有找到对应的就申请一个新的i节点
	inode->i_dev = dev;
	inode->i_num = nr;
	read_inode(inode);
	return inode;
} //为什么要占一个空闲块先？
```

**iput.c**

```
void iput(struct m_inode * inode)
{
	if (!inode)
		return;
	wait_on_inode(inode);
	if (!inode->i_count)
		panic("iput: trying to free free inode");
	if (inode->i_pipe) {  //说明它是一个管道i节点，但是不清楚下面的操作暂时
		wake_up(&inode->i_wait);
		if (--inode->i_count)
			return;
		free_page(inode->i_size);
		inode->i_count=0;
		inode->i_dirt=0;
		inode->i_pipe=0;
		return;
	}
	if (!inode->i_dev) {
		inode->i_count--;
		return;
	}
	if (S_ISBLK(inode->i_mode)) {
		sync_dev(inode->i_zone[0]);
		wait_on_inode(inode);
	}
repeat:
	if (inode->i_count>1) {
		inode->i_count--;
		return;
	}
	if (!inode->i_nlinks) {  //如果这个i节点的链接数已经减少为0了，则释放该i节点并且释放所有使用到的逻辑块
		truncate(inode);
		free_inode(inode);
		return;
	}
	if (inode->i_dirt) {  
		write_inode(inode);	/* we can sleep - so do again */ //如果被修改了就需要写将节点信息写入设备
		wait_on_inode(inode);
		goto repeat;
	}
	inode->i_count--;
	return;
}
```

其中其实还有两个辅助函数write_inode和read_inode,就是将数据从设备读取i节点所在的逻辑块然后复制其中的内容，还有就是及那个i节点的信息复制到逻辑快对应的i节点中，执行方法如下：

```
read_inode.c:
if (!(bh=bread(inode->i_dev,block)))
		panic("unable to read i-node block");
	*(struct d_inode *)inode =
		((struct d_inode *)bh->b_data)
			[(inode->i_num-1)%INODES_PER_BLOCK];
write_inode.c:
if (!(bh=bread(inode->i_dev,block)))
		panic("unable to read i-node block");
	((struct d_inode *)bh->b_data)
		[(inode->i_num-1)%INODES_PER_BLOCK] =
			*(struct d_inode *)inode;    //这里需要理解这个b_data到底怎么存储的信息
```

###### super.c

这个文件处理的是对于文件系统超级块，主要就是get_super,put_super和read_super。当然在这个文件中还有处理文件系统挂载和卸载的函数sys_unmount和sys_mount。我们直接来看这些函数是怎么操作的把。

**get_super**  //获取超级块

```
struct super_block * get_super(int dev)  //取指定设备的超级块
{
	struct super_block * s;

	if (!dev)
		return NULL;
	s = 0+super_block;  //指向super_block数组，哪来的？？？
	while (s < NR_SUPER+super_block)
		if (s->s_dev == dev) {
			wait_on_super(s);  //等待超级块被释放
			if (s->s_dev == dev)
				return s;
			s = 0+super_block;
		} else
			s++;
	return NULL;
}
```

**put_super**  //释放超级块

```
void put_super(int dev)
{
	struct super_block * sb;
	struct m_inode * inode;
	int i;

	if (dev == ROOT_DEV) {    //根文件系统不能释放
		printk("root diskette changed: prepare for armageddon\n\r");
		return;
	}
	if (!(sb = get_super(dev)))
		return;
	if (sb->s_imount) {
		printk("Mounted disk changed - tssk, tssk\n\r");
		return;
	}
	lock_super(sb);
	sb->s_dev = 0;   //设备置空
	for(i=0;i<I_MAP_SLOTS;i++)
		brelse(sb->s_imap[i]);   //释放对应的i节点占用的缓冲块
	for(i=0;i<Z_MAP_SLOTS;i++)
		brelse(sb->s_zmap[i]);   //释放占用的对应的逻辑块的缓冲块
	free_super(sb);  //释放超级块
	return;
}  //超级块的占用到底是什么形态?
```

**read_super**  //这个函数从设备上将超级块的信息读取到内存中

```
static struct super_block * read_super(int dev)
{
	struct super_block * s;
	struct buffer_head * bh;
	int i,block;

	if (!dev)
		return NULL;
	check_disk_change(dev);
	if (s = get_super(dev))   //如果这个设备的超级块已经在缓存中了就直接返回这个超级块就行了
		return s;
	for (s = 0+super_block ;; s++) {
		if (s >= NR_SUPER+super_block)
			return NULL;
		if (!s->s_dev)
			break;
	}
	s->s_dev = dev;
	s->s_isup = NULL;
	s->s_imount = NULL;
	s->s_time = 0;
	s->s_rd_only = 0;
	s->s_dirt = 0;
	lock_super(s);
	if (!(bh = bread(dev,1))) {
		s->s_dev=0;
		free_super(s);
		return NULL;
	}
	*((struct d_super_block *) s) =
		*((struct d_super_block *) bh->b_data);  //？？？
	brelse(bh);
	if (s->s_magic != SUPER_MAGIC) {
		s->s_dev = 0;
		free_super(s);
		return NULL;
	}
	for (i=0;i<I_MAP_SLOTS;i++)
		s->s_imap[i] = NULL;
	for (i=0;i<Z_MAP_SLOTS;i++)
		s->s_zmap[i] = NULL;
	block=2;
	for (i=0 ; i < s->s_imap_blocks ; i++)
		if (s->s_imap[i]=bread(dev,block))
			block++;
		else
			break;
	for (i=0 ; i < s->s_zmap_blocks ; i++)
		if (s->s_zmap[i]=bread(dev,block))
			block++;
		else
			break;
	if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {
		for(i=0;i<I_MAP_SLOTS;i++)
			brelse(s->s_imap[i]);
		for(i=0;i<Z_MAP_SLOTS;i++)
			brelse(s->s_zmap[i]);
		s->s_dev=0;
		free_super(s);
		return NULL;
	}
	s->s_imap[0]->b_data[0] |= 1;
	s->s_zmap[0]->b_data[0] |= 1;
	free_super(s);             
	return s;
}
```

说一下接下来的三个函数：

sys_unmount:这个函数是从系统中卸载某个文件系统，这个函数首先会取设备的超级块，然后看这个设备被安装到的i节点，随后查找i节点表看是否存在进程正在这个设备上运行，正常情况下要求在卸载的时候不能有进程正在运行在该设备上了。这时置空这个i节点，随后释放设备的超级块，并且释放位图占用的缓冲块。

sys_mount:就是挂载某个文件系统了，那么显然它也应该是卸载i节点的逆操作。那么首先函数根据对应的设备文件名找到对应的i节点，然后取到其中的设备号。文件系统必须被加载到一个目录名，因此需要由给定的目录名找到对应的i节点，然后读取该文件系统的超级块，然后将这个i节点置位。

mount_root这个函数的目的是在开机初始化的时候挂载根文件系统。这个函数的调用位置是在初始化硬盘的时候。

###### namei.c

这个文件我觉得是比较关键的一个文件之一，为什么这么说，因为在这个函数中定义了如何创建目录，删除目录，创建文件和删除文件等系统调用，而这一系列的操作的本质，其实就是对于i节点的操作，所以我认为在文件系统中对于i节点的操作的核心就在这个文件中了。

在其中有两个使用比较核心的函数：find_entry和add_entry函数。

**find_entry**

```
static struct buffer_head * find_entry(struct m_inode ** dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
	//参数中dir代表的是目录i节点，name代表文件名，res_dir返回找到的目录，而本函数返回的是找到的缓冲块
{
	int entries;
	int block,i;
	struct buffer_head * bh;
	struct dir_entry * de;
	struct super_block * sb;

#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
		namelen = NAME_LEN;
#endif
	entries = (*dir)->i_size / (sizeof (struct dir_entry));  //这一步是计算了在该目录下有多少条目录记录，这在后面其实也会遇到，而要知道的一点是，一个目录项中至少包含了两个目录项，分别是'.'和'..'
	*res_dir = NULL;
	if (!namelen)
		return NULL;
/* check for '..', as we might have to do some "magic" for it */
	if (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {
/* '..' in a pseudo-root results in a faked '.' (just change namelen) */
		if ((*dir) == current->root)
			namelen=1;
		else if ((*dir)->i_num == ROOT_INO) {
/* '..' over a mount-point results in 'dir' being exchanged for the mounted
   directory-inode. NOTE! We set mounted, so that we can iput the new dir */
			sb=get_super((*dir)->i_dev);
			if (sb->s_imount) {
				iput(*dir);
				(*dir)=sb->s_imount;
				(*dir)->i_count++;
			}
		}
	}   //..如果切换了文件系统则需要切换对应的文件系统
	if (!(block = (*dir)->i_zone[0]))
		return NULL;
	if (!(bh = bread((*dir)->i_dev,block)))
		return NULL;
	i = 0;
	de = (struct dir_entry *) bh->b_data;
	while (i < entries) {
		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
			brelse(bh);
			bh = NULL;
			if (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) ||
			    !(bh = bread((*dir)->i_dev,block))) {
				i += DIR_ENTRIES_PER_BLOCK;
				continue;
			}
			de = (struct dir_entry *) bh->b_data;
		}  //上面是读对应的而数据块吧，但是这里有点小问题还看不懂
		if (match(namelen,name,de)) {  //这里是在匹配是否找到了匹配名字的目录项
			*res_dir = de;  //res_dir就是该目录项
			return bh;  //返回的是缓冲块
		}
		de++;
		i++;
	}
	brelse(bh);
	return NULL;
}
```

**add_entry**

```
static struct buffer_head * add_entry(struct m_inode * dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
	int block,i;
	struct buffer_head * bh;
	struct dir_entry * de;

	*res_dir = NULL;
#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
		namelen = NAME_LEN;
#endif
	if (!namelen)
		return NULL;
	if (!(block = dir->i_zone[0]))
		return NULL;
	if (!(bh = bread(dir->i_dev,block)))
		return NULL;
	i = 0;
	de = (struct dir_entry *) bh->b_data;
	while (1) {
		if ((char *)de >= BLOCK_SIZE+bh->b_data) {
			brelse(bh);
			bh = NULL;
			block = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);
			if (!block)
				return NULL;
			if (!(bh = bread(dir->i_dev,block))) {
				i += DIR_ENTRIES_PER_BLOCK;
				continue;
			}
			de = (struct dir_entry *) bh->b_data;
		}
		//下面的说法是当序号乘上目录结构大小超过目录指出的i_size则说明这个目录项并没有被使用，那么我们就可是使用它。
		if (i*sizeof(struct dir_entry) >= dir->i_size) {
			de->inode=0;  //注意这一步先置空i节点
			dir->i_size = (i+1)*sizeof(struct dir_entry);
			dir->i_dirt = 1;
			dir->i_ctime = CURRENT_TIME;
		}
		if (!de->inode) { //如果确实是一个新的目录项
			dir->i_mtime = CURRENT_TIME;
			for (i=0; i < NAME_LEN ; i++)
				de->name[i]=(i<namelen)?get_fs_byte(name+i):0;  //输入这个目录项对应的名字
			bh->b_dirt = 1;
			*res_dir = de;  //res_dir指向这个新的目录项
			return bh;  //返回对应的缓冲块
		}
		de++;
		i++;
	}
	brelse(bh);
	return NULL;
}
```

有了这两个函数，那么其他函数理解起来就十分方便了

``static struct m_inode * get_dir(const char * pathname)``

这个函数的目的是通过路径名来找到对应的i节点。

``static struct m_inode * dir_namei(const char * pathname,int * namelen, const char ** name)``

这个函数的目的是根据路径找到i节点的同时还返回对应的目录或者文件名，这里有个有意思的地方，这个函数是使用了get_dir函数去寻找的目录i节点，但是它只会返回最后一个/之前的目录，意思是其实真正完整的目录路径应该类似'/usr/local/'，但是它确实返回了路径上的最高一级的路径。

**namei**

取得指定路径的i节点，你可以看到namei就是对于dir_namei的又一层封装。

```
struct m_inode * namei(const char * pathname)
{
	const char * basename;
	int inr,dev,namelen;
	struct m_inode * dir;
	struct buffer_head * bh;
	struct dir_entry * de;

	if (!(dir = dir_namei(pathname,&namelen,&basename)))
		return NULL;
	if (!namelen)			/* special case: '/usr/' etc */
		return dir;
	bh = find_entry(&dir,basename,namelen,&de);  //为什么这边又要根据basename去找下一层节点，就是因为如果在namelen不为0的情况下当前的目录其实是上一级的目录。
	if (!bh) {
		iput(dir);
		return NULL;
	}
	inr = de->inode;
	dev = dir->i_dev;
	brelse(bh);
	iput(dir);
	dir=iget(dev,inr);
	if (dir) {
		dir->i_atime=CURRENT_TIME;
		dir->i_dirt=1;
	}
	return dir;
}
```

下面开始就是各个系统调用的实现，其实大同小异，因为有了上面这些函数的铺垫

**open_namei**

这个函数是open系统调用使用的函数，打开文件

```
int open_namei(const char * pathname, int flag, int mode,
	struct m_inode ** res_inode)
{
	const char * basename;
	int inr,dev,namelen;
	struct m_inode * dir, *inode;
	struct buffer_head * bh;
	struct dir_entry * de;

	if ((flag & O_TRUNC) && !(flag & O_ACCMODE))
		flag |= O_WRONLY;
	mode &= 0777 & ~current->umask;
	mode |= I_REGULAR;
	if (!(dir = dir_namei(pathname,&namelen,&basename)))
		return -ENOENT;
	if (!namelen) {			/* special case: '/usr/' etc */
		if (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {
			*res_inode=dir;
			return 0;
		}
		iput(dir);
		return -EISDIR;
	}
	bh = find_entry(&dir,basename,namelen,&de);  //上面这些代码依然是基本操作，就是在找最后以及文件的i节点
	if (!bh) {  //如果没有找到的话，说明最后一级并没有对应的缓冲块，那么就要新建一个
		if (!(flag & O_CREAT)) {
			iput(dir);
			return -ENOENT;
		}
		if (!permission(dir,MAY_WRITE)) {
			iput(dir);
			return -EACCES;
		}
		inode = new_inode(dir->i_dev);
		if (!inode) {
			iput(dir);
			return -ENOSPC;
		}   // 这个以上是在检测是否又写权限
		inode->i_uid = current->euid;
		inode->i_mode = mode;
		inode->i_dirt = 1;
		bh = add_entry(dir,basename,namelen,&de);  //增加一个目录项
		if (!bh) {
			inode->i_nlinks--;
			iput(inode);
			iput(dir);
			return -ENOSPC;
		}
		de->inode = inode->i_num;
		bh->b_dirt = 1;
		brelse(bh);
		iput(dir);
		*res_inode = inode;
		return 0;
	}  //从这里往下，是假设在之前最后以及目录项找到了，那么说明已经存在对应的文件或者目录了，那么打开
	inr = de->inode;
	dev = dir->i_dev;
	brelse(bh);
	iput(dir);
	if (flag & O_EXCL)
		return -EEXIST;
	if (!(inode=iget(dev,inr)))
		return -EACCES;
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
	    !permission(inode,ACC_MODE(flag))) {
		iput(inode);
		return -EPERM;
	}
	inode->i_atime = CURRENT_TIME;
	if (flag & O_TRUNC)
		truncate(inode);   //这个函数释放了该i节点上占用的所有逻辑块。
	*res_inode = inode;
	return 0;
}
```

好了，那么我也不累赘的一个个函数这么说了，上面的这个函数基本已经告诉了你这样的系统调用怎么写了，首先就是通过dir_namei去按目录找到对应的目录i节点项以及获取到最高一级的目录名，随后就根据最高一级目录名获取对应的缓冲块。这里就需要分两种情况了，如果我找到了对应的缓冲块那么应该如何做？如果没有找到又该如何做？

这样的函数还包括了sys_mknod（创建一个普通文件），sys_mkdir（创建一个目录）,sys_rmdir（删除一个目录），empty_dir（判断是否目录为空，这时一个辅助函数），sys_unlink（删除一个文件链接）,sys_link（创建一个文件链接）。

###### block_dev.c

该文件是块设备数据访问操作类程序。这个文件中一共只有两个函数block_read()和block_write()。

**block_read**

```
int block_read(int dev, unsigned long * pos, char * buf, int count)
//pos给的是偏移，count给的是长度，这样就是将给定长度的内容写入设备的某个偏移位置
{
	int block = *pos >> BLOCK_SIZE_BITS;
	int offset = *pos & (BLOCK_SIZE-1);  //这两步可以看出通过一维的pos计算出在第几块的偏移位置
	int chars;
	int read = 0;
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
		chars = BLOCK_SIZE-offset;
		if (chars > count)
			chars = count;
		if (!(bh = breada(dev,block,block+1,block+2,-1)))  //预读出数据块
			return read?read:-EIO;
		block++;
		p = offset + bh->b_data;
		offset = 0;
		*pos += chars;
		read += chars;
		count -= chars;  //为下一次读入初始化数据
		while (chars-->0)
			put_fs_byte(*(p++),buf++);  //一个字符一个字符读入缓冲区
		brelse(bh);
	}
	return read;
}
```

**read_write**

```
int block_write(int dev, long * pos, char * buf, int count)
{
	int block = *pos >> BLOCK_SIZE_BITS;
	int offset = *pos & (BLOCK_SIZE-1);
	int chars;
	int written = 0;
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
		chars = BLOCK_SIZE - offset;
		if (chars > count)
			chars=count;
		if (chars == BLOCK_SIZE)
			bh = getblk(dev,block);  //如果长度为一个块长，则正好读出整块
		else
			bh = breada(dev,block,block+1,block+2,-1);  //否则预读数据
		block++;
		if (!bh)
			return written?written:-EIO;
		p = offset + bh->b_data;
		offset = 0;
		*pos += chars;
		written += chars;
		count -= chars;
		while (chars-->0)
			*(p++) = get_fs_byte(buf++);   //写入p指向的告诉缓冲区中
		bh->b_dirt = 1;
		brelse(bh);
	}
	return written;
}
```

###### file_dev.c

这个文件就是用于访问文件的数据

**file_read**

```
int file_read(struct m_inode * inode, struct file * filp, char * buf, int count)
{
	int left,chars,nr;
	struct buffer_head * bh;

	if ((left=count)<=0)
		return 0;
	while (left) {
		if (nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE)) {  //先取该文件当前读写的位置在设备上对应的逻辑块号
			if (!(bh=bread(inode->i_dev,nr))) //取对应的缓冲块
				break;
		} else
			bh = NULL;
		nr = filp->f_pos % BLOCK_SIZE;
		chars = MIN( BLOCK_SIZE-nr , left );
		filp->f_pos += chars;
		left -= chars;
		if (bh) {
			char * p = nr + bh->b_data;
			while (chars-->0)         //读取文件中数据
				put_fs_byte(*(p++),buf++);
			brelse(bh);
		} else {
			while (chars-->0)
				put_fs_byte(0,buf++);  //如果没有读到数据就用0填充
		}
	}
	inode->i_atime = CURRENT_TIME;
	return (count-left)?(count-left):-ERROR;
}
```

**file_write**

```
int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
	off_t pos;
	int block,c;
	struct buffer_head * bh;
	char * p;
	int i=0;

/*
 * ok, append may not work when many processes are writing at the same time
 * but so what. That way leads to madness anyway.
 */
	if (filp->f_flags & O_APPEND)
		pos = inode->i_size;  //如果是向文件后添加数据，指针指向文件末尾
	else
		pos = filp->f_pos;    //否则指向当前读写位置
	while (i<count) {
		if (!(block = create_block(inode,pos/BLOCK_SIZE)))  //创建逻辑块
			break;
		if (!(bh=bread(inode->i_dev,block))) //读取对应的缓冲块
			break;
		c = pos % BLOCK_SIZE;
		p = c + bh->b_data;
		bh->b_dirt = 1;
		c = BLOCK_SIZE-c;
		if (c > count-i) c = count-i;
		pos += c;
		if (pos > inode->i_size) {
			inode->i_size = pos;
			inode->i_dirt = 1;
		}
		i += c;
		while (c-->0)
			*(p++) = get_fs_byte(buf++);  //将buf中的数据写入p指向的位置
		brelse(bh);
	}
	inode->i_mtime = CURRENT_TIME;
	if (!(filp->f_flags & O_APPEND)) {
		filp->f_pos = pos;
		inode->i_ctime = CURRENT_TIME;
	}
	return (i?i:-1);
}
```

###### pipe.c

管道在linux系统中也是一个特殊的结构，它的目的也是读取数据到指向管道的缓冲块内，同样也可以从这个区域中将数据读出。使用管道时，管道i节点的i_size字段会被设置为指向管道缓冲区指针，管道头部指针存放入i_zone[0]，管道数据尾部指针存放在i_zone[1]中。对于管道的读操作是从管道尾部读出，写操作是从管道头部写入。

**pipe_read**

```
int read_pipe(struct m_inode * inode, char * buf, int count)
{
	int chars, size, read = 0;

	while (count>0) {
		while (!(size=PIPE_SIZE(*inode))) {
			wake_up(&inode->i_wait);
			if (inode->i_count != 2) /* are there any writers? */  //判断是否有向管道中写入的请求
				return read;
			sleep_on(&inode->i_wait);
		}
		chars = PAGE_SIZE-PIPE_TAIL(*inode);
		if (chars > count)
			chars = count;
		if (chars > size)
			chars = size;
		count -= chars;
		read += chars;
		size = PIPE_TAIL(*inode);
		PIPE_TAIL(*inode) += chars;  //移动尾指针位置
		PIPE_TAIL(*inode) &= (PAGE_SIZE-1);
		while (chars-->0)
			put_fs_byte(((char *)inode->i_size)[size++],buf++);  //读取chars个字符
	}
	wake_up(&inode->i_wait);
	return read;
}
```

**pipe_write**

和pipe_read十分类似，就不需要重复来看了。

这个文件中还有一个初始化管道的一个函数叫做sys_pipe，所做的事就是初始化管道的读和管道写句柄，然后将这两个句柄复制到用户空间中。

###### char_dev.c

这个文件包括一些字符设备的文件的访问没其中有很多函数还没有实现，简单的说一下：rw_ttyx是向串口终端设备读写，主设备号是4；rw_tty是向控制台读写函数，主设备号是5；rw_mem是内存设备文件读写，主设备是rw_char是对字符设备读写函数的接口。

###### read_write.c

这个文件就是实现了read，write和lseek系统调用的文件。这里按一共涉及三个函数，使用的就是上面讲到的四个文件，对于块设备、字符设备、管道、文件的读写。

你可以很简单的想到read函数首先根据fd文件描述符从当前进程中读取对应的文件。然后获取该文件所在的inode，根据inode中的标志来判断该文件是一个管道文件还是字符文件还是块文件还是普通文件。write函数也是如此。lseek函数是返回一个文件的读写位置指针。

**sys_lseek**

```
int sys_lseek(unsigned int fd,off_t offset, int origin)
{
	struct file * file;
	int tmp;

	if (fd >= NR_OPEN || !(file=current->filp[fd]) || !(file->f_inode)
	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))
		return -EBADF;
	if (file->f_inode->i_pipe)  //管道文件头尾指针不能够随意移动
		return -ESPIPE;
	switch (origin) {
		case 0:  //将文件起始作为文件读写指针
			if (offset<0) return -EINVAL;
			file->f_pos=offset;
			break;
		case 1:  //将文件当前位置作为文件读写指针
			if (file->f_pos+offset<0) return -EINVAL;
			file->f_pos += offset;
			break;
		case 2:  //使用文件末尾作为文件读写指针
			if ((tmp=file->f_inode->i_size+offset) < 0)
				return -EINVAL;
			file->f_pos = tmp;
			break;
		default:
			return -EINVAL;
	}
	return file->f_pos;
}
```

###### open.c

这个文件除了像文件名所述的这样和打开文件有关，同时还包含了创建文件，关闭文件，文件属性修改，文件访问权限修改等操作，其实对于文件的打开，在namei中就已经基本接触了文件的打开操作，就是根据文件路径找到对应的i节点和缓冲块。那么来看看其他函数是怎么操作的。

*int sys_utime(char\*filename, struct utimbuf\* time)*

这个函数设置了文件的访问和修改的时间，time这个结构体中包含了访问时间和修改时间。

*int sys_access(const char\* filename, int mode)*

这个函数检查了文件的访问权限，根据filename来查找i节点，然后提取其中的i_mode字段。

*int sys_chdir(const char\* filename)*

这个函数改变当前的工作目录，将filename对应的i节点赋给对应的用户进程

*int sys_chroot(const char\* filename)*

这个函数改变了根目录，将某个指定的而路径改成了根目录，这个也是根据文件名找到i节点，然后将该进程中的根目录项修改掉。

*int sys_chmod(const char\* filename, int mode)*

这个函数的目的是修改文件的属性，首先通过文件名找到对应的i节点，随后修改这个i节点中的i_mode属性。

*int sys_chown(const char\* filename, int uid, int gid)*

这个函数的目的是修改了宿主，包括修改文件的用户标识符和组标识符。方法和上面修改属性一样。

**sys_open**

open系统调用

```
int sys_open(const char * filename,int flag,int mode)
{
	struct m_inode * inode;
	struct file * f;
	int i,fd;

	mode &= 0777 & ~current->umask;
	for(fd=0 ; fd<NR_OPEN ; fd++)   //查找进程结构中的文件空闲项
		if (!current->filp[fd])
			break;
	if (fd>=NR_OPEN)
		return -EINVAL;
	current->close_on_exec &= ~(1<<fd);
	f=0+file_table;
	for (i=0 ; i<NR_FILE ; i++,f++)   //查找空闲文件结构项
		if (!f->f_count) break;
	if (i>=NR_FILE)
		return -EINVAL;
	(current->filp[fd]=f)->f_count++;
	if ((i=open_namei(filename,flag,mode,&inode))<0) {  //这边就是调用了open_namei
		current->filp[fd]=NULL;
		f->f_count=0;
		return i;
	}
/* ttys are somewhat special (ttyxx major==4, tty major==5) */
	if (S_ISCHR(inode->i_mode))  //检查对应的的是否为字符设备
		if (MAJOR(inode->i_zone[0])==4) {
			if (current->leader && current->tty<0) {
				current->tty = MINOR(inode->i_zone[0]);
				tty_table[current->tty].pgrp = current->pgrp;
			}
		} else if (MAJOR(inode->i_zone[0])==5)
			if (current->tty<0) {
				iput(inode);
				current->filp[fd]=NULL;
				f->f_count=0;
				return -EPERM;
			}
/* Likewise with block-devices: check for floppy_change */
	if (S_ISBLK(inode->i_mode))   //检查是否为块设备
		check_disk_change(inode->i_zone[0]);
	f->f_mode = inode->i_mode;
	f->f_flags = flag;
	f->f_count = 1;
	f->f_inode = inode;
	f->f_pos = 0;  //以上在初始化
	return (fd);  //返回文件描述符
}
```

**sys_close**

close系统调用

```
int sys_close(unsigned int fd)
{	
	struct file * filp;

	if (fd >= NR_OPEN)
		return -EINVAL;
	current->close_on_exec &= ~(1<<fd);
	if (!(filp = current->filp[fd]))
		return -EINVAL;
	current->filp[fd] = NULL;  //找到进程中对应文件描述符的文件然后释放
	if (filp->f_count == 0)
		panic("Close: file count is 0");
	if (--filp->f_count)
		return (0);
	iput(filp->f_inode);  //如果文件已经没有引用句柄了，则释放对应的i节点
	return (0);
}
```

###### exec.c

本文件实现了二进制可执行文件或者shell脚本的加载和执行，是系统调用exec所在。在这个文件中，它将对参数和环境变量进行初始化；根据文件的头部数据结构，对信息进行处理；随后对当前调用进程进行一些处理以方便新的文件运行；随后替换堆栈。

**create_table**

这个函数的目的是在用户堆栈中创建环境和参数变量的指针表，返回这个新的堆栈指针。

```
static unsigned long * create_tables(char * p,int argc,int envc)
{
	unsigned long *argv,*envp;
	unsigned long * sp;

	sp = (unsigned long *) (0xfffffffc & (unsigned long) p);
	sp -= envc+1;  //环境变量起始处
	envp = sp;  //环境变量指针指向此处
	sp -= argc+1;  //参数变量起始处
	argv = sp;  //参数指针指向此处
	put_fs_long((unsigned long)envp,--sp);
	put_fs_long((unsigned long)argv,--sp);
	put_fs_long((unsigned long)argc,--sp);  //将这三个参数分别压入堆栈
	while (argc-->0) {
		put_fs_long((unsigned long) p,argv++);
		while (get_fs_byte(p++)) /* nothing */ ;
	} //排放参数
	put_fs_long(0,argv);
	while (envc-->0) {
		put_fs_long((unsigned long) p,envp++);
		while (get_fs_byte(p++)) /* nothing */ ;
	}// 排放环境变量
	put_fs_long(0,envp);
	return sp; //返回堆栈指针（指向argc）
}
```

**copy_string**

将用户空间内存复制参数和环境字符串进入内核空闲页面中。

```
static unsigned long copy_strings(int argc,char ** argv,unsigned long *page,
		unsigned long p, int from_kmem) //from_kmem是字符串来源
{
	char *tmp, *pag;
	int len, offset = 0;
	unsigned long old_fs, new_fs;

	if (!p)
		return 0;	/* bullet-proofing */
	new_fs = get_ds();
	old_fs = get_fs();
	if (from_kmem==2)  //说明来源于内核
		set_fs(new_fs);
	while (argc-- > 0) {
		if (from_kmem == 1)  //说明来源于用户空间
			set_fs(new_fs);
		if (!(tmp = (char *)get_fs_long(((unsigned long *)argv)+argc)))  //取到argv最后一个参数
			panic("argc is wrong");
		if (from_kmem == 1)
			set_fs(old_fs);
		len=0;		/* remember zero-padding */
		do {
			len++;
		} while (get_fs_byte(tmp++));  //获取一个个参数
		if (p-len < 0) {	/* this shouldn't happen - 128kB */
			set_fs(old_fs);
			return 0;
		}
		while (len) {  //进入内核空间了
			--p; --tmp; --len;
			if (--offset < 0) {
				offset = p % PAGE_SIZE;
				if (from_kmem==2)
					set_fs(old_fs);
				if (!(pag = (char *) page[p/PAGE_SIZE]) &&
				    !(pag = (char *) page[p/PAGE_SIZE] =
				      (unsigned long *) get_free_page())) //偏移p对应的页面如果不存在则重新申请页面 
					return 0;
				if (from_kmem==2)
					set_fs(new_fs);

			}
			*(pag + offset) = get_fs_byte(tmp);  //将数据复制到内核页面中
		}
	}
	if (from_kmem==2)
		set_fs(old_fs);
	return p;
}
```

**do_execve**

```
int do_execve(unsigned long * eip,long tmp,char * filename,
	char ** argv, char ** envp)
{
	struct m_inode * inode;
	struct buffer_head * bh;
	struct exec ex;
	unsigned long page[MAX_ARG_PAGES];
	int i,argc,envc;
	int e_uid, e_gid;
	int retval;
	int sh_bang = 0;
	unsigned long p=PAGE_SIZE*MAX_ARG_PAGES-4;  //首先指针指向了参数和环境字符串空间最后一个长字处

	if ((0xffff & eip[1]) != 0x000f)
		panic("execve called from supervisor mode");
	for (i=0 ; i<MAX_ARG_PAGES ; i++)	/* clear page-table */
		page[i]=0;   //初始化参数和环境变量表
	if (!(inode=namei(filename)))		/* get executables inode */
		return -ENOENT;  //找到对应可执行文件的i节点
	argc = count(argv);
	envc = count(envp);
	
restart_interp:
	if (!S_ISREG(inode->i_mode)) {	/* must be regular file */
		retval = -EACCES;
		goto exec_error2;
	}
	i = inode->i_mode;
	e_uid = (i & S_ISUID) ? inode->i_uid : current->euid;
	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
	if (current->euid == inode->i_uid)
		i >>= 6;
	else if (current->egid == inode->i_gid)
		i >>= 3;
	if (!(i & 1) &&
	    !((inode->i_mode & 0111) && suser())) {
		retval = -ENOEXEC;
		goto exec_error2;
	}
	//以上在查询可执行文件的文件权限
	if (!(bh = bread(inode->i_dev,inode->i_zone[0]))) {
		retval = -EACCES;
		goto exec_error2;
	}  //读取可执行文件的第一块数据
	ex = *((struct exec *) bh->b_data);	/* read exec-header */  //获取头部
	if ((bh->b_data[0] == '#') && (bh->b_data[1] == '!') && (!sh_bang)) {
		/*
		 * This section does the #! interpretation.
		 * Sorta complicated, but hopefully it will work.  -TYT
		 */

		char buf[1023], *cp, *interp, *i_name, *i_arg;
		unsigned long old_fs;

		strncpy(buf, bh->b_data+2, 1022);
		brelse(bh);
		iput(inode);
		buf[1022] = '\0';
		if (cp = strchr(buf, '\n')) {
			*cp = '\0';
			for (cp = buf; (*cp == ' ') || (*cp == '\t'); cp++);
		}
		if (!cp || *cp == '\0') {
			retval = -ENOEXEC; /* No interpreter name found */
			goto exec_error1;
		}
		interp = i_name = cp;
		i_arg = 0;
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
 			if (*cp == '/')
				i_name = cp+1;
		}
		if (*cp) {
			*cp++ = '\0';
			i_arg = cp;
		}   //以上在处理shell脚本文件
		/*
		 * OK, we've parsed out the interpreter name and
		 * (optional) argument.
		 */
		if (sh_bang++ == 0) {
			p = copy_strings(envc, envp, page, p, 0);
			p = copy_strings(--argc, argv+1, page, p, 0);
		}  //复制对应的参数和环境变量
		/*
		 * Splice in (1) the interpreter's name for argv[0]
		 *           (2) (optional) argument to interpreter
		 *           (3) filename of shell script
		 *
		 * This is done in reverse order, because of how the
		 * user environment and arguments are stored.
		 */
		p = copy_strings(1, &filename, page, p, 1);
		argc++;
		if (i_arg) {
			p = copy_strings(1, &i_arg, page, p, 2);
			argc++;
		}
		p = copy_strings(1, &i_name, page, p, 2);
		argc++;
		if (!p) {
			retval = -ENOMEM;
			goto exec_error1;
		}  //复制程序文件名和解释程序文件名
		/*
		 * OK, now restart the process with the interpreter's inode.
		 */
		old_fs = get_fs();
		set_fs(get_ds());
		if (!(inode=namei(interp))) { /* get executables inode */
			set_fs(old_fs);
			retval = -ENOENT;
			goto exec_error1;
		}
		set_fs(old_fs);
		goto restart_interp;
	}  //因为获取了解释文件，所以使用解释文件，然后重新运行
	brelse(bh);
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
		ex.a_text+ex.a_data+ex.a_bss>0x3000000 ||
		inode->i_size < ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) {
		retval = -ENOEXEC;
		goto exec_error2;
	}
	if (N_TXTOFF(ex) != BLOCK_SIZE) {
		printk("%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.", filename);
		retval = -ENOEXEC;
		goto exec_error2;
	}
	if (!sh_bang) {  //不是脚本文件，则复制对应的参数和环境变量
		p = copy_strings(envc,envp,page,p,0);
		p = copy_strings(argc,argv,page,p,0);
		if (!p) {
			retval = -ENOMEM;
			goto exec_error2;
		}
	}
/* OK, This is the point of no return */
	if (current->executable)  //原程序如果是个可执行程序释放，并且重新指向该i节点
		iput(current->executable);
	current->executable = inode;
	for (i=0 ; i<32 ; i++)
		current->sigaction[i].sa_handler = NULL;  //清除信号
	for (i=0 ; i<NR_OPEN ; i++)
		if ((current->close_on_exec>>i)&1)
			sys_close(i);  //关闭对应文件
	current->close_on_exec = 0;
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));  //释放源程序占用的代码段和数据段内存页
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
	if (last_task_used_math == current)
		last_task_used_math = NULL;
	current->used_math = 0;
	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE;
	p = (unsigned long) create_tables((char *)p,argc,envc);  //为该进程建立参数表
	current->brk = ex.a_bss +
		(current->end_data = ex.a_data +
		(current->end_code = ex.a_text));
	current->start_stack = p & 0xfffff000;
	current->euid = e_uid;
	current->egid = e_gid;
	//以上修改老进程中的一些信息
	i = ex.a_text+ex.a_data;
	while (i&0xfff)
		put_fs_byte(0,(char *) (i++));
	eip[0] = ex.a_entry;		/* eip, magic happens :-) */  //代码指针替换为新程序入口
	eip[3] = p;			/* stack pointer */  //堆栈指针替换为新程序堆栈指针
	return 0;
exec_error2:
	iput(inode);
exec_error1:
	for (i=0 ; i<MAX_ARG_PAGES ; i++)
		free_page(page[i]);
	return(retval);
}
```

###### stat.c

这个文件实现了读取文件状态的作用，通过系统给调用stat和fstat来实现，总的来说就是使用文件名或者是文件描述符来查找对应i节点上保存的状态。

###### fcntl.c

这个文件实现的是系统调用dup，dup2和fcntl操作。dup和dup2是复制文件描述符函数，而区别在于dup返回当前最小的未用描述符，dup2返回新的描述符。fcntl是对于文件系统的控制函数，通过这个函数对文件系统中的文件进行操作。

**dupfd**

```
static int dupfd(unsigned int fd, unsigned int arg)
{
	if (fd >= NR_OPEN || !current->filp[fd]) 
		return -EBADF;
	if (arg >= NR_OPEN)
		return -EINVAL;
	while (arg < NR_OPEN)  //找一个当前进程文件中没有用过的最小的一项
		if (current->filp[arg])  
			arg++;
		else
			break;
	if (arg >= NR_OPEN)
		return -EMFILE;
	current->close_on_exec &= ~(1<<arg);
	(current->filp[arg] = current->filp[fd])->f_count++;  //将当前找到的文件描述福对应的文件赋值为原描述符对应的文件
	return arg;
}//那么dup函数就是使arg为0找到一个最小的未用的，而dup2将arg改为一个新的fd这样直接将老fd的文件描述符对应的结构赋值给新fd
```

###### ioctl.c

这个文件实现的是对于输入和输出的控制，是系统调用ioctl程序所在之处。主要是其中调用了之前所说的tty_ioctl函数来加以控制。

