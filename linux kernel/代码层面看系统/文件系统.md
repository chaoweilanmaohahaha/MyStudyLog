# 文件系统

这一部分比较庞大，需要分块来进行记忆。

###### 写在前面

Linux0.11版本使用的是MINIX1.0版本的文件系统，MINIX文件系统和UNIX文件系统基本相似，由6个部分组成，从左到右分别为：引导块，超级块，i结点位图，逻辑块位图，i节点，数据区。

引导块：还记得在引导部分，在第一个盘块的一个扇区装载着引导系统的信息。如果一个盘是用来做引导设备的，那么它应该在引导盘块中有对应的引导代码。如果这块盘不是用作引导则仍然需要有引导部分，但是这部分没有代码。

超级块：用来存放盘设备上文件系统结构的信息。也就是存放了该文件系统的一些全局信息。

i节点位图：这是一个bitmap结构，如果某一位被置1则说明该位代表的i节点被使用了。

逻辑块位图：这个位图是用来描述盘上的数据块的使用情况，其中每一位代表的是一个数据盘块的使用情况。

i节点：是一个结构，存放文件系统中文件或者目录的索引节点，每一个文件都有一个i节点。

数据区：存放文件真正的数据，而要找到这些存放数据的数据块，则需要通过i节点进行连接。在后面看i节点的操作时可以看到在i节点寻找数据块的过程中可能会出现间接指向数据块的过程。在MINIX系统中使用连续2个扇区（1024B）作为一个数据块来使用，称为一个盘块。那么逻辑块并不能完全认为是等同于盘块，在这个版本中这两个概念表示的大小相同，但是逻辑块的作用是用来寻址，还是要有一个和物理块地址转换的过程。

**这里有一个关于文件的概念还是要说明一下：有一个概念是符号链接，符号链接就是使用一个不同的文件名来引用另一个文件，而这个文件是可以跨越文件系统，这个链接并不影响本身的文件。但是还有一种链接是硬链接，这说明链接文件和源文件可以说是同一个文件，相互是有影响的。**

### 高速缓存区

代码先从这边开始，高速缓存区也就是所谓的cache，它的位置存在于内核代码和主存的中间。cache的存在是为了协调IO读写操作和内存处理的速度。因此在这个版本的内核中，专门在其中开辟了一片区域为高速缓存区。那就先从这一片小区域开始讲起。

###### buffer.c

其实在前面的块设备等地方就已经涉及到了一点高速缓存的知识。整个高速缓存区被划分位1024B的缓冲块，在0.11版本的内核中，高速缓存区使用了hash表和空闲缓冲队列来管理。在初始化过程中，会从缓冲区的两端开始初始化缓冲头部和缓冲块。缓冲头部也就是buffer_head记录了缓冲块的属性，并且和其他缓冲头一起连接成一个链表；从尾部起初始化缓冲块，当两端相遇，已经没有空间再分配时就停止。每个buffer_head被链接成一个双向链表。我们先来看看初始化(这个函数出现在main.c中)：

```
void buffer_init(long buffer_end)  //buffer_end是初始化到的末尾位置
{
	struct buffer_head * h = start_buffer;  //buff开始位置，也就是从缓冲区头部开始
	void * b;
	int i;

	if (buffer_end == 1<<20)
		b = (void *) (640*1024);
	else
		b = (void *) buffer_end; 
	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) { 
		h->b_dev = 0;   //设备
		h->b_dirt = 0;  //是否修改
		h->b_count = 0; 
		h->b_lock = 0;  //是否上锁
		h->b_uptodate = 0;  //更新标志
		h->b_wait = NULL;  //是否等待
		h->b_next = NULL;  //指向同一个hash值的下一个缓冲头
		h->b_prev = NULL;  //指向同一个hash值的前一个缓冲头
		h->b_data = (char *) b;  //指向缓冲块数据（1024B）
		h->b_prev_free = h-1;  //空闲链表双向链表前向指针
		h->b_next_free = h+1;  //空闲链表双向链表后继指针
		h++;
		NR_BUFFERS++;
		if (b == (void *) 0x100000)
			b = (void *) 0xA0000;
	}
	h--;
	free_list = start_buffer;  //空闲链表头指向该缓冲区头部
	free_list->b_prev_free = h; // 完成双向链表的链接
	h->b_next_free = free_list;
	for (i=0;i<NR_HASH;i++)
		hash_table[i]=NULL;  //hash表初始化
}	
```

从这个里面可以看到，所有的缓冲头都被挂在了一个双向链表上（free_list）使用b_prev_free和b_next_free指针指向。已经被读入缓冲区中的数据块需要存放在一个hash表中，这个需要使用对应的设备号和逻辑块号进行hash，然后将这个块放入hash表中，而b_prev和b_next就是用来处理hash表上的块的链接。

然后我们看一下获取缓冲块的函数：

**get_hash_table** 

先看这个辅助函数，这个函数其实是看是否有指定的设备已经使用了某个缓冲块，这样直接在hash表中就能找到。

```
struct buffer_head * get_hash_table(int dev, int block)
{
	struct buffer_head * bh;

	for (;;) {
		if (!(bh=find_buffer(dev,block))) //这就是找这个缓冲块的函数，根据对应设备号和块号，找不到就return
			return NULL;
		bh->b_count++;  //引用计数
		wait_on_buffer(bh);  //等待缓冲区解锁
		if (bh->b_dev == dev && bh->b_blocknr == block) //验证是否是正确的缓冲区
			return bh;
		bh->b_count--;
	}
}
```

**getblk**

```
struct buffer_head * getblk(int dev,int block)
{
	struct buffer_head * tmp, * bh;
repeat:
	if (bh = get_hash_table(dev,block))
		return bh;   //如果hash表中存在则直接返回
	tmp = free_list;  //如果没有则开始寻找一个空闲的缓冲块
	do {
		if (tmp->b_count)
			continue;
		if (!bh || BADNESS(tmp)<BADNESS(bh)) {
			bh = tmp;
			if (!BADNESS(tmp))
				break;
		}
/* and repeat until we find something good */
	} while ((tmp = tmp->b_next_free) != free_list);
	if (!bh) {
		sleep_on(&buffer_wait);  //如果没有空闲的块就等待
		goto repeat;
	}
	wait_on_buffer(bh);  //等待这个空闲块解锁
	if (bh->b_count)  //如果这个块又被引用了就重新寻找
		goto repeat;
	while (bh->b_dirt) {
		sync_dev(bh->b_dev);  //设备上数据和缓冲区中数据同步
		wait_on_buffer(bh);
		if (bh->b_count)
			goto repeat;
	}
/* NOTE!! While we slept waiting for this block, somebody else might */
/* already have added "this" block to the cache. check it */
	if (find_buffer(dev,block))
		goto repeat;
/* OK, FINALLY we know that this buffer is the only one of it's kind, */
/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
	bh->b_count=1;
	bh->b_dirt=0;
	bh->b_uptodate=0;
	remove_from_queues(bh); //先把这个块从队列中拿掉，以免有人使用
	bh->b_dev=dev;
	bh->b_blocknr=block;
	insert_into_queues(bh);  //将这个块插入原来的空闲队列尾部，同时插入hash表中
	return bh;
}
```

以上就是块的查找过程，所有一个设备要使用到一个缓冲块就需要这么查找。

那么对缓冲区进行读操作，需要使用这个文件中的bread，bread_page和breada函数，其实都很相似，只要看一下bread函数就可以了。

**bread**

返回含有有效数据的缓冲块

```
struct buffer_head * bread(int dev,int block)
{
	struct buffer_head * bh;

	if (!(bh=getblk(dev,block)))   //获取一个缓冲块
		panic("bread: getblk returned NULL\n");
	if (bh->b_uptodate)  //如果这个块上数据就是最新的，则直接返回
		return bh;
	ll_rw_block(READ,bh);  //读块
	wait_on_buffer(bh);
	if (bh->b_uptodate)  
		return bh;
	brelse(bh);   //读失败，释放块
	return NULL;
}
```

###### bitmap.c

从文件的名字来看就很好理解，这个肯定和i节点位图和逻辑块位图有关，它们代表了一个i节点或者一个逻辑块是否被使用。先来看一下关于逻辑块的：

**new_block**

```
int new_block(int dev)
{
	struct buffer_head * bh;
	struct super_block * sb;
	int i,j;

	if (!(sb = get_super(dev)))  //获取设备的超级快
		panic("trying to get new block from nonexistant device");
	j = 8192;
	for (i=0 ; i<8 ; i++)
		if (bh=sb->s_zmap[i])  //zmap保存的是逻辑块位图
			if ((j=find_first_zero(bh->b_data))<8192)  //扫描是否有空闲位置
				break;
	if (i>=8 || !bh || j>=8192)
		return 0;
	if (set_bit(j,bh->b_data))  //j代表找到的位置，置位j
		panic("new_block: bit already set");
	bh->b_dirt = 1;
	j += i*8192 + sb->s_firstdatazone-1;   //这边有点蒙蔽，有点不知道在干嘛。。。，应该在计算逻辑盘块号
	if (j >= sb->s_nzones)
		return 0;
	if (!(bh=getblk(dev,j)))  //申请缓冲块
		panic("new_block: cannot get block");
	if (bh->b_count != 1)
		panic("new block: count is != 1");
	clear_block(bh->b_data);  //清除缓冲块上的数据
	bh->b_uptodate = 1; //置位更新和修改位
	bh->b_dirt = 1;
	brelse(bh);   //释放盘块
	//上面四步目前不知道在干嘛。。。
	return j;  //返回逻辑盘块号
}
```

**free_block**

```
void free_block(int dev, int block)
{
	struct super_block * sb;
	struct buffer_head * bh;

	if (!(sb = get_super(dev)))
		panic("trying to free block on nonexistent device");
	if (block < sb->s_firstdatazone || block >= sb->s_nzones)
		panic("trying to free block not in datazone");
	bh = get_hash_table(dev,block);
	if (bh) {
		if (bh->b_count != 1) {
			printk("trying to free block (%04x:%d), count=%d\n",
				dev,block,bh->b_count);
			return;
		}
		bh->b_dirt=0;
		bh->b_uptodate=0;
		brelse(bh);
	}  //如果这个设备和逻辑块占用了某个缓冲块就释放
	block -= sb->s_firstdatazone - 1 ;
	if (clear_bit(block&8191,sb->s_zmap[block/8192]->b_data)) {  //清除那一位
		printk("block (%04x:%d) ",dev,block+sb->s_firstdatazone-1);
		panic("free_block: bit already cleared");
	}
	sb->s_zmap[block/8192]->b_dirt = 1;
}
```

这个文件中还有两个函数是用来更新i节点位图，分别是free_inode复位对应i节点位图的比特位，new_node为某个设备建立一个新的i节点，这个会在i节点获取一个新的空闲i节点表项。

###### inode.c

i节点是文件系统中的一个非常重要的概念，i节点存放着文件系统中文件的索引节点，每一个文件都有一个节点，一个i节点是32个字节，其中包括保存了文件类型属性，文件用户id，文件长度，修改时间，组id，文件链接数和文件占用的逻辑盘块数组。i_zone[9]代表着占用的逻辑盘块，其中0~6直接指向某个逻辑盘块，而7是一次间接指针，8是二次间接指针。

这个文件中主要包含对于inode操作的三个函数，iget()从设备上读取某个指定节点，iput()从设备上释放某一个i节点，bmap用于将文件数据块映射到盘块上。首先先来看bmap的操作：

**bmap**

```
static int _bmap(struct m_inode * inode,int block,int create)  //create代表要新申请一个磁盘块
{
	struct buffer_head * bh;
	int i;

	if (block<0)
		panic("_bmap: block<0");
	if (block >= 7+512+512*512)
		panic("_bmap: block>big");  //判断逻辑是否超过文件系统的承受范围
	if (block<7) {
		if (create && !inode->i_zone[block])  //如果需要新申请则new出一个逻辑块
			if (inode->i_zone[block]=new_block(inode->i_dev)) {
				inode->i_ctime=CURRENT_TIME;
				inode->i_dirt=1;
			}
		return inode->i_zone[block];  //直接指向的块
	}
	block -= 7;
	if (block<512) {  //说明是一级间接块
		if (create && !inode->i_zone[7])  //和上面同样的操作
			if (inode->i_zone[7]=new_block(inode->i_dev)) {
				inode->i_dirt=1;
				inode->i_ctime=CURRENT_TIME;
			}
		if (!inode->i_zone[7])
			return 0;
		if (!(bh = bread(inode->i_dev,inode->i_zone[7])))  //获取对应的数据缓冲块
			return 0;
		i = ((unsigned short *) (bh->b_data))[block];  //这个不懂再干嘛但是你要知道它返回的是逻辑盘块号
		if (create && !i)
			if (i=new_block(inode->i_dev)) {
				((unsigned short *) (bh->b_data))[block]=i;
				bh->b_dirt=1;
			}
		brelse(bh);
		return i;
	}
	block -= 512;   //以下是二级间接块
	if (create && !inode->i_zone[8])
		if (inode->i_zone[8]=new_block(inode->i_dev)) {
			inode->i_dirt=1;
			inode->i_ctime=CURRENT_TIME;
		}
	if (!inode->i_zone[8])
		return 0;
	if (!(bh=bread(inode->i_dev,inode->i_zone[8])))
		return 0;
	i = ((unsigned short *)bh->b_data)[block>>9];
	if (create && !i)
		if (i=new_block(inode->i_dev)) {
			((unsigned short *) (bh->b_data))[block>>9]=i;
			bh->b_dirt=1;
		}
	brelse(bh);
	if (!i)
		return 0;
	if (!(bh=bread(inode->i_dev,i)))
		return 0;
	i = ((unsigned short *)bh->b_data)[block&511];
	if (create && !i)
		if (i=new_block(inode->i_dev)) {
			((unsigned short *) (bh->b_data))[block&511]=i;
			bh->b_dirt=1;
		}
	brelse(bh);//释放该缓冲区
	return i;
}
```

**iget**

```
struct m_inode * iget(int dev,int nr) //返回一个i节点，给的参数是设备号和i节点号
{
	struct m_inode * inode, * empty;

	if (!dev)
		panic("iget with dev==0");
	empty = get_empty_inode(); //找一个空的inode
	inode = inode_table;  //定位到存储i节点的表
	while (inode < NR_INODE+inode_table) {  //找对应的inode
		if (inode->i_dev != dev || inode->i_num != nr) {
			inode++;
			continue;
		}
		wait_on_inode(inode);
		if (inode->i_dev != dev || inode->i_num != nr) {
			inode = inode_table;
			continue;
		}
		inode->i_count++;
		if (inode->i_mount) {  //这说明这个inode是其他文件系统的安装点，但是这是要干嘛？？？
			int i;

			for (i = 0 ; i<NR_SUPER ; i++)
				if (super_block[i].s_imount==inode)
					break;
			if (i >= NR_SUPER) {
				printk("Mounted inode hasn't got sb\n");
				if (empty)
					iput(empty);
				return inode;
			}
			iput(inode);
			dev = super_block[i].s_dev;
			nr = ROOT_INO;
			inode = inode_table;
			continue;
		}
		if (empty)
			iput(empty); 
		return inode;  //这里代表了对应的i节点已经被找到了，因此就释放之前申请的空闲的块，然后返回找到的块
	}
	if (!empty)
		return (NULL);
	inode=empty;   //没有找到对应的就申请一个新的i节点
	inode->i_dev = dev;
	inode->i_num = nr;
	read_inode(inode);
	return inode;
} //为什么要占一个空闲块先？
```

**iput.c**

```
void iput(struct m_inode * inode)
{
	if (!inode)
		return;
	wait_on_inode(inode);
	if (!inode->i_count)
		panic("iput: trying to free free inode");
	if (inode->i_pipe) {  //说明它是一个管道i节点，但是不清楚下面的操作暂时
		wake_up(&inode->i_wait);
		if (--inode->i_count)
			return;
		free_page(inode->i_size);
		inode->i_count=0;
		inode->i_dirt=0;
		inode->i_pipe=0;
		return;
	}
	if (!inode->i_dev) {
		inode->i_count--;
		return;
	}
	if (S_ISBLK(inode->i_mode)) {
		sync_dev(inode->i_zone[0]);
		wait_on_inode(inode);
	}
repeat:
	if (inode->i_count>1) {
		inode->i_count--;
		return;
	}
	if (!inode->i_nlinks) {  //如果这个i节点的链接数已经减少为0了，则释放该i节点并且释放所有使用到的逻辑块
		truncate(inode);
		free_inode(inode);
		return;
	}
	if (inode->i_dirt) {  
		write_inode(inode);	/* we can sleep - so do again */ //如果被修改了就需要写将节点信息写入设备
		wait_on_inode(inode);
		goto repeat;
	}
	inode->i_count--;
	return;
}
```

其中其实还有两个辅助函数write_inode和read_inode,就是将数据从设备读取i节点所在的逻辑块然后复制其中的内容，还有就是及那个i节点的信息复制到逻辑快对应的i节点中，执行方法如下：

```
read_inode.c:
if (!(bh=bread(inode->i_dev,block)))
		panic("unable to read i-node block");
	*(struct d_inode *)inode =
		((struct d_inode *)bh->b_data)
			[(inode->i_num-1)%INODES_PER_BLOCK];
write_inode.c:
if (!(bh=bread(inode->i_dev,block)))
		panic("unable to read i-node block");
	((struct d_inode *)bh->b_data)
		[(inode->i_num-1)%INODES_PER_BLOCK] =
			*(struct d_inode *)inode;    //这里需要理解这个b_data到底怎么存储的信息
```

