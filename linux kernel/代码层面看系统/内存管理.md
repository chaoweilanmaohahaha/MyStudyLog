# 内存管理

在8086CPU中，程序在寻址过程中采用段和偏移组成的虚拟地址，但是这个地址并不能直接使用来寻找物理内存地址。因此虚拟地址会通过段管理机制变换成一种32位线性地址，然后再通过分页管理机制来映射到物理地址处。

在8086CPU中，内存分页管理是通过页目录表和内存页表所组成的二级表来进行的。页目录表每个表项是4B用来寻址一个页表，每个页表项时4B用来寻址一个物理内存页。因此一个页表占用一页内存，而一个页表也占用一页内存。所有进程都使用一个页目录表，而每个进程都有自己的页表。

一个32位线性地址被分为了三个部分，分别指定了页目录项，页表项和对应的物理偏移地址。一个系统中可能同时存在多个页目录表。当前的页目录表是用CPU的寄存器CR3来确定的。页目录项和页表项12-31位代表了页框地址，后面12位是标志位。

为了节省物理内存，在调用fork生成一个新进程时，新进程与原进程会共享一个内存区，只有当其中一个进程需要进行写操作时，系统才会为其另外分配内存页面。因此这个操作可以总结成：写操作->页面异常中断->处理写保护异常->重新执行写操作。

###### memory.c

这个文件是用来进行内存分页管理的，其中实现了对主内存区内存的动态分配和收回操作，这里面用了一个mem_map来表示主内存中所有物理内存页的状态。

*unsigned long get_free_page(void)*

这个函数就是获取第一个空闲页面，扫描了mem_map函数，如果有空余页面，置位。

*void free_page(unsigned long addr)*

释放了从addr开始的一页面内存，这个需要复位mem_map。

**free_page_table**

```
int free_page_tables(unsigned long from,unsigned long size)
// 该函数只处理释放4MB的内存块
{
	unsigned long *pg_table;
	unsigned long * dir, nr;

	if (from & 0x3fffff)
		panic("free_page_tables called with wrong alignment");
	if (!from)
		panic("Trying to free up swapper memory space");
	size = (size + 0x3fffff) >> 22;   //计算占页表数
	dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */ //计算起始目录项
	for ( ; size-->0 ; dir++) {
		if (!(1 & *dir))
			continue;
		pg_table = (unsigned long *) (0xfffff000 & *dir);  //从页目录项中抽取页表项
		for (nr=0 ; nr<1024 ; nr++) {
			if (1 & *pg_table)
				free_page(0xfffff000 & *pg_table);  //释放物理页
			*pg_table = 0;
			pg_table++;
		}
		free_page(0xfffff000 & *dir); // 释放页表所占内存
		*dir = 0;
	}
	invalidate();
	return 0;
}
```

**copy_page_tables**

复制一定范围内线性地址中的内容，但这个函数不复制任何内存块，

```
int copy_page_tables(unsigned long from,unsigned long to,long size)
{
	unsigned long * from_page_table;
	unsigned long * to_page_table;
	unsigned long this_page;
	unsigned long * from_dir, * to_dir;
	unsigned long nr;

	if ((from&0x3fffff) || (to&0x3fffff))
		panic("copy_page_tables called with wrong alignment");
	//计算了源地址和目的地址目录项地址
	from_dir = (unsigned long *) ((from>>20) & 0xffc); /* _pg_dir = 0 */
	to_dir = (unsigned long *) ((to>>20) & 0xffc);
	size = ((unsigned) (size+0x3fffff)) >> 22;  //计算页表项
	for( ; size-->0 ; from_dir++,to_dir++) {
		if (1 & *to_dir)
			panic("copy_page_tables: already exist");
		if (!(1 & *from_dir))
			continue;
		from_page_table = (unsigned long *) (0xfffff000 & *from_dir);  //源地址的页表地址
		if (!(to_page_table = (unsigned long *) get_free_page())) //给目的地址分配新的页表
			return -1;	/* Out of memory, see freeing */
		*to_dir = ((unsigned long) to_page_table) | 7;   //设置标志
		nr = (from==0)?0xA0:1024;  //选择复制页表项数，内核复制头160页，否则复制1024页
		for ( ; nr-- > 0 ; from_page_table++,to_page_table++) {
			this_page = *from_page_table;
			if (!(1 & this_page))
				continue;
			this_page &= ~2;
			*to_page_table = this_page;
			if (this_page > LOW_MEM) {  //1M以上设置mem_map
				*from_page_table = this_page;
				this_page -= LOW_MEM;
				this_page >>= 12;
				mem_map[this_page]++;
			}
		}
	}
	invalidate();
	return 0;
}
```

**put_page**

```
unsigned long put_page(unsigned long page,unsigned long address)
{
	unsigned long tmp, *page_table;

/* NOTE !!! This uses the fact that _pg_dir=0 */

	if (page < LOW_MEM || page >= HIGH_MEMORY)
		printk("Trying to put page %p at %p\n",page,address);
	if (mem_map[(page-LOW_MEM)>>12] != 1)
		printk("mem_map disagrees with %p at %p\n",page,address);
	page_table = (unsigned long *) ((address>>20) & 0xffc);  //取到页表地址
	if ((*page_table)&1)
		page_table = (unsigned long *) (0xfffff000 & *page_table);  //该页在内存中取到页表项
	else {
		if (!(tmp=get_free_page()))  //否则申请页面
			return 0;
		*page_table = tmp|7;
		page_table = (unsigned long *) tmp;
	}
	page_table[(address>>12) & 0x3ff] = page | 7;  //在该页中设置指定页内容，
/* no need for invalidate */
	return page;
}
```

**un_wp_page**

取消写保护页面函数，写时复制时通过页异常中断来处理写保护，通过do_wp_page调用

```
void un_wp_page(unsigned long * table_entry)
{
	unsigned long old_page,new_page;

	old_page = 0xfffff000 & *table_entry;
	if (old_page >= LOW_MEM && mem_map[MAP_NR(old_page)]==1) {
		*table_entry |= 2;  //解除该页的写保护
		invalidate();
		return;
	}
	if (!(new_page=get_free_page()))
		oom();
	if (old_page >= LOW_MEM)
		mem_map[MAP_NR(old_page)]--;
	*table_entry = new_page | 7;
	invalidate();
	copy_page(old_page,new_page);  //复制页面
}	
```

**try_to_share**

在任务p中区检查位于address的页面是否存在并且是否干净，如果干净就和当前进程共享。

```
static int try_to_share(unsigned long address, struct task_struct * p)
{
	unsigned long from;
	unsigned long to;
	unsigned long from_page;
	unsigned long to_page;
	unsigned long phys_addr;

	from_page = to_page = ((address>>20) & 0xffc); //指定地址的页目录项
	from_page += ((p->start_code>>20) & 0xffc);  //进程p起始地址对应的页目录项
	to_page += ((current->start_code>>20) & 0xffc);  //当前进程起始地址对应的页目录项
/* is there a page-directory at from? */
	from = *(unsigned long *) from_page;
	if (!(from & 1))
		return 0;
	from &= 0xfffff000;  // 当前p进程的页表地址
	from_page = from + ((address>>10) & 0xffc);  //页表项
	phys_addr = *(unsigned long *) from_page;
/* is the page clean and present? */
	if ((phys_addr & 0x41) != 0x01)
		return 0;
	phys_addr &= 0xfffff000;   //物理地址
	if (phys_addr >= HIGH_MEMORY || phys_addr < LOW_MEM)
		return 0;
	to = *(unsigned long *) to_page;  //当前进程和之前一样处理，提取页表项
	if (!(to & 1))
		if (to = get_free_page())
			*(unsigned long *) to_page = to | 7;
		else
			oom();
	to &= 0xfffff000;
	to_page = to + ((address>>10) & 0xffc);
	if (1 & *(unsigned long *) to_page)
		panic("try_to_share: to_page already exists");
/* share them: write-protect */
	*(unsigned long *) from_page &= ~2;
	*(unsigned long *) to_page = *(unsigned long *) from_page;  //共享
	invalidate();
	phys_addr -= LOW_MEM;
	phys_addr >>= 12;
	mem_map[phys_addr]++;
	return 1;
}
```

do_no_page

缺页中断

```
void do_no_page(unsigned long error_code,unsigned long address)
{
	int nr[4];
	unsigned long tmp;
	unsigned long page;
	int block,i;

	address &= 0xfffff000; //页面地址
	tmp = address - current->start_code;  //计算页面地址关于进程基址的偏移
	if (!current->executable || tmp >= current->end_data) {
		get_empty_page(address);  //说明超过了对应的代码和数据长度，重新申请一页物理内存
		return;
	}
	if (share_page(tmp))  //尝试和其他进程共享页面
		return;
	if (!(page = get_free_page())) //取新的页面
		oom();
/* remember that 1 block is used for header */
	block = 1 + tmp/BLOCK_SIZE; //计算缺页所在的数据块项
	for (i=0 ; i<4 ; block++,i++) 
		nr[i] = bmap(current->executable,block);  //取对应的逻辑块号
	bread_page(page,current->executable->i_dev,nr);  //向该页中写入数据
	i = tmp + 4096 - current->end_data;  //将对物理页面超出的部分清0
	tmp = page + 4096;
	while (i-- > 0) {
		tmp--;
		*(char *)tmp = 0;
	}
	if (put_page(page,address))  //将物理页面映射到指定的线性地址中
		return;
	free_page(page);
	oom();
}
```

###### page.s

这个文件是页异常中断处理程序，这里的页异常只有两种，要么是缺页产生的异常，要么是撤销写保护产生的异常，其中CR2保存了出现异常时访问的线性地址。

```
_page_fault:
	xchgl %eax,(%esp)
	pushl %ecx
	pushl %edx
	push %ds
	push %es
	push %fs
	movl $0x10,%edx
	mov %dx,%ds
	mov %dx,%es
	mov %dx,%fs 
	movl %cr2,%edx  //出错地址
	pushl %edx    //压入出错地址
	pushl %eax		//压入出错码
	testl $1,%eax    //看是否时缺页，如果是缺页的话跳入缺页中断处理，否则跳入取消写保护
	jne 1f
	call _do_no_page
	jmp 2f
1:	call _do_wp_page
2:	addl $8,%esp
	pop %fs
	pop %es
	pop %ds
	popl %edx
	popl %ecx
	popl %eax
	iret

```

