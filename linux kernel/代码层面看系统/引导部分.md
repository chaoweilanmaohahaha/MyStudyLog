# linux 引导部分解析

这一部分主要介绍linux0.11内核版本下，系统是如何将内核加载进来，有关内核的引导程序的介绍。

关于linux引导部分的代码在boot文件夹下主要包括bootsect.s,setup.s,head.s三个文件来完成。前两者都是使用x86的汇编书写，head.s采用AT&T风格汇编来书写，因此在编译过程中，前两者采用as86来进行编译，而后者采用gas来进行。

当电脑开机时，计算机默认运行在实模式下（寻址空间1M），存储在ROM-BIOS的程序会对系统进行检测，然后从物理地址0处开始初始化中断向量。随后它将磁盘的第一个扇区也就是所谓引导扇区，也就是存在的bootsect.s代码默认加载到0x7C00处，随后运行该代码。

#### bootsect.s在干嘛

这段代码的第一步是将自己移动到内存0x9000处，然后它会将setup.s代码通过13号中断从磁盘加载到它的后面也就是内存地址0x90200处，再读取引导盘的参数，将system模块，也就是带有内核代码和head.s的模块移动到内存地址开始的0x10000处，当时的内核保证代码长度不会覆盖到bootsect.s,这也是为什么要把自己搬一下位置，在腾空间呢！当做完这些后，长跳转到setup执行它的代码。

感觉哈这个里面因为设计很多读写磁盘的操作，还是有必要了解一下13号中断的。

#### setup.s在干嘛

setup的代码从0x90200开始，它首先要从系统中读取系统参数，并保存在0x90000开始的内存区域中，也就是覆盖上面的bootsect.s，然后它将system模块下移到物理地址0x00000处，随后加载gdt(全局描述符表）和idt（中断描述符表），然后开启A20地址线（这个是因为计算机的发展，存储空间的扩展导致寻址空间要发生变化，而地址线也要跟着变，这里因为马上就要进入保护模式了，寻址空间要发生变化了，而老式电脑的寻址空间很小。），随后重新设置中断控制芯片8259，最后通过设置CPU控制寄存器CR0进入32位保护模式。

在这中间用到了15号中断和10号中断值得了解。

同时有几个问题还是要想一下，在这一步中允许system模块移动到物理地址0处是因为在这一步中重新设置了中断了，因此接下来不需要使用BIOS提供的中断了，在此之前仍需使用其中的数据所以不能覆盖。这里设置了gdt和idt是给截下来运行的head.s临时创建使用的，这一点需要注意。

#### head.s在干嘛

head.s主要的工作是在分页，此时系统运行在了保护模式下了，那么在head.s中需要重新再设置一次gdt和idt这是以后真正要用到的。随后进行必要的硬件检测，然后置为CR0中的GP位，告诉系统要进行分页的操作，然后开始分页，使用CR3寄存器指向页目录表。在程序的最后是有一个小trick的，那就是当分页函数ret的时候需要执行截下来的系统初始化函数main.c，则在执行之前需要将main.c压入堆栈中，当函数返回时默认弹出main.c,然后开始进行初始化。



#### 以上就是系统的引导过程啦！！