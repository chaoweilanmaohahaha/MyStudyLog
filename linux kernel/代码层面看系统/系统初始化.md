# linux 系统初始化部分解析

这一部分承接之前讲到的引导部分的，那么当系统完成引导后就已经完成了从实模式到保护模式的转换，同时完成了将内核模块整体搬运进内存中，内存的开辟和页表的建立等步骤。我们可以看到最后一步它将初始化函数init/main.c压入栈中，当所有步骤都完成后将该地址弹出转而开始进行系统初始化，那么系统初始化调用的就是init/main.c中的main函数。

###### main.c 到底干了什么？

第一步要完成的是初始化部分，其中包括内存部分初始化，中断向量初始化，字符设备初始化，tty初始化，硬盘初始化，缓冲管理初始化，软驱初始化，然后开中断进入用户模式（move_to_user_mode()，这也说明上述部分都是在内核模式下运行的）。然后从之后开始系统会新建一个子进程1，那么也就是说在移动到用户模式下进行运行的就是进程0，而此时通过fork系统调用，代码从此出现分叉。而如果系统中没有多余任务执行而回到进程0，则系统会进入死循环，知道有进程被调度：

```
for(;;) pause();
```

###### 第一个进程在干嘛？

在第一个进程中，系统加载根文件系统，并且打开终端设备。

```
set((void *)&drive_info)
(void) open("/dev/tty0", O_RDWR, 0)
```

然后它又会创建一个子进程，但是这个子进程到底干了啥，目前还不知道。而父进程则会等待子进程的状态，如果子进程退出了，又会继续创建新的子进程。

#### 初始化的一些事

其实初始化部分这样掠过讲会有点草率，可能大体知道了但是不知道它是怎么实现的。

###### 中断处理程序

中断其实是一个很重要的话题，它从系统引导部分就开始有很多使用了。中断在系统中分为硬件中断和软件中断（异常），其中中断号0~31是intel所固定的软件终端，而32~255是自定义中断。在linux中32~47号中断对应了8259芯片产生的硬件中断请求信号，而所谓的系统调用中断被分配在128号

发生中断时需要向堆栈中压入许多东西，它会把代码段选择符SS，返回地址偏移ESP，标志寄存器EFLAGS，如果系统从用户级进入内核级会讲代码段CS和堆栈指针EIP压入栈中，如果CPU内部产生出错码的话也会压入栈中。对于有无出错码，程序会有不同的实现，但是大差不差。

异常故障处理程序依赖asm.s文件，我们挑其中一些函数来看就行了：

```
_divide_error：
	pushl $_do_divide_error  //函数地址入栈
no_error_code:
	xchgl %eax, (%esp)
	pushl %ebx
	pushl %ecx
	pushl %edx
	pushl %edi
	pushl %esi
	pushl %ebp
	push %ds
	push %es
	push %fs
	pushl $0  // error code
	movl $0x10, %edx   // 段描述符
	mov %dx, %ds
	mov %dx, %es
	mov %dx, %fs
	call * %eax   //调用中断函数
	addl $8, %esp
	pop %fs
	……
	popl %eax
	iret
```

当系统完成了之前提到的压栈过程后，在正式处理中断时还会将所有寄存器进行压栈，然后调用中断处理程序，最后弹栈还原现场。其他函数在完成函数地址入栈后就可以去调用no_error_code部分的代码了。那么如果有出错码呢？

```
_double_fault:
	push $_do_double_fault
error_code:
	xchgl %eax, 4(%esp)
	xchgl %ebx, (%esp)
    pushl %ecx
    pushl %edx
    pushl %edi
    pushl %esi
    pushl %ebp
    push %ds
    push %es
    push %fs
    pushl %eax   // 出错码入栈
    lea 44(%esp) ,%eax   //返回地址
    pushl %eax
    ……  //以下和no_error_code一致
```

那么很显然，多了一步有关出错码的操作，其他和没有出错码的过程一样。

那么附带有一个trap.c文件，这个文件就是asm.s中调用的相应的故障处理C函数，其中的die函数专门用来打印出错信息，而trap_init() 函数就是在初始化中提到的用来初始化中断向量的函数。在设置中断向量时使用了set_trap_gate() 和set_system_gate()方法，将中断号和中断处理程序绑定。

注意，以上的中断都是系统固有的中断和硬件中断的初始化与使用，那么关于系统调用，专门有一个文件叫做system_call.s，它实现了系统调用的处理过程。着重来看系统调用这部分，其他的在这个文件中提到的中断处理方法与之类似：

```
_system_call:
	cmpl $nr_system_calls-1 %eax  //eax中存放调用号
	ja bad_sys_call
	push %ds
	push %es
	push %fs
	pushl %edx
	pushl %ecx
	pushl %ebx
	movl $0x10, %edx  //内核数据段
	mov %dx, %ds
	mov %dx, %es
	movl $0x17, %edx  //局部数据段
	mov %dx, %fs
	call _sys_call_table(, %eax,4)
	pushl %eax
	movl _current, %eax   //当前任务数据结构地址
	/*
		这里的代码过程主要在判断：当前任务的状态，时间片，初始任务状况，是否是超级用户程序，用户堆栈等
	*/
	call _do_signal //C函数信号处理程序
	popl %eax
	popl %eax
	popl %ebx
	popl %ecx
	popl %edx
	pop %fs
	pop %es
	pop %ds
	iret
```

其实在实现方法上大同小异，在这里真正去调用中断处理程序时是去sys_call_table结构查找的，这个在sys.h中定义了72个系统调用C处理函数。

---

**sche_init**

这个函数在调度程序中讲解。

**blk_dev_init**

初始化设备请求数组request，将它们置为空闲项，一共有32项。

**hd_init**

这个初始化函数是初始化了硬盘中断

```
blk_dev[MAJOR_NR].request_fn = DEVICE_REQUEST  //将硬盘设备的请求句柄设置为do_hd_request
set_intr_gate(0x2E, &hd_interrupt)  //设置硬盘中断门向量
```

