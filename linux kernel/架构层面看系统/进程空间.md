# 进程空间

如果说之前讲内存空间，都是从内核的角度和实际物理内存的角度来看内存空间具体是如何实现的，那么这一章节的内容就是聚焦整个在用户空间中，针对一个进程，它的内存空间到底是怎么样的呢？

**说在前面**

首先我们都知道一点，因为存在了分段和分页的机制，因此在整个操作系统中我们能够看到的一共有三种地址：虚拟逻辑地址，线性地址和物理地址。MMU部件能够做到将虚拟逻辑地址转换为线性地址，然后再从线性地址转换为物理地址。但是在以下的讲解中都是依赖了IA32架构的支撑，而在IA32中虽然声称可以分段，但是实际并没有分段这个机制，它默认将段基址设为0，段限长设为4G，这样使得虚拟逻辑地址就和线性地址一样了，因此以下所谓的虚拟地址其实和线性地址可以理解为是一个概念。

那么在linux中，每个进程都会独占4G的线性地址空间，而这个4G也从前面的章节看到了，切割成了用户空间和内核空间两部分。而对于内核空间而言，系统应当是绝对信任的，但是用户空间就不一定了，执行的程序有着各种各样的限制。通过硬件的一些处理可以保证对于每一个进程而言，看到的内核空间都是相同的。

## 地址空间分布

在进程的用户空间中，我们可以看到这些部分：

* 当前正在运行的代码，也就是代码段；
* 程序需要的动态库文件
* 全局变量和动态生成的变量，也就是堆空间；
* 局部变量和用户函数调用的区域，也就是栈空间；
* 环境变量和参数
* 内存映射到文件内容的映射空间。

那么一个进程中对以上的信息的一个具体描述保存在了task_struct中的mm_struct中了，其中告诉了各个区域具体的一个起始点和终止点地址，同时给出了一个mmap_base指定打开mmap的地址区域范围。

这里有那么几点说明：

1. 其中在设置这个结构的过程中会遇到一个标志称为PF_RANDOMIZE，如果这个标志置位了，表示进程空间中的栈的起始位置和内存映射的起始位置是随机的，这是使得攻击者不能根据一个给定的位置来实施攻击。
2. 普通的进程空间各个区域的生长方向如下：堆空间从低地址向高地址生长直到mmap_base，内存映射区域从mmap_base区域向高地址生长，栈空间由最高地址向低地址生长，直到两个区域碰上。参数列表和环境变量是存放在栈中的。但是由于空间的限制，在IA32中进程的栈空间是被限制指定的大小的，而内存映射空间是从上至下和堆空间面对面生长的。
3. text段是在整个进程空间的最底段位置，但是并不是直接从0开始，它会被映射到一个指定的开始地址处：比如IA32中是从0x08048000 。

在执行exec系统调用的时候，根据执行的ELF中的信息，完成这个进程地址空间的初始化。主要的过程就是在填充这个mm_struct中的各个结构中的参数。那么栈空间保证了它至少要有128M。

## 内存映射

你依旧得知道一点，用户进程的地址空间很大，要比物理内存大很多，所以物理内存中只会保存进程常用的信息。比如对于一个文件而言，可能如果我们是在写一个文件那么内存可能只关心文件的末尾位置，对于代码段也是一个道理。所以简单的认为，内核必须要使得虚拟地址空间中的部分区域和数据存储的位置产生 一个映射，这就是内存映射。那么将数据放到物理页上的操作就变成了按需分配。

如果进程想要访问的某个地址没有在页表中，此时会触发缺页异常，内核会去后被存储中去取，随后装载到内存中。

## 数据结构

着重来看一下内存映射需要的数据结构。在mm_struct中有这么一些结构：

```C
struct mm_struct {
    struct vm_area_struct *mmap;
    struct rb_root mm_rb;
    struct vm_area_struct *mmap_cache;
    ...
}
```

在映射中，每一个单独的区域是一个vm_area_struct 的实例，他们被存放在两个地方，一根单链表mmap和红黑树mmrb上（起始道理上只需要一个队列就行了，但是为了查找快所以使用了红黑树）。

每一个vm_area_struct结构的表示就比较复杂了，但是每一个内容都很重要。

```C
struct vm_area_struct {
    struct mm_struct *mm;  // 回向指针，指向包含他的mm_struct
    unsigned long vm_start;  // 在用户空间中该区域的起始地址，和结束地址
    unsigned long vm_end;
    
    struct vm_area_struct *vm_next;  // 指向下一个区域的指针
    
    pgprot_t vm_page_prot; // 存放着该区域的访问控制标志
    unsigned long vm_flags;  // 代表这个区域的一些标志
    
    struct rb_node vm_rb;  // 挂在红黑树上的结点
    
    union {
        struct {
        	struct list_head list;
            void *parent;
            struct vm_area_struct *head;
        } vm_set;
        struct raw_prio_tree_node prio_tree_node;
    } shared;  // 共享映射，这个后续会介绍
    
    struct list_head anon_vma_node;
    struct anon_vma *anon_vma;  // 这两个参数用来管理由匿名映射残生的共享映射
    
    struct vm_operations_struct *vm_ops;  // 存放了处理这个区域需要使用的所有句柄
    
    unsigned long vm_pgoff;  // 如果有文件映射到了这篇区域，这个值表示的是当前文件的偏移位置
    
    struct file *vm_file;  // 映射到这里的文件实例
    void *vm_private_data;  // 隐私信息
}
```

### 优先搜索树

这是一个比较重要的数据结构，因为后面的逆向映射就会用到。这棵树是用来建立一个文件中的一片区域（vm_area_struct）和所有这个区域映射到的所有虚拟地址的一个关系。

所有打开的文件都会使用一个数据结构file存放，而这个结构中会使用一根指针指向一个地址address_space，而这个结构就是这颗优先搜索树的首先关键。这个结构中含有所有映射到这个文件一个个区间的vm_area_struct实例。这些实例被挂在了优先搜索树上。**所以注意，一个vm_area_struct可以被挂载两个地方：一个是建立了进程空间和打开文件的关系，一个表示了所有映射到该文件片段上的地址空间。**

在优先搜索树种管理的区域，映射的区间不能有重叠。而如果出现有多个区域映射到了同一个文件片段上，可以看到在vm_area_struct种shared共享映射部分是一个联合体，如果只是一个结点，那么它被raw_prio_tree_node表示，否则就是vm_set来表示，其中的head部分指向第一个加入的相同的那个vm_area_struct，而所有的区域连在那个链表上。

## 有关区域的操作

在上面介绍了，所有和文件的映射关系切分成了一个个小的区域，那么接下去内核中就会给出具体的操作来处理这些区域。

### 建立虚拟地址和区域的关系

内核中使用find_vma这个函数来找到合适的区域。这个函数的参数中会指定addr，那么找到的区域的位置的结束位置应该在addr的后面。首先内核会去mmap_cache看是否满足条件，如果不满足就去红黑树中寻找合适的区域，并把这个区域放入到cache中。

### 合并

如果有一个区域被添加到进程中，内核需要查看这个区域是否可以和背的区域合并。方法很直接，就是找到这个区域的前向结点，前向节点的尾部地址一定要比该区域开始地址大；随后内核检测这两个区域的映射片段是否相同，那就可以将这两个区域合并。

### 插入

插入一个结点需要两个步骤，你首先需要一些信息保证你的插入，包括插入点的前继的地址，红黑树上的父节点等。当找到了这些信息之后，就需要调用真正的插入函数插入到1、map队列中；2、红黑树上；3、可能是匿名映射队列中。最后需要需要将这个信息更新到优先搜索书上。

### 创建

在插入操作之前，绝对需要从虚拟地址空间上找到一个空闲的，指定长度的一片区域来，这个操作交给了函数get_unmapped_area来完成。如果在这个函数中有指定了addr参数，就直接使用find_vma函数获取，否则先去已经cache的区域中查找合适的区域，如果还没有则从进程的mmap_base去找一个空闲的区域。

## Address space结构

每个文件的映射都有这么一个结构，这个结构除了上面说的包含了所有映射的区域，还包括了许多操作函数，包括writepage写函数，readpage读函数，writepages写函数， readpages读函数。对于读函数来说，就是从块设备上把数据读到内存，写函数就是把数据写回块设备。

## 映射操作

那么其实讲了这么多也没有讲到具体的将文件映射到一个进程地址空间到底是怎么做的。那么如果要使得内核和一个应用程序建立内存上的映射，需要使用的是函数mmap，这个函数触发了系统调用mmap。它的目的是建立了在用户地址空间中pos位置上长度为len的一个映射。

### 建立映射

下面就是详细讲讲上面那个mmap到底怎么做的喽。最底层调度的是do_mmap_pgoff，在这个函数中其实有很大一部分都是在检测状态参数，这些我们把它忽略，那么首先我们需要使用get_unmapped_area获取一个空闲的区域。然后计算一下对于这个区域的标志位，我们就可以通过find_map_prepare去查找插入需要的信息，随后创建一个新的vm_area_struct，加上映射文件的句柄。最后返回找到的区域的地址。

### 移除映射

使用munmap函数。这个函数首先做的还是找到对应的映射，但是注意的是，找到了之后的区域的其实地址如果并不是指定的地址，那就需要对分配的区域进行一次切割；同理对于后面一半的区域也要判断是否要切割。做完切割操作之后，就需要使用unmap_region函数抹去所有这个映射的信息。

### 非线性映射

大部分映射文件都是映射一个连续的部分，但是也有可能出现这种情况，文件多个不同的部分映射到了另外一个虚拟空间的一片连续区域，那么就需要使用非线性映射了。这个的方法是对映射进行重排序，这个操作需要借助页表来实现。这个操作需要完成将一个指定位置指定长度的映射移动到一个新的位置。那么此时如果这个映射突然被交换了出去，内核必须能在换回来时确保原来的偏移，那么这些信息都应该保存在页表中。建立的非线性映射的nonlinear mapping保存在了address space中的i_mmap_nonlinear中，如果你要从vm_area_struct中查看，可以直接从shared.vm_set.list中查找（因为非线性映射并不在优先搜索树上出现）；并且这样的映射在页表上的表示也需要进行特殊的处理。

一个页表项中我们可以这样使用来进行非线性的映射。我们知道最后一位一定是页项存在位。那么在表项倒数第二位为1表示这是一个非线性映射，随后除了最高位之外的61位作为非线性映射的偏移。

好了，此时我们再来看这个remap的过程。使用find_vma找到对应的区域，如果这个区域还没被remap那么设置它的标志位，并且将它从优先搜索树上删除，加入到非线性映射的队列中。最后你要给出一个被魔改过的页表入口，这一步需要遍历所有页表，然后移除之前可能存在的页表项，然后添加新的页表项。

## 逆向映射