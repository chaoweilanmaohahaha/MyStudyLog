# 进程与调度

其实对于进程与调度而要最重要的几个问题无非就是进程的隔离以及进程调度问题，而关于进程调度，内核又需要直到当时间片结束之后应该选择谁来参与调度，每一个进程又应当给与多大的时间片运行，调度过程中从A进程到B进程的切换要保存A进程的现场，这些问题都值得考虑，先一步一步来看linux（2.6）中有关进程的知识点：

### 进程优先级

linux系统是一个抢占式的多任务系统。进程的优先级影响到进程被调度时的选择，在内核0.11版本的代码中已经有了进程优先级的概念了，当所有进程时间片都用完后，总需要挑选一个进程参与调度，这就要借助进程优先级。其实对于一个进程而言一般划分为实时进程与非实时进程两种。

* 实时进程：这样的进程需要在一个特定的时间内完成。所以这一类进程有个比较核心的特征就是进程调度时需要带有一个时间帧结构，并且系统要保证进程运行的时间不能超过这个帧长。但是这一类进程在linux中并不是十分支持。
* 软实时进程：这类进程与上面的实时进程比较类似，但是这些进程也需要较快被处理，只不过相对可以被延后一些。
* 普通进程：这时绝大多数进程属于的类型，这类进程没有对于时间特别的限制，但是要注意这类进程也可以再给它们赋予优先级来表示各自的重要程度。

那么系统根据这些优先级，也就是进程的重要程度来分配时间片。你可以想象一下一个简单的模型，所有的进程相当于围成一个圈，有一个监视器在扫描这个圈，如果某一个进程的时间片耗尽就调度下一个进程，然后如果上一个进程还没运行完保存对应的寄存器和页表信息。

### 进程的生命周期

简单的说一个进程并不是时时刻刻都在运行，进程可以处于不同的状态：

* 运行态：进程占用着CPU和相应的资源，正在运行。
* 就绪态：进程能够运行的标志是它已经拿到了所有需要的资源了，只需要获取CPU的调度就可以参与运行。
* 睡眠（阻塞）态：这种状态是不能被调度的，需要一个外部事件的触发来唤醒。

调度程序需要直到所有进程的状态从而进行判断应该调度哪个程序，既然有这么多状态，进程必然是可以从这些状态中切换的。

当一个进程拥有了所有资源而准备运行时，重要它被分配到了CPU时间，它就从就绪态转变为了运行态，而在运行中的进程如果失去了CPU则就又回到了就绪态；如果在运行中的进程因为需要某个事件的发生而无法继续运行下去了，则它必须从运行态进入阻塞态。而如果这个事件发生了，则阻塞态的进程也就具备了被调度的资源，这样该进程被修改为就绪态等待调度。如果进程运行完了，那么它会进入停止态。在这里有一个特殊的进程状态：**僵死态**。这种状态的进程资源已经被系统回收了，但是它仍然存在于进程表中，这种状态只有在一个程序被用户直接杀死时才会出现。

对于一个进程而言，它又有两种运行模式：**用户模式**和**内核模式**。运行在用户模式下的进程只能在自己的内存空间下运行，但是内核模式则拥有所有的权限。如果一个进程需要获取系统数据和系统函数，则必须进入内核模式，一共有两种方法可以做到：**系统调用**和**中断**。系统调用是人为控制的，但是中断不是，中断和正在跑的进程可以说基本没有关系。中断可以改变进程的状态：普通的进程是可以被中断的；在内核模式下处理系统调用是无法被收回CPU的，除非碰到一个中断，中断可以使用户模式和内核模式下的程序终止，它有最高的优先级。

### 进程表示

在内核代码中一个进程的表示是通过一个名叫task_struct的数据结构定义的，这里不能展示它所有的成员因为实在是太多了，先做个小总结在里面都有些什么：

* 进程执行时信息，包括pid，信号，父亲指针和兄弟指针，时钟等
* 虚拟内存信息
* 进程附带的用户和组信息
* 文件信息
* 线程信息
* 信号处理信息

在这里顺便讲一下在上面提到的状态，在这个里面是由一个叫state的参数，它被指派为一系列已经定义好的宏定义：

* TASK_RUNNING:正在运行或者就绪的状态；
* TASK_INTERRUPTIBLE: 一般的阻塞状态；
* TASK_UNINTERRUPTIBLE: 只能被内核唤醒而不能由外部事件唤醒的阻塞状态；
* TASK_STOPPED: 停止状态。

这里再带过一个知识点，linux内核中给每一个进程提供了一个资源限制机制，用rlimit结构表示，这部分信息被存储在proc文件系统中

##### 进程类型

你可以通过如下三种方式来生成新的进程：

**fork**：在父进程的基础上生成子进程，生成的过程是就是将所有父进程的资源统统拷贝一份下来，经过这个系统调用后，就会有两个独立的示例跑在原始的进程上。

**exec**：这个加载一个新的可执行文件来代替一个运行的进程，其实准确地说，exec并不会产生一个新进程，就是加载一个新的程序，具体步骤是先将老进程fork一下，然后执行exec调用。

**clone**：这个调用的操作和fork类似，只不过生成的实例不是一个独立的实例，需要和父进程共享一些资源。因此这个方法一般用来建立线程。

##### 名空间

这个概念比较特别，它的本意是做到空间隔离的效果。一个名空间你可以把它看成是一个单独的linux系统，在系统中有许多全局变量需要被管理，那么这些全局变量可以映射到某个名空间中，而两个名空间之间关于这些变量是隔离的，你无法从一个名空间中去查看另一个名空间中的变量，因此给人的感觉是一个个独立的linux系统，在这个名空间上你也运行着init方法和其他子进程。名空间是由继承性的，如果一个名空间中的某些进程被映射到父名空间上，那么父名空间是可以管理子名空间上的进程状态，但是子名空间无法看到上层。

在linux系统中在task_struct结构中专门有一个值为nsproxy，这是一个名空间数据结构，里面存放着指向不同类型名空间的指针，包括uts_namespace,user_namespace,mnt_namespace，这些指针指向一个个名空间实例。**关于名空间的说法确实还要再看一遍，加深理解**。

##### 进程标识

关于进程的标识，其实在接触操作系统的时候就应该直到，进程使用pid标识的。但是在操作系统的不同层面上来标识进程使用的标识是繁多的并且是不同的。

* 在一个线程组中的进程有标识TGID，有说法认为它就是pid。
* 一个进程可以被划分入一个进程组，也就是在task_struct中有pgrp这个值，而如果不是在进程组中的leader进程，在task_struct中的pgrp都应该等于leader进程的pid号。
* 不同的进程组又被合成一个会话。会话有一个专门的会话ID

这里有一个小trick，那就是对于名空间中的pid名空间是有继承性质的，也就是说父空间可以看到子空间但是子空间无法看到父空间。

下面谈一下linux里对于pid的管理：

先看一下pid名空间的数据结构:

```
struct pid_namespace{
    struct task_struct *child_reaper;   //指向任务的结构，说明该名空间隶属于某个进程
    int level;  //名空间层级
    struct pid_namespace *parent;  //有继承关系的父亲空间，应该指的是根父亲
}
```

```
struct pid {
    atomic_t count;  //计数
    struct hlist_head task[PIDTYPE_MAX]; //根据每一种ID类型，在hash表中的一个链表头
    int level;  //层级
    struct upid numbers[1];  //代表的是每一层级的一个upid实例
}
```

```
struct upid {
    int nr;   //数字表示的ID
    struct pid_namespace *ns;  //指向隶属的名空间
    struct hlist_node pid_chain; //一个hash表
}
```

上面的两个分别为pid和upid的结构，pid就是内核所能理解的pid结构，而upid结构代表在特定的名空间内所能看到的信息。那么一个pid到底有多少信息呢，可以看到一个PID值根据进程中ID类型的不同，可以指派给多个进程，而这些进程会被挂载hlist_head上，这些进程根据类型的不同会挂在不同的位置。比如一个PID的值会被指派给PIDTYPE_PID, PIDTYPE_PGID, PIDTYPE_SID。那么对于一个pid来说它可以通过upid实例去看到名空间内进程的情况。

在task_struct中有这么一个值：

```
struct pid_link pids[PIDTYPE_MAX]
```

```
struct pid_link {
    struct hlist_node node;
    struct pid *pid;
}
```

然后在同一个文件中有这样一个结构

```
static struct hlist_head *pid_hash
```

这边就要理解一下这些数据结构之间到底什么关系了，对于一个进程来说，pids是一个pid hash表。在pid结构中tasks代表的是使用该类型pid的一个表头，而pids就是这个表的真正的结点，也就是tasks表上的结点。

pid_hash这个结构是负责从一个名空间的数值PID找到该pid的实例，因此这个hash是由名空间和pid一起hash得到的。

那么赋予一个进程pid的方法就是：

```
int fastcall attach_pid(struct task_struct *task, enum pid_type type, struct pid *pid) { 	 struct pid_link *link;
	link = &task->pids[type]; 
	link->pid = pid;  //赋予pid
	hlist_add_head_rcu(&link->node, &pid->tasks[type]);  //节点加入pid的task
	return 0;
}

```

##### 进程之间的关系

1. 父子关系：A如果fork出了B， 那么B就是A的子进程，当然这个有继承，比如爷孙进程。
2. 兄弟关系：A同时fork出了很多进程，那么这些进程就是兄弟进程。

所以在task_struct中有专门存放这些值的地方：

```
struct list_head children
struct list_head sibling
```

### 进程管理的系统调用

##### 如何创建一个子进程？--- fock

##### 如何创建一个线程？ --- clone

##### 内核线程是什么？

##### 如何运行一个新程序？ --- execve





