#### 2、字符设备驱动程序---scull

##### 主设备号和次设备号

对字符设备的访问通过文件系统内的设备名称进行，通常在/dev目录下。设备文件如果使用ls -l命令查看，则输出的第一列会使用c来标识，如果使用命令展开会发现在中间有两个使用逗号分隔的数字，那就是设备的主设备号和次设备号。主设备号标识驱动程序，次设备号则提供给内核使用。那么在内核中则使用dev_t类型来存储设备号（<linux/kdev_t.h>），它是一个32位的数，前十二位为主设备号，后20位为次设备号。那么如果要取用它们，则要用到<linux/kdev_t.h>中定义的宏：

###### MAJOR(dev_t dev) :主设备号

###### MINOR(dev_t dev) ：次设备号

###### MKDEV(int major, int minor)：转换为dev_t类型。

在建立一个字符设备前，首先要做的事是获得一个或者多个设备的编号，那么需要使用<linux/fs.h>中的register_chardev_region函数。

###### int register_chrdev_region(dev_t first, unsigned int count, char* name)

其中first的次设备号通常为0，count代表请求的连续设备数，name是和编号关联的设备名称。分配成功时返回0，否则返回一个负值。

如果事先不知道设备号，则应当让系统自动分配一个设备号：

###### int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name)

其中dev就是会返回已分配范围的第一个编号，firstminor则为被请求的第一个次设备号。

如果不再使用该设备，则需要释放设备编号：

###### void unregister_chrdev_region(dev_t first, unsigned int count)

scull中初始化时分配设备号操作如下：

 * ```
      int result, i;
      dev_t dev = 0；
    /*
    - Get a range of minor numbers to work with, asking for a dynamic
    - major unless directed otherwise at load time.
    */
      if (scull_major) {
      	dev = MKDEV(scull_major, scull_minor);
      	result = register_chrdev_region(dev, scull_nr_devs, "scull");
      } else {
      	result = alloc_chrdev_region(&dev, scull_minor, scull_nr_devs,
      			"scull");
      	scull_major = MAJOR(dev);
      }
      if (result < 0) {
      	printk(KERN_WARNING "scull: can't get major %d\n", scull_major);
      	return result;
      }
    ```

为了加载一个使用动态主设备号的设备驱动程序，对insmod的调用可以替换为一个简单的脚本，例如源码中的scull_load，这中间有创建设备的操作。