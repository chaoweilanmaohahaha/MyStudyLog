### 1、构造和运行模块

###### hello world

```
#include<linux/init.h>
#include<linux/module.h>
MODULE_LICENSE("Dual BSD/GPL");

static int hello_init(void){
	printk(KERN_ALERT "Hello,World\n");
	return 0;
}

static void hello_exit(void){
	printk(KERN_ALERT "GoodBye");
}
module_init(hello_init);
module_exit(hello_exit);
```

这里存在的printk的作用其实和c语言中的printf的作用一样，只不过内核部分不依赖C库，拥有自己的一套函数。后续将实验如何真实添加运行该模块。

###### 模块函数与应用程序不同在于：1、模块只是预先注册自己，而服务于将来某个请求；2、模块的退出函数必须仔细撤销初始化函数所做的一切；3、内核错误即便不会影响整个系统，但是也至少会杀死某个进程。

###### 每当应用程序执行系统调用或者被硬件中断挂起时，UNIX将执行模式从用户空间切换为内核空间。

###### 编写时要铭记：同一时刻，可能会有许多事情正在发生。

###### 调用的过程中会遇到双下划线开头的寒素，这类函数通常是接口底层的函数，要谨慎使用。

#### 

#### 编译模块

使用makefile编译已经写好的模块，不过在此之前要准备好内核树，或者说要配置并构造一下内核。（这里解释一下所谓内核树应该就是指编译完成后内核的源码树结构，那么为什么要预先准备好呢？那是因为模块中所需要的头文件和库可能在linux发行版本中并没有，所以需要编译内核版本从而供模块调用）

#### 装载与卸载

使用insmod程序可以将模块的代码和数据装入内核（modprobe会装入指定模块所依赖的其他模块）；使用rmmod工具可以从内核中移除模块。使用lsmod程序则可以列出当前装载到内核中的模块具体有哪些。

###### 编写的模块必须适应要装载的系统的版本，如果不符合当前版本则会出现报错的可能。那么如果说要编写一个适应多个版本的模块，则必须使用宏以及#ifdef来构造并编译代码。可以使用linux/version.h中的相关定义。



####  内核符号表

insmod程序会使用公共内核符号表来解析模块中未定义的符号，公共内核符号表中包含了所有全局内核项的地址。模块装入了内核后，它导出的任何符号也会成为符号表的一项。



#### 一个模块应该有的部分：

###### 一定数量的头文件：

就像上述代码那样，linux/module.h头文件包含了大量符号和函数的定义，init.h则指定了初始化和清除函数；

###### 许可证：

模块中应该指定代码所使用的许可证信息，例如MODULE_LICENSE('GPL')；

###### 初始化函数：

模块的初始化函数负责注册模块所提供的设施，通常定义为：

```
static int __init function(void){
/*code*/
}
module_init(function)
```

static 的使用是因为该函数一般只有可能在当前文件中使用。而__init标记则在告诉内核，该函数在装在后就应该被抛弃。

###### 清除函数：

该函数的目的是在模块被移除前注销接口并向系统返回资源。

```
static void __exit function(void){
/*code*/
}
module_exit(function)
```

###### 错误处理：

因为所有操作都需要获得内存，有时内存是如法获得的，所以必须始终检查返回值。

如果是注册出现错误，则需要判断是否可以继续初始化；如果是在途中出现某个特定的错误，则需要将之前所有注册的工作撤销；有意思的是内核常使用goto来处理错误。

###### 其实还会有很多错误的可能性，因为当完成初始化后内核会立刻调用，那么就要思考如何在错误的情况下处理这些资源。

最后讲一下可能会在装入时指定模块的参数的问题，像insmod程序时支持指定参数的，不过模块必须要让参数对insmod可见。参数需要使用module_param宏来声明。

