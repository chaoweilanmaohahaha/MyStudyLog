# 缓冲区溢出

什么是缓冲区溢出？你从这个字面上来看，就是缓冲区提供了多于限制的数据，造成了溢出。在通常情况下，缓冲区溢出只应该造成数据上的一些问题。但是这个攻击为什么会称为那么有名的攻击呢？因为如果你可以构造一些比较特殊的数据，甚至还有可能会影响到程序的执行，甚至是程序的控制。

## 先从地址空间说起

我们都知道进程空间会被分为两段，一段用来给应用程序，一段用来给内核空间，那么我们关注一下给应用程序的那一段。一个应用程序你可以把它切分一下，可执行文件的代码和库会放入**代码段**，那么这样所有的函数都会有对对应的内存地址，那么程序所要处理的数据又会放入**数据段**，但是要注意的是，对于一个进程而言，它必然有的是自己的**堆栈**，它记录了当前进程的执行函数状态。

我们依旧来看一下调用函数时是怎么影响栈的。

在调用一个函数的时候，我们可以思考，如果执行完这个函数时，需要返回到之前调用这个函数的位置，这样为了要知道这个返回地址就需要把它压入堆栈。我们需要知道的几个常用的指针，**esp**是x86定义下的栈顶指针，当实施退栈操作时，esp指针就会向下偏移一个单位。**eip**指针指向的是当前执行的指令的指针。ret指令所作的事就是让esp指针取出当前栈顶的数，然后偏移增加4位，eip就是用这个被弹出的值。

所以如果在x86下，下面的代码会出现问题：

```
void function(int a, int b, int c, int d, int e, int f) {
        int *ret;
        ret = &a-1; 
        //指针指向了函数返回地址，a作为函数的实参，而且遵循函数的参数会逆向压入栈中，所以a参数的下面就是返回地址
        (*ret)+=8;  //修改原来代码的地址
}

void main() {
        int x;
        x = 0;
        function(1,2,3,4,5,6);
        x = 1;
        printf("x is %d\n", x);
}

```

**但是这个例子在目前的机器上不一定能成功，在x64的汇编下，并不是使用esp指针来做函数压栈了。**

x64的情况：

```
int function(unsigned long a, unsigned long b, unsigned long c){
        unsigned long * ret;
        ret = &a + 4; //print x = 0
        (*ret) += 7;
}

void main(){

        int x;
        x = 0;
        function(1,2,3);
        x = 1;
        printf("x is %d\n",x);
}
```

我们看一下实际的汇编代码就一目了然了：

![buffer](..\img\buffer.png)

最后的那个+7就是跳过了中间对于x的另外一个赋值语句。（在x64中rbp指针废弃不用，所有栈内操作都是用rsp指针）

ps: 这个也可以修改分支结构的执行，比如说：

```
void function(unsigned long a, unsigned long b, unsigned long c) {
        unsigned long *ret;
        ret = &a+4;  
        //返回地址的位置和x86中有点区别，这个可以发现返回地址的位置出现在最后压入参数的上面
        (*ret)+=2;
}

void main() {
        int x = 0;
        if(x == 0) {
                printf("right\n");
                function(1,2,3);
        } else {
                printf("wrong\n");
        }
}  // 最后的结果是right和wrong
```

(*等做完实验这里需要补充真正的缓冲区溢出实例*)

## 保护

防止简单的缓冲区溢出的方法主要包括：Stack Guard、DEP、ASLR、PIE、Canary、RelRO、Fortify 。

### Stack Guard

### DEP

### ASLR

### PIE

### Canary

### RelRO

### Fortify



