# ROP

ROP 攻击，全称为 Return-oriented Programming，即面向返回的编程。在讲 ROP 之前先要提到 NX 保护，这个保护的做法简单的说就是**让栈区域的代码无法执行**。这是因为很多情况下可以通过多余的栈空间来写入一些代码，然后通过 return to shellcode 的方法，应用缓冲区溢出来执行这些代码。但是有了 NX 后栈中的数据就相当于被保护了，不能被执行，如果被执行了 cpu 就会报出异常。

ROP 就是用来绕过 NX 防护的方法之一，它也需要借助缓冲区溢出，不过执行的代码往往是现成的程序代码和库代码，不需要认为添加。所以只要防止缓冲区溢出，也就能防住 ROP。

通过缓冲区溢出的概念，已经能够知道它是通过覆盖原本函数的返回地址，来控制控制流的转向的。ROP 也是用了这个原理，不过为了使用现成的代码，它还需要借助一些工具，这里就先接触一个概念：

## gadget

代码小片段，这个片段不是一个随随便便找到的片段，而是说要带 ret 指令的代码指令小片段比如说：

```
mov edx, eax
ret
```

有点像函数尾声的意思，这个 gadget 也没有指定具体是多大的，全靠真正使用的时候的构造。

---

gadget 对我们构造攻击有什么帮助？先来看一下 ret 这个指令，它的目的是 pop rip，也就是从栈中弹出一个数据，这个数据作为下一个要执行的指令地址。那么假设有如下的结构：

我们通过构造缓冲区溢出，构造当前栈为：

|             栈              |
| :-------------------------: |
| gadget2的地址(老函数的栈帧) |
|   0x8888888(老函数的栈帧)   |
|  gadget1的地址（返回地址）  |
|        aaaa(老 rbp)         |

假设  gadget1 的代码如下：

```
pop eax
ret
```

那么这个能发生什么？可以知道当我们从原函数返回后，执行的地址已经被换成了 gadget1 的地址，对应的指令第一步的 pop 就是说明从栈中弹出数据赋给 eax，然后 ret 告诉系统下一个要执行的指令就是 gadget2 的地址的指令，这是由 ret 指令的性质得来的。也就是说通过构造指令和数据的顺序，就能轻易控制指令的执行和寄存器中的数值，这就形成了一条 ROP 链。

那么这样的 gadget 哪里得到呢？因为在动态链接的时候动态链接库要被加载到内存中，而动态链接库中就充满了这些含有 ret 的语句，并且库函数嘛肯定是能被执行的，所以就可以从这些被加载到内存中的动态链接库中抽取想要的 gadget 来拼凑成相应功能的代码段。当然如果本程序中也有很多，比如这个程序是被静态链接的，那么本程序中也会有许多这样的 gadget，我们只需要能够得到这样的 gadget 的地址就可以了。

以上就是 ROP 攻击的基本内容，为了能够抽取到 gadget，一个叫做 one_gadget 的工具能够帮的上大忙。

