# 字符串格式化漏洞

这个是针对 printf 类似的函数的一种漏洞，因为 printf 函数打印需要给出格式化字符串：

```
int a = 1;
printf("%d", a);
```

这里暂时不去讨论 printf  这种参数数目不定的函数的具体的实现，不过就对于普通的函数的执行理解，它也应该符合函数压栈和弹栈的规则。那么像这里的 printf 就是最正常的用法，打印字符串，如果字符串中存在格式化字符串，就在后面的参数列表中查找。

像最开始学习的 hello world 程序，就是这么写的：

```c
#include<stdio.h>
int main() {
	printf("hello world");
    return 0;
}
```

当然假设这个 hello world 字符串是个变量，就可以使用 %s 格式化字符串：

```c
#include<stdio.h>
int main() {
	char a[] = "hello world";
    printf("%s", a);
    return 0;
}
```

但是有这么一种写法：

```c
#include<stdio.h>
int main() {
	char a[] = "hello world";
	printf(a);
	return 0;
}
```

这种方法虽然会引起编译器的 warning，不过确实可以通过编译，并且能得到最后的结果。不过假设变量 a 是一个常量一切还好说，如果 a 是一个用户输入的变量的话，那么就会有危险：

```c
#include<stdio.h>
int main() {
	char a[100];
	scanf("%s", a);
	printf(a);
	return 0;
}
```

如果此时用户是一个攻击者，并不管输入字符串的内容是否符合常理，然后输入了一个：

```
%x.%x.%x.%x
```

此时就构成了内存的数据泄露，也就是会将栈中的数据打印出来。究其原因是和 printf 的性质有关，这里将该字符串当成了带有格式化字符串的输入，但是却发现用户没有在函数中给出变量啊。那还是遵循函数执行和参数压栈的规则吧，它会将栈中相应位置的参数当成是变量替换进来，也就构成了格式化字符串漏洞。

先写道这里，以上只是说明了如果这样书写，确实会使得栈中的数据被暴露，但是还不至于构成巨大的漏洞，其实仅仅使用 printf 函数和格式化字符串漏洞，还可以随意修改任意地址的数据，这才是这个漏洞的真正可怕之处。

