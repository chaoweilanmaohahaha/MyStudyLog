## 9、中断处理

有一个很大的问题，那就是一般外部设备处理数据比处理器慢，那么应该有一种手段告诉处理器，我已经把数据准备好了，这样处理器就可以直接去拿数据了，这种手段就是中断。

### 安装中断处理例程

模块要使用中断前要先请求一个中断通道，这和IO端口注册表十分类似，这个在头文件<linux/sched.h>：

```
int request_irq(unsigned int irq, irqreturn_t (*handler)(int, void*, struct pt_regs*)， unsigned long flags, const char *dev_name, void *dev_id)
void free_irq(unsigned int irq, void *dev_id)
```

中断处理程序可以在驱动程序初始化时安装，或者在第一次打开时安装，建议后者。所以一般调用注册时应该在设备第一次打开，硬件被告知产生中断时；而调用释放函数的位置则应该在最后一次关闭设备，硬件被告知不再中断时。

### /proc/interrupts

当中断到达处理器时，内部计数器会递增，并且中断的日记会记录在/proc/interrupts中。

### 自动检测中断号

初始化时，其实应当要决定设备要使用哪一根中断信号线，如果能够自动检测时最好的。有的可以使用默认值，或者直接简单申明它们要用到的中断。当然还有的不一定有这些方式，那么可以通过内核的帮助来探测，比如使用probe_irq_on和probe_irq_off函数。当然也可以选择手工实现。

### 实现中断处理程序

注意中断处理程序不能向用户空间发送或者接收数据，因为它们不在一个上下文中。第一步通常是清除几口上的一个位，大多数硬件都在它们的中断挂起位被清除之前不产生其他中断。然后当中断通知进程事件发生了，则需要唤醒设备上休眠的进程。

通常中断处理程序用法如下：

```
static irqreturn_t sample_interrupt(int irq, void *dev_id, struct pt_regs *regs)
```

第二个参数是驱动程序使用的额一个私有数据，通常传递一个指向自己设备的结构指针。regs参数保存了中断代码处理之前的处理器上下文快照。

如果我们在一定情况下需要阻塞中断，禁用单个中断使用下面的函数：

```
void disable_irq(int irq)
void disable_irq_nosync(int irq)
void enable_irq(int irq)
```

那么如果需要禁用处理器上所有中断呢：

```
void local_irq_save(unsigned long flags)
void local_irq_disable(void)
void local_irq_restore(unsigned long flags)
void local_irq_enable(void)
```

### 顶半部和弟半部

中断处理程序有个要求，就是需要在中断处理历程中尽可能快地处理事务，避免中断阻塞过长时间。在linux中将中断划分为了两个部分，顶半部是注册的中断例程，而底半部则是被顶半部调用地，并在后续时间中执行的例程。其中最大的不同是，底半部执行时中断是打开的。实现底半部的操作可以使用tasklet和工作队列。

### 中断共享

进行中断共享时和普通中断注册不同的是，请求中断时必须指定flags参数中的SA_SHIRQ位；dev_id参数必须唯一，且不能设置为NULL。内核会为每个中断维护一个共享处理例程表，记录各个dev_id。当然要注意的是，使用共享的中断信号线就不能使用关闭中断的操作了，这样会导致其他设备无法正常使用。

### 中断驱动IO

最后来谈谈中断驱动的数据传输，对于一个硬件而言应当按照以下方法来实现中断：

* 对于输入，当数据到达并且处理器准备接收，则设备就产生中断，这里的行为取决于使用的是IO还是内存映射还是DMA
* 对于输出，设备准备好接收数据或者对成功的数据传输给与应答时，要发出中断；如果是对内存映射和具有DMA能力的设备，通常通过产生中断来告知它们处理结束。

