## linux 设备模型

### kobject，kset和子系统

kobject是组成设备模型的基本结构，它主要包含了对象的引用计数，sysfs表述，数据结构的关联以及热插拔事件的处理。kobject对象一般会嵌入到其他的结构中。可以这么认为，kobject就是一个基类，而其他类是它的派生类。对kobject初始化是比较复杂的，首先需要将整个kobject设置为0，使用memset；然后调用函数kobject_init(struct kobject *kobj)，这个步骤实际上是让引用计数变为了1，然后要通过kobject_set_name函数设置它的名字，这时sysfs入口中使用的名字。kobject的一个重要作用就是要给引用它的结构设置计数：

```
struct kobject *kobject_get(struct kobject *kobj);
void kobject_put(struct kobject *kobj);
```

内核用多个kobject结构将各个对象连接起来组成一个分层的结构体系。

kset是嵌入了相同类型结构的kobject集合，因此可以认为它是kobject的顶层容器类，创建了一个对象后，通常需要将一个kobject对象加入到kset中，通过kobject_register函数可以实现，如果需要删除某个引用就是用kobject_del函数。当然一个kset结构也有着和kobject相同的操作。

子系统，一个子系统就是一个kset和一个信号量的封装，每一个kset必须属于一个子系统。

### 总线、设备和驱动程序

总线是处理器与一个或者多个设备之间的通道，在设备模型中，所有设备都是通过总线相连的。在Linux设备模型中是使用bus_type来表示总线结构的，它在<linux/device.h>中，里面的成员包括总线名，一个子系统，包含的两个kset代表驱动程序和设备，还有一组方法。

对于新的总线，需要调用bus_register函数进行注册，当然相对应的就是一个unregister的函数。在总线结构中有一组方法，包括match方法：新设备或者新驱动程序被添加，则会调用该函数。hostplug方法：为用户空间产生热插拔事件前，允许总线添加环境变量。

设备在linux系统各种都是用一个device结构的一个实例来表示的。它包括了parent：宿主设备；kobj：连接到结构体系中的kobject；busid：在总线上的唯一标识该设备的字符串；bus：总线类型；driver：驱动程序；driver_data:设备驱动程序使用的私有成员；release:注销函数。

设备驱动程序结构类似，在此就略过了。

### 类

类允许了用户空间使用设备所提供的功能，而并不关心设备如何连接，如何工作。类子系统是向用户空间导出信息的最好的方法。管理类驱动程序核心导出了两个接口。class_simple接口是一个比较易于使用的接口，它的第一步是使用class_simple_create函数创建类，当然销毁对应了destroy函数，然后使用class_simple_device_add函数增加设备。

## 热插拔

从内核角度来看，热插拔就是在硬件、内核、内核驱动程序之间的交互，从用户的角度来看，热插拔是内核和用户之间通过调用/sbin/hotplug程序的交互。热插拔程序需要查询从总线读来的数据值，然后正确处理它们。对于用户空间来说，当用户向系统添加了或者删除了设备时，会导致内核调用用户空间程序，这个脚本会搜索所有以.hotplug为后缀的程序，并调用它们，传递给它们环境变量。

## 固件处理

对于某些设备而言，它必须要把固件下载到设备后才能正常工作，固件一般会在随硬件发行的CD上，由操作系统负责将固件传递到设备上。正确的做法是当需要的时候从用户空间来获得固件，那么需要使用一些固件接口：request_firmware函数，它需要用户空间给内核提供一个固件的映像文件。