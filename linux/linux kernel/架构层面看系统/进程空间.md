# 进程空间

如果说之前讲内存空间，都是从内核的角度和实际物理内存的角度来看内存空间具体是如何实现的，那么这一章节的内容就是聚焦整个在用户空间中，针对一个进程，它的内存空间到底是怎么样的呢？

**说在前面**

首先我们都知道一点，因为存在了分段和分页的机制，因此在整个操作系统中我们能够看到的一共有三种地址：虚拟逻辑地址，线性地址和物理地址。MMU部件能够做到将虚拟逻辑地址转换为线性地址，然后再从线性地址转换为物理地址。但是在以下的讲解中都是依赖了IA32架构的支撑，而在IA32中虽然声称可以分段，但是实际并没有分段这个机制，它默认将段基址设为0，段限长设为4G，这样使得虚拟逻辑地址就和线性地址一样了，因此以下所谓的虚拟地址其实和线性地址可以理解为是一个概念。

那么在linux中，每个进程都会独占4G的线性地址空间，而这个4G也从前面的章节看到了，切割成了用户空间和内核空间两部分。而对于内核空间而言，系统应当是绝对信任的，但是用户空间就不一定了，执行的程序有着各种各样的限制。通过硬件的一些处理可以保证对于每一个进程而言，看到的内核空间都是相同的。

## 地址空间分布

在进程的用户空间中，我们可以看到这些部分：

* 当前正在运行的代码，也就是代码段；
* 程序需要的动态库文件
* 全局变量和动态生成的变量，也就是堆空间；
* 局部变量和用户函数调用的区域，也就是栈空间；
* 环境变量和参数
* 内存映射到文件内容的映射空间。

那么一个进程中对以上的信息的一个具体描述保存在了task_struct中的mm_struct中了，其中告诉了各个区域具体的一个起始点和终止点地址，同时给出了一个mmap_base指定打开mmap的地址区域范围。

这里有那么几点说明：

1. 其中在设置这个结构的过程中会遇到一个标志称为PF_RANDOMIZE，如果这个标志置位了，表示进程空间中的栈的起始位置和内存映射的起始位置是随机的，这是使得攻击者不能根据一个给定的位置来实施攻击。
2. 普通的进程空间各个区域的生长方向如下：堆空间从低地址向高地址生长直到mmap_base，内存映射区域从mmap_base区域向高地址生长，栈空间由最高地址向低地址生长，直到两个区域碰上。参数列表和环境变量是存放在栈中的。但是由于空间的限制，在IA32中进程的栈空间是被限制指定的大小的，而内存映射空间是从上至下和堆空间面对面生长的。
3. text段是在整个进程空间的最底段位置，但是并不是直接从0开始，它会被映射到一个指定的开始地址处：比如IA32中是从0x08048000 。

在执行exec系统调用的时候，根据执行的ELF中的信息，完成这个进程地址空间的初始化。主要的过程就是在填充这个mm_struct中的各个结构中的参数。那么栈空间保证了它至少要有128M。

## 内存映射

你依旧得知道一点，用户进程的地址空间很大，要比物理内存大很多，所以物理内存中只会保存进程常用的信息。比如对于一个文件而言，可能如果我们是在写一个文件那么内存可能只关心文件的末尾位置，对于代码段也是一个道理。所以简单的认为，内核必须要使得虚拟地址空间中的部分区域和数据存储的位置产生 一个映射，这就是内存映射。那么将数据放到物理页上的操作就变成了按需分配。

如果进程想要访问的某个地址没有在页表中，此时会触发缺页异常，内核会去后被存储中去取，随后装载到内存中。

## 数据结构

着重来看一下内存映射需要的数据结构。在mm_struct中有这么一些结构：

```C
struct mm_struct {
    struct vm_area_struct *mmap;
    struct rb_root mm_rb;
    struct vm_area_struct *mmap_cache;
    ...
}
```

在映射中，每一个单独的区域是一个vm_area_struct 的实例，他们被存放在两个地方，一根单链表mmap和红黑树mmrb上（起始道理上只需要一个队列就行了，但是为了查找快所以使用了红黑树）。

每一个vm_area_struct结构的表示就比较复杂了，但是每一个内容都很重要。

```C
struct vm_area_struct { // 虚拟存储区域的具体表示
    struct mm_struct *mm;  // 回向指针，指向包含他的mm_struct
    unsigned long vm_start;  // 在用户空间中该区域的起始地址，和结束地址
    unsigned long vm_end;
    
    struct vm_area_struct *vm_next;  // 指向下一个区域的指针
    
    pgprot_t vm_page_prot; // 存放着该区域的访问控制标志
    unsigned long vm_flags;  // 代表这个区域的一些标志
    
    struct rb_node vm_rb;  // 挂在红黑树上的结点
    
    union {
        struct {
        	struct list_head list;
            void *parent;
            struct vm_area_struct *head;
        } vm_set;
        struct raw_prio_tree_node prio_tree_node;
    } shared;  // 共享映射，这个后续会介绍
    
    struct list_head anon_vma_node;
    struct anon_vma *anon_vma;  // 这两个参数用来管理由匿名映射残生的共享映射
    
    struct vm_operations_struct *vm_ops;  // 存放了处理这个区域需要使用的所有句柄
    
    unsigned long vm_pgoff;  // 如果有文件映射到了这篇区域，这个值表示的是当前文件的偏移位置
    
    struct file *vm_file;  // 映射到这里的文件实例
    void *vm_private_data;  // 隐私信息
}
```

### 优先搜索树

这是一个比较重要的数据结构，因为后面的逆向映射就会用到。这棵树是用来建立一个文件中的一片区域（vm_area_struct）和所有这个区域映射到的所有虚拟地址的一个关系。

所有打开的文件都会使用一个数据结构file存放，而这个结构中会使用一根指针指向一个地址address_space，而这个结构就是这颗优先搜索树的首先关键。这个结构中含有所有映射到这个文件一个个区间的vm_area_struct实例。这些实例被挂在了优先搜索树上。**所以注意，一个vm_area_struct可以被挂载两个地方：一个是建立了进程空间和打开文件的关系，一个表示了所有映射到该文件片段上的地址空间。**

在优先搜索树种管理的区域，映射的区间不能有重叠。而如果出现有多个区域映射到了同一个文件片段上，可以看到在vm_area_struct种shared共享映射部分是一个联合体，如果只是一个结点，那么它被raw_prio_tree_node表示，否则就是vm_set来表示，其中的head部分指向第一个加入的相同的那个vm_area_struct，而所有的区域连在那个链表上。

## 有关区域的操作

在上面介绍了，所有和文件的映射关系切分成了一个个小的区域，那么接下去内核中就会给出具体的操作来处理这些区域。

### 建立虚拟地址和区域的关系

内核中使用find_vma这个函数来找到合适的区域。这个函数的参数中会指定addr，那么找到的区域的位置的结束位置应该在addr的后面。首先内核会去mmap_cache看是否满足条件，如果不满足就去红黑树中寻找合适的区域，并把这个区域放入到cache中。

### 合并

如果有一个区域被添加到进程中，内核需要查看这个区域是否可以和背的区域合并。方法很直接，就是找到这个区域的前向结点，前向节点的尾部地址一定要比该区域开始地址大；随后内核检测这两个区域的映射片段是否相同，那就可以将这两个区域合并。

### 插入

插入一个结点需要两个步骤，你首先需要一些信息保证你的插入，包括插入点的前继的地址，红黑树上的父节点等。当找到了这些信息之后，就需要调用真正的插入函数插入到1、map队列中；2、红黑树上；3、可能是匿名映射队列中。最后需要需要将这个信息更新到优先搜索书上。

### 创建

在插入操作之前，绝对需要从虚拟地址空间上找到一个空闲的，指定长度的一片区域来，这个操作交给了函数get_unmapped_area来完成。如果在这个函数中有指定了addr参数，就直接使用find_vma函数获取，否则先去已经cache的区域中查找合适的区域，如果还没有则从进程的mmap_base去找一个空闲的区域。

## Address space结构

每个文件的映射都有这么一个结构，这个结构除了上面说的包含了所有映射的区域，还包括了许多操作函数，包括writepage写函数，readpage读函数，writepages写函数， readpages读函数。对于读函数来说，就是从块设备上把数据读到内存，写函数就是把数据写回块设备。

## 映射操作

那么其实讲了这么多也没有讲到具体的将文件映射到一个进程地址空间到底是怎么做的。那么如果要使得内核和一个应用程序建立内存上的映射，需要使用的是函数mmap，这个函数触发了系统调用mmap。它的目的是建立了在用户地址空间中pos位置上长度为len的一个映射。

### 建立映射

下面就是详细讲讲上面那个mmap到底怎么做的喽。最底层调度的是do_mmap_pgoff，在这个函数中其实有很大一部分都是在检测状态参数，这些我们把它忽略。那么首先我们需要使用get_unmapped_area获取一个空闲的区域，在这里我们要知道一点，映射区域的大小一定是按整页整页分配的。然后计算一下对于这个区域的标志位，我们就可以通过find_map_prepare去查找插入位置需要的信息，随后创建一个新的vm_area_struct，根据函数的参数填充这个vm_area_struct，加上映射文件的句柄(相当于和一片address space挂钩)，这个最后会被插入到映射队列中和红黑树中。最后返回找到的区域的地址。

### 移除映射

使用munmap函数。这个函数首先做的还是找到对应的映射，但是注意的是，找到了之后的区域的其实地址如果并不是指定的地址，那就需要对分配的区域进行一次切割；同理对于后面一半的区域也要判断是否要切割。做完切割操作之后，就需要使用unmap_region函数抹去所有这个映射的信息。

### 非线性映射

大部分映射文件都是映射一个连续的部分，但是也有可能出现这种情况，文件多个不同的部分映射到了另外一个虚拟空间的一片连续区域，那么就需要使用非线性映射了。这个的方法是对映射进行重排序，这个操作需要借助页表来实现。这个操作需要完成将一个指定位置指定长度的映射移动到一个新的位置。那么此时如果这个映射突然被交换了出去，内核必须能在换回来时确保原来的偏移，那么这些信息都应该保存在页表中。建立的非线性映射的nonlinear mapping保存在了address space中的i_mmap_nonlinear中，如果你要从vm_area_struct中查看，可以直接从shared.vm_set.list中查找（因为非线性映射并不在优先搜索树上出现）；并且这样的映射在页表上的表示也需要进行特殊的处理。

一个页表项中我们可以这样使用来进行非线性的映射。我们知道最后一位一定是页项存在位。那么在表项倒数第二位为1表示这是一个非线性映射，随后除了最高位之外的61位作为非线性映射的偏移。

好了，此时我们再来看这个remap的过程。使用find_vma找到对应的区域，如果这个区域还没被remap那么设置它的标志位，并且将它从优先搜索树上删除，加入到非线性映射的队列中。最后你要给出一个被魔改过的页表入口，这一步需要遍历所有页表，然后移除之前可能存在的页表项，然后添加新的页表项。

## 逆向映射

现在我们已经是建立了虚拟地址空间和物理地址空间之间的关系，又建立了进程空间与虚拟地址空间的关系。那么此时我们考虑物理地址和进程之间的关系，也就是去识别一个物理页到底被多少个进程使用。所以要知道这个数目，物理页和引用它的进程必须要产生一个映射关系，这就需要借助逆向映射。

我们回想一下在物理页page中包含的引用计数：

```
struct page {
    atomic_t _mapcount
}
```

这个计数值记录了这个物理页出现在页表中的次数，如果次数是0说明已经插入到了逆向映射。有这个计数值似乎不是很够，所以我们再考虑一下在每个vm_area_struct中的存在的一颗优先搜索树结构：

```
struct vm_area_struct {
	union {
        struct {
            struct list_head list;
            void *parent;
            struct vm_area_struct *head;
        } vm_set;
        struct raw_prio_tree_node prio_tree_node;
	} shared;
	struct list_head anon_vma_node;
	struct ano_vma *anon_vma;
}
```

我们下面我们介绍一下到底怎么使用这样一个逆向映射

### 创建逆向映射

在逆向映射创建的时候要注意的是分匿名页和文件页，上面所提到的映射都是文件页的映射，而匿名页的映射一般是指应用程序动态分配的堆内存。对应匿名页的操作来说它需要给引用计数+1的同时使用最底层函数__page_set_anon_rmap函数去操作，就是要将anon_vma中有关匿名映射部分挂到page->mapping上。而对于纯粹的文件页来说只需要给引用计数+1就行了。

mapping 字段用于确定页是映射的或匿名映射的。

* 如果 mapping 字段空，则该页属于交换高速缓存。
* 如果 mapping 字段非空，且最低位是 1，表示该页是匿名页；同时 mapping 字段中存放指向 anon_vma 描述符的指针。
* 如果 mapping 字段非空，且最低位是 0，表示该页是映射页；同时 mapping 字段指向对应文件的 address_space 对象。

### 使用逆向映射

匿名映射有什么用呢？它的作用体现在交换页面上。当其调用try_to_unmap函数时，那么它需要删除一个物理页的在所有进程页表中的入口。那么在这里就要分两步去找引用的页面了，分别去找匿名映射页面和文件页面。如果是找匿名映射页面，那很简单，只要获取当前物理页page的mapping处就行。那么如果保证发生了页面的映射，则需要做的是去页表中找到对应的页面的入口，然后抹去_PAGE_ACCESSED位，并且如果抹去一次reference计数加1。而对于普通的映射，它的信息都存放在了address_space中了，那么就从优先搜索树上遍历结点来查看引用计数了。**具体的操作我们到交换页面的时候看吧。只要知道一点就是说逆向映射的作用就是可以在释放的时候找到对应的使用的进程。那么当看到内存页交换的时候再来看这个内容吧。**

## 堆映射

堆存在的意义就是给内存动态分配给变量和数据的。其中用户使用malloc函数来操作堆，而内核使用brk系统调用来扩展或者缩减堆的大小。

我们主要看一下brk系统调用的实现，这个brk机制的实现借助于匿名映射这个功能。首先brk保证分配空间后不会超过进程中的资源限制，然后扩展空间使得页对齐，在堆中申请的大小最小为一页。然后需要保证增大的这个堆空间不会和已有的映射重叠，虽有就调用do_brk真正去扩大堆。do_brk的作用就是创建一个匿名映射，过程和do_mmap类似。

## 处理缺页错误

那么虚拟页和物理页的关系是不是一开始就已经确定的呢？当然不是呢，只有在使用的时候才会建立映射，那么如果我需要的时候没找到这样的一个对应关系怎么办呢？处理器会发生一个缺页异常，让内核去解决这个问题。

简单的说在内核中有一个函数do_page_fault函数，这个函数里面有两个参数，一个记录了当时的寄存器情况，一个是出错码，出错码中又可以区分不同的错误情况，还有一个比较重要的是，内核保存了缺页异常出错的地址，它被保存在了CR2寄存器中。

那么我们简单叙述一下这个函数所作的事情，这里有很大一部分都是在处理这个出错地址的合法性，不再这里多赘述了，如果经过一系列的判断，证明这个地址是合法的，那么如果出现缺页的地址是合法的，就交给handle_mm_fault函数去处理缺页异常。下面分两种情况来分析具体缺页异常的处理方法：

### 用户空间中的缺页异常

页不在页表中一共有以下三种情况：

* 页表中是真的没有这个页表项，也就是从来没有加载过这一页，那就需要按需分配。这里就要用到vm_operations_struct结构中的操作。
* 这个页的P位没有置位，意思是信息在但是显示它不再页表中，那说明它被置换了出去
* 一些非线性映射被置换了出去，这个需要特殊对待。

当然在处理这个句柄函数时也不光是处理页表不在的问题，也处理页表在但是出现了写保护的问题，需要调用do_wp_page来解除写保护。

#### 按需分配

我们先来看看第一种情况，首先因为内存中根本没有需要的页面的数据，那么内核就需要将该文件对应位置的数据读到内存中，完成这个操作的函数需要vm_operations_struct中的fault函数。那么真正读的过程中每个address space都包含了映射的读方法readpage。、

现在相当于我已经能够拿到这个页面了，那么现在我就可以把它插入到进程的页表中了，并且要注意的是更新逆向映射的数据结构。

#### 再谈匿名映射

我们知道普通的映射都是将设备上的一些文件映射到一篇区域，但是匿名映射之所以叫匿名的，那是因为它根本没有什么文件来映射。但是对于它的操作和普通的映射又是没什么不同的。

#### 写时拷贝

回想当时我们谈论fork的时候，为了减小开销，它会做一步写时拷贝。在创建子进程的时候并不是立刻创建一个新的页表，而是和父进程使用相同的页表项，这样就可以省去一笔开销。但是此时子进程或者父进程要开始对某个页面进行写操作了，那么迫不得已必须创建新的页表和页面了。

此时我们必须通过页异常出发句柄do_wp_page，首先你必须收集所有的相关页面，因为涉及要往新的页面写数据，那么出发alloc_page_vma函数，虽有使用cow_user_page进行拷贝。同时原本的逆向映射要修改，新的页表也需要做相应的修改。

### 内核空间中的缺页异常

内核空间的缺页异常什么时候才会被触发呢？

* 内核的一个编程的问题导致了内核出现巨大的问题。
* 内核使用用户传递进来的参数访问到了一个错误的位置
* 内核使用vmalloc触发了缺页异常（这个和相关页面没有添加到内核页表中有关）

内核使用**异常修补**机制来修复内核中的缺页问题，相当于内核可以给每个异常访问的方法找到一个合理的原因并尝试去修补它。每一次一个缺页异常发生了之后，那么内核中存在一个异常表，根据此时的一个EIP指针只想的代码段地址去异常表中搜索是否有合适的异常修补历程。那么如果没找到怎么办？那就会导致一个内核错误（oops），相当于出现了一个内核漏洞。

---

最后介绍一下一些用户空间和内核空间交互的函数，首先你确实要知道的是，用户空间是不能直接进入内核空间的，那么对于内核而言从用户空间传入的指针也并不一定真的和一个物理页有关。所以使用交互函数是隔离两侧操作的方法：

```
copy_from_user: 从用户空间复制n字节到达内核空间；
get_user：从用户空间读取一个简单的变量；
put_user：复制一个十分简单的值从内核到用户空间；
copy_to_user: 内核空间向用户空间复制n个字节；
```

