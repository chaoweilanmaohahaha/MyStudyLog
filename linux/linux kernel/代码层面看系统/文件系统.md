# 文件系统

这一部分比较庞大，需要分块来进行记忆。考虑一下文件系统在linux系统中的定位，它应当是操作系统长时间用来存储程序和数据的地方。文件系统需要使用高速设备来存储程序和数据，所以操作系统通常使用块设备作为文件系统的设备。

###### 写在前面

Linux0.11版本使用的是MINIX1.0版本的文件系统，MINIX文件系统和UNIX文件系统基本相似，由6个部分组成，从左到右分别为：引导块，超级块，i结点位图，逻辑块位图，i节点，数据区。

引导块：还记得在引导部分，在第一个盘块的一个扇区装载着引导系统的信息。如果一个盘是用来做引导设备的，那么它应该在引导盘块中有对应的引导代码。这是在加电的过程中由BIOS自动读入的执行代码存放的位置，那么文件系统不是引导盘所以会在块设备上空出一个存放引导块的地方。如果这块盘不是用作引导则仍然需要有引导部分，但是这部分没有代码。

超级块：用来存放盘设备上文件系统结构的信息。也就是存放了该文件系统的一些全局信息，例如i节点数，逻辑块数，位图占用磁盘块数，第一个逻辑块块号、2为底的对数表示的每个逻辑块包含的磁盘块数、魔数等等。那么每一个文件系统的超级块会被保存在一个super_block数组中，共有8位。在内存中超级块还会包含如下字段：

* s_imap[8]: i节点位图在高速缓存块指针
* s_zmap[8]: 逻辑块位图在高速缓冲块指针数组
* s_dev: 超级块所在设备号
* s_isup: 根目录i节点
* s_imount：文件系统被安装到的i节点，后面就还包含一些标志位。

i节点位图：这是一个bitmap结构，如果某一位被置1则说明该位代表的i节点被使用了。

逻辑块位图：这个位图是用来描述盘上的数据块的使用情况，其中每一位代表的是一个数据盘块的使用情况。超级块中的zmap数组可以看出，逻辑块位图最多使用8个缓冲块。

i节点：是一个结构，存放文件系统中文件或者目录的索引节点，每一个文件都有一个i节点。其中包含了文件的属性，比如：

* 文件的类型属性，用户id，文件长度，修改时间，文件的宿主id；
* 文件的链接数
* 文件占用的逻辑盘块数组izone[9]
* 等待该i节点的进程，时间属性，i节点所在设备，i节点号
* i节点使用次数，和一些属性

数据区：存放文件真正的数据，而要找到这些存放数据的数据块，则需要通过i节点进行连接。在后面看i节点的操作时可以看到在i节点寻找数据块的过程中可能会出现间接指向数据块的过程。在MINIX系统中使用连续2个扇区（1024B）作为一个数据块来使用，称为一个盘块。那么逻辑块并不能完全认为是等同于盘块，在这个版本中这两个概念表示的大小相同，但是逻辑块的作用是用来寻址，还是要有一个和物理块地址转换的过程。![kernel5](..\..\img\kernel5.png)

在图上可以看到，在MINIX文件系统中，一块代表了一个磁盘块，也可以认为是一个逻辑块即1KB。

当前的硬盘块设备容量巨大，因此可以在单个块设备上划分多个分区，并且每个分区存放着不同的完整的文件系统。硬盘的第一个分区是主引导扇区，其中包含着引导程序和**分区表**，分区表又存放了所有分区的基本信息。

**这里有一个关于文件的概念还是要说明一下：有一个概念是符号链接，符号链接就是使用一个不同的文件名来引用另一个文件，因此在izone中存放的不是真正的i节点，而是真正的文件的文件名字符串，而这个文件是可以跨越文件系统，这个链接并不影响本身的文件。但是还有一种链接是硬链接，这说明链接文件和源文件可以说是同一个文件，相互是有影响的。**

一个文件的目录项，存放的是一个文件的目录名以及i节点号，因此一个盘块能够存放64个目录项。那么在通过系统通过名字来查找文件试是怎么做的呢？简单的说通过文件名来查找到i节点编号，然后再去位图中和i节点中查找逻辑块的位置![kernel6](..\..\img\kernel6.png)

在这里再补充以下，就是在内核中还实现了文件数据结构，其中一个文件包含了操作该文件的文件模式，文件句柄的引用计数，指向对应i节点的指针和当前文件读写的位置。那么有一个文件数组file_table专门存放64个文件。这样在进程中就有一个文件指针数组指向了file_table中的某个文件，再由这个文件中给出的这个i节点指针指向对应的i节点。

---


### 高速缓存区

代码先从这边开始，高速缓存区也就是所谓的cache，它的位置存在于内核代码和主存的中间。cache的存在是为了协调IO读写操作和内存处理的速度。因此在这个版本的内核中，专门在其中开辟了一片区域为高速缓存区。那就先从这一片小区域开始讲起。

###### buffer.c

其实在前面的块设备等地方就已经涉及到了一点高速缓存的知识。整个高速缓存区被划分位1024B的缓冲块，这正好和磁盘逻辑快大小相同。在0.11版本的内核中，高速缓存区使用了hash表和空闲缓冲队列来管理。在初始化过程中，会从缓冲区的两端开始初始化缓冲头部和缓冲块。缓冲头部也就是buffer_head记录了缓冲块的属性，并且和其他缓冲头一起连接成一个链表；从尾部起初始化缓冲块，当两端相遇，已经没有空间再分配时就停止。

每个buffer_head被链接成一个双向链表，也就是所谓的空闲链表，其中free_list指针是链表头，指向了空闲链表块中第一个最空闲的缓冲块。而在这个buffer_head中有一根反向指针指向最后一个缓冲块。

```
struct buffer_head {          
	char * b_data;                      // 指向该缓冲块中数据区（1024 字节)的指针。          
	unsigned long b_blocknr;            // 块号。          
	unsigned short b_dev;               // 数据源的设备号(0 = free)。          
	unsigned char b_uptodate;           // 更新标志：表示数据是否已更新。          
	unsigned char b_dirt;               // 修改标志: 0- 未修改(clean)，1- 已修改(dirty)。         unsigned char b_count;              // 使用该块的用户数，如果是空闲块，则这个数是0     
	unsigned char b_lock;               // 缓冲区是否被锁定。0- ok, 1- locked          
	struct task_struct * b_wait;        // 指向等待该缓冲区解锁的任务。          
	struct buffer_head * b_prev;        // hash 队列上前一块（这四个指针用于缓冲区管理）。    
	struct buffer_head * b_next;        // hash 队列上下一块。          
	struct buffer_head * b_prev_free;   // 空闲表上前一块。          
	struct buffer_head * b_next_free;   // 空闲表上下一块。 };
```

首先要直到一点，这个b_prev_free和b_next_free是专门查找空闲块的，因此所有的空闲块是通过这个指针连接起来的。在内核中还有一个数据结构是hash表，这个hash表的目的是能够快速找到某个缓冲块，那么这个hash表具有307个buffer_read指针，其中hash散列使用的是逻辑块号^设备号。那么b_prev和b_next就是链接某个hash表上的某一项上的所有缓冲块。

我们先来看看初始化(这个函数出现在main.c中)：

```
void buffer_init(long buffer_end)  //buffer_end是初始化到的末尾位置
{
	struct buffer_head * h = start_buffer;  //buff开始位置，也就是从缓冲区头部开始
	void * b;
	int i;

	if (buffer_end == 1<<20)
		b = (void *) (640*1024);
	else
		b = (void *) buffer_end; 
	while ( (b -= BLOCK_SIZE) >= ((void *) (h+1)) ) { 
		h->b_dev = 0;   //设备
		h->b_dirt = 0;  //是否修改
		h->b_count = 0; 
		h->b_lock = 0;  //是否上锁
		h->b_uptodate = 0;  //更新标志
		h->b_wait = NULL;  //是否等待
		h->b_next = NULL;  //指向同一个hash值的下一个缓冲头
		h->b_prev = NULL;  //指向同一个hash值的前一个缓冲头
		h->b_data = (char *) b;  //指向缓冲块数据（1024B）
		h->b_prev_free = h-1;  //空闲链表双向链表前向指针
		h->b_next_free = h+1;  //空闲链表双向链表后继指针
		h++;
		NR_BUFFERS++;
		if (b == (void *) 0x100000)
			b = (void *) 0xA0000;
	}
	h--;
	free_list = start_buffer;  //空闲链表头指向该缓冲区头部
	free_list->b_prev_free = h; // 完成双向链表的链接
	h->b_next_free = free_list;
	for (i=0;i<NR_HASH;i++)
		hash_table[i]=NULL;  //hash表初始化
}	
```

从这个里面可以看到，所有的缓冲头都被挂在了一个双向链表上（free_list）使用b_prev_free和b_next_free指针指向。已经被读入缓冲区中的数据块需要存放在一个hash表中，这个需要使用对应的设备号和逻辑块号进行hash，然后将这个块放入hash表中，而b_prev和b_next就是用来处理hash表上的块的链接。

然后我们看一下获取缓冲块的函数：

**get_hash_table** 

先看这个辅助函数，这个函数其实是看是否有指定的设备已经使用了某个缓冲块，这样直接在hash表中就能找到。

```
struct buffer_head * get_hash_table(int dev, int block)
{
	struct buffer_head * bh;

	for (;;) {
		if (!(bh=find_buffer(dev,block))) //这就是找这个缓冲块的函数，根据对应设备号和块号去hash表中寻找块，找不到就return
			return NULL;
		bh->b_count++;  //引用计数
		wait_on_buffer(bh);  //等待缓冲区解锁
		if (bh->b_dev == dev && bh->b_blocknr == block) //验证是否是正确的缓冲区
			return bh;
		bh->b_count--;
	}
}
```

**getblk**

```
struct buffer_head * getblk(int dev,int block)
{
	struct buffer_head * tmp, * bh;
repeat:
	if (bh = get_hash_table(dev,block))  //意思是在hash表中寻找块
		return bh;   //如果hash表中存在则直接返回
	tmp = free_list;  //如果没有则开始寻找一个空闲的缓冲块，free_list是空闲队列头指针
	do {
		if (tmp->b_count)  //说明当前的块被引用了
			continue;
		if (!bh || BADNESS(tmp)<BADNESS(bh)) {  //这里就是找到一个空的块
			bh = tmp;
			if (!BADNESS(tmp))
				break;
		}
/* and repeat until we find something good */
	} while ((tmp = tmp->b_next_free) != free_list); 
	if (!bh) { 这里说明我出了循环了，但是没有找到空闲块
		sleep_on(&buffer_wait);  //如果没有空闲的块就等待
		goto repeat;
	}
	wait_on_buffer(bh);  //等待这个空闲块解锁
	if (bh->b_count)  //如果这个块又被引用了就重新寻找
		goto repeat;
	while (bh->b_dirt) {
		sync_dev(bh->b_dev);  //设备上数据和缓冲区中数据同步
		wait_on_buffer(bh);
		if (bh->b_count)
			goto repeat;
	}
/* NOTE!! While we slept waiting for this block, somebody else might */
/* already have added "this" block to the cache. check it */
	if (find_buffer(dev,block))
		goto repeat;
/* OK, FINALLY we know that this buffer is the only one of it's kind, */
/* and that it's unused (b_count=0), unlocked (b_lock=0), and clean */
	bh->b_count=1;
	bh->b_dirt=0;
	bh->b_uptodate=0;
	remove_from_queues(bh); //先把这个块从队列中拿掉，以免有人使用
	bh->b_dev=dev;
	bh->b_blocknr=block;
	insert_into_queues(bh);  //将这个块插入原来的空闲队列尾部，同时插入hash表中
	return bh;
}
```

以上就是块的查找过程，所有一个设备要使用到一个缓冲块就需要这么查找。

那么对缓冲区进行读操作，需要使用这个文件中的bread，bread_page和breada函数，其实都很相似，只要看一下bread函数就可以了。

**bread**

返回含有有效数据的缓冲块，这个函数是一次性读一个缓冲块，也就是1K。

```
struct buffer_head * bread(int dev,int block)
{
	struct buffer_head * bh;

	if (!(bh=getblk(dev,block)))   //获取一个缓冲块
		panic("bread: getblk returned NULL\n");
	if (bh->b_uptodate)  //如果这个块上数据就是最新的，则直接返回，说明数据已经读到了缓冲区中
		return bh;
	ll_rw_block(READ,bh);  //走到这里说明数据还没走到缓冲区，则需要将数据读入设备
	wait_on_buffer(bh);
	if (bh->b_uptodate)  //查看是否读入
		return bh;
	brelse(bh);   //读失败，释放块
	return NULL;
}
```

这个函数的下面还有它的一些兄弟函数，比如bread_page（一次性读入一个页面也就是4K的数据，然后将这些数据再复制到某个指定的地址处）、breada（这个函数预读入一些数据进入临时的一些缓冲块，在预读后先暂时将这些快的计数--）

###### bitmap.c

从文件的名字来看就很好理解，这个肯定和i节点位图和逻辑块位图有关，它们代表了一个i节点或者一个逻辑块是否被使用。这是根据逻辑块和i节点的使用情况对位图的某个比特位进行置位和释放的操作。在这个文件中可以发现，所有有关置位和清位，寻找空闲块和清除块信息都是通过汇编来做的。

**new_block**

```
int new_block(int dev)
{
	struct buffer_head * bh;
	struct super_block * sb;
	int i,j;

	if (!(sb = get_super(dev)))  //获取设备的超级快
		panic("trying to get new block from nonexistant device");
	j = 8192;
	for (i=0 ; i<8 ; i++)
		if (bh=sb->s_zmap[i])  //zmap保存的是逻辑块位图，也就是从设备的超级块读出逻辑位图
			if ((j=find_first_zero(bh->b_data))<8192)  //扫描是否有空闲位置
				break;
	if (i>=8 || !bh || j>=8192)
		return 0;
	if (set_bit(j,bh->b_data))  //j代表找到的位置，置位j
		panic("new_block: bit already set");
	bh->b_dirt = 1;  //说明这一个缓冲块已经被修改，即逻辑位图被修改
	j += i*8192 + sb->s_firstdatazone-1;   //计算占用的块号
	if (j >= sb->s_nzones)
		return 0;
	if (!(bh=getblk(dev,j)))  //j就是新获得的块的块号，根据dev去申请一个块，这个块肯定是一个新块
		panic("new_block: cannot get block");
	if (bh->b_count != 1)
		panic("new block: count is != 1");
	clear_block(bh->b_data);  //清除缓冲块上的数据
	bh->b_uptodate = 1; //置位更新和修改位
	bh->b_dirt = 1; //修改了逻辑位图
	brelse(bh);   //释放盘块
	return j;  //返回逻辑盘块号
}
```

**free_block**

释放掉某个设备上数据区中的逻辑块

```
void free_block(int dev, int block)
{
	struct super_block * sb;
	struct buffer_head * bh;

	if (!(sb = get_super(dev)))  //出现在super.c中，取某个设备的超级块
		panic("trying to free block on nonexistent device");
	if (block < sb->s_firstdatazone || block >= sb->s_nzones) //如果这个块号不在指定范围内就报错
		panic("trying to free block not in datazone");
	bh = get_hash_table(dev,block);  //先去hash表中查看，看是否已经在高速缓冲区内
	if (bh) {
		if (bh->b_count != 1) {  //说明，这个块被几个设备一起使用着
			printk("trying to free block (%04x:%d), count=%d\n",
				dev,block,bh->b_count);
			//brelse(bh) 0.12中这么写，要释放这个缓冲块
			return;
		}
		bh->b_dirt=0; //清除标志
		bh->b_uptodate=0;  //
		// if(bh->b_count) 此时只有一个设备了在使用了
		brelse(bh);
	}  //如果这个设备和逻辑块占用了某个缓冲块就释放
	block -= sb->s_firstdatazone - 1 ;  //计算了从firstdatazone开始是第几块
	if (clear_bit(block&8191,sb->s_zmap[block/8192]->b_data)) {  //清除那一位
		printk("block (%04x:%d) ",dev,block+sb->s_firstdatazone-1);
		panic("free_block: bit already cleared");
	}
	sb->s_zmap[block/8192]->b_dirt = 1;  //这一步是说明了逻辑块位图被修改了
}
```

这个文件中还有两个函数是用来更新i节点位图，分别是free_inode复位对应i节点位图的比特位，new_node为某个设备建立一个新的i节点，这个会在i节点获取一个新的空闲i节点表项。

**free_node**

```
void free_inode(struct m_inode * inode)
{
	struct super_block * sb;
	struct buffer_head * bh;

	if (!inode)
		return;
	if (!inode->i_dev) {  //这个的意思是inode当前并没有被设备占用
		memset(inode,0,sizeof(*inode));
		return;
	}
	if (inode->i_count>1) {  //当前使用这个inode的进程不止一个
		printk("trying to free inode with count=%d\n",inode->i_count);
		panic("free_inode");
	}
	if (inode->i_nlinks)  //当前inode有关的文件不止一个
		panic("trying to free inode with links");
	if (!(sb = get_super(inode->i_dev))) //获取这个inode对应设备的超级块
		panic("trying to free inode on nonexistent device");
	if (inode->i_num < 1 || inode->i_num > sb->s_ninodes)  //检查inode的编号是否则范围内
		panic("trying to free inode 0 or nonexistant inode");
	if (!(bh=sb->s_imap[inode->i_num>>13]))   //此时的bh对应的是当前的inode编号下的位图占用的逻辑块
		panic("nonexistent imap in superblock");
	if (clear_bit(inode->i_num&8191,bh->b_data))  //清除这一位
		printk("free_inode: bit already cleared.\n\r");
	bh->b_dirt = 1; //说明了逻辑位图被修改了
	memset(inode,0,sizeof(*inode));
}
```

**new_node**

```
struct m_inode * new_inode(int dev)
{
	struct m_inode * inode;
	struct super_block * sb;
	struct buffer_head * bh;
	int i,j;

	if (!(inode=get_empty_inode()))  //这个在inode.c中，意思是获取一个空的inode
		return NULL;
	if (!(sb = get_super(dev)))  //根据设备获得设备的超级块
		panic("new_inode with unknown device");
	j = 8192;
	for (i=0 ; i<8 ; i++)   //从inode位图中找到一个空的位
		if (bh=sb->s_imap[i])
			if ((j=find_first_zero(bh->b_data))<8192)
				break;
	if (!bh || j >= 8192 || j+i*8192 > sb->s_ninodes) {
		iput(inode);  //放回申请的inode
		return NULL;
	}
	if (set_bit(j,bh->b_data))
		panic("new_inode: bit already set");
	bh->b_dirt = 1;
	inode->i_count=1;
	inode->i_nlinks=1;
	inode->i_dev=dev;
	inode->i_uid=current->euid;
	inode->i_gid=current->egid;
	inode->i_dirt=1;
	inode->i_num = j + i*8192;
	inode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME; //以上填入与inode相关的信息
	return inode;
}
```

###### truncate.c

还记得在inode中专门有一个叫做i_zone的数组用来存放inode中使用的逻辑块，其中这个数组一共有9个元素，前七个元素直接指向某一个逻辑块，倒数第二个是一级间接块，最后一个元素是二级间接指针块，当要释放某一个inode时，则这个inode使用的逻辑块应该都被回收，那么这个文件就是做了这件事情。

```
void truncate(struct m_inode * inode)
{
	int i;

	if (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))
		return;
	for (i=0;i<7;i++)   //释放1-7号块
		if (inode->i_zone[i]) {
			free_block(inode->i_dev,inode->i_zone[i]);  //释放块
			inode->i_zone[i]=0;
		}
	free_ind(inode->i_dev,inode->i_zone[7]);  //释放一级间接块
	free_dind(inode->i_dev,inode->i_zone[8]);  //释放二级间接块
	inode->i_zone[7] = inode->i_zone[8] = 0;
	inode->i_size = 0;
	inode->i_dirt = 1;
	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
}
```

###### inode.c

i节点是文件系统中的一个非常重要的概念，i节点存放着文件系统中文件的索引节点，每一个文件都有一个节点，一个i节点是32个字节，其中包括保存了文件类型属性，文件用户id，文件长度，修改时间，组id，文件链接数和文件占用的逻辑盘块数组。i_zone[9]代表着占用的逻辑盘块，其中0~6直接指向某个逻辑盘块，而7是一次间接指针，8是二次间接指针。

这个文件中主要包含对于inode操作的三个函数，iget()从设备上读取某个指定节点，iput()从设备上释放某一个i节点，bmap用于将文件数据块映射到盘块上。首先先来看bmap的操作：

**bmap**

```
static int _bmap(struct m_inode * inode,int block,int create)  
//create代表要新申请一个磁盘块， block文件中的数据块号，下面可以看到block的值是对应某个inode中的数据块的索引
{
	struct buffer_head * bh;
	int i;

	if (block<0)
		panic("_bmap: block<0");
	if (block >= 7+512+512*512)
		panic("_bmap: block>big");  //判断逻辑是否超过文件系统的承受范围
	if (block<7) {
		if (create && !inode->i_zone[block])  //如果需要新申请则new出一个逻辑块
			if (inode->i_zone[block]=new_block(inode->i_dev)) {
				inode->i_ctime=CURRENT_TIME;
				inode->i_dirt=1;
			}
		return inode->i_zone[block];  //直接指向的块
	}
	block -= 7;
	if (block<512) {  //说明是一级间接块
		if (create && !inode->i_zone[7])  //和上面同样的操作
			if (inode->i_zone[7]=new_block(inode->i_dev)) {
				inode->i_dirt=1;
				inode->i_ctime=CURRENT_TIME;
			}
		if (!inode->i_zone[7])
			return 0;
		if (!(bh = bread(inode->i_dev,inode->i_zone[7])))  //读入设备以及这个对应的块号指定的缓冲块的数据
			return 0;
		i = ((unsigned short *) (bh->b_data))[block];  //这个是该缓冲区的数据部分，如果这是一级间接块的话，应该存放了这个一级间接块指向的逻辑块情况
		if (create && !i)
			if (i=new_block(inode->i_dev)) {
				((unsigned short *) (bh->b_data))[block]=i;
				bh->b_dirt=1;
			}
		brelse(bh);
		return i;
	}
	block -= 512;   //以下是二级间接块
	if (create && !inode->i_zone[8])
		if (inode->i_zone[8]=new_block(inode->i_dev)) {
			inode->i_dirt=1;
			inode->i_ctime=CURRENT_TIME;
		}
	if (!inode->i_zone[8])
		return 0;
	if (!(bh=bread(inode->i_dev,inode->i_zone[8])))
		return 0;
	i = ((unsigned short *)bh->b_data)[block>>9];
	if (create && !i)   
		if (i=new_block(inode->i_dev)) {
			((unsigned short *) (bh->b_data))[block>>9]=i;
			bh->b_dirt=1;
		}
	brelse(bh);
	if (!i)
		return 0;
	if (!(bh=bread(inode->i_dev,i)))
		return 0;
	i = ((unsigned short *)bh->b_data)[block&511];
	if (create && !i)
		if (i=new_block(inode->i_dev)) {
			((unsigned short *) (bh->b_data))[block&511]=i;
			bh->b_dirt=1;
		}
	brelse(bh);//释放该缓冲区
	return i;  //可以看到其实这是一个嵌套新建块的过程，如果一级目录没有建立，那么就会建立之后再把对应的数据块建立出来，然后放入逻辑块对应的块号。
}
```

**iget**

```
struct m_inode * iget(int dev,int nr) //返回一个i节点，给的参数是设备号和i节点号
{
	struct m_inode * inode, * empty;

	if (!dev)
		panic("iget with dev==0");
	empty = get_empty_inode(); //找一个空的inode，这是用来最后如果没有再高速缓冲区中找到的情况
	inode = inode_table;  //定位到存储i节点的表
	while (inode < NR_INODE+inode_table) {  //找对应的inode
		if (inode->i_dev != dev || inode->i_num != nr) {  //inode对应的设备或者i节点号是否相同
			inode++;
			continue;
		}
		wait_on_inode(inode);
		if (inode->i_dev != dev || inode->i_num != nr) {
			inode = inode_table;
			continue;
		}
		inode->i_count++;  //inode的引用加1
		if (inode->i_mount) {  //这说明这个inode是其他文件系统的安装点
			int i;

			for (i = 0 ; i<NR_SUPER ; i++)
				if (super_block[i].s_imount==inode)  //在这个全局超级块数组中找对应的文件系统
					break;
			if (i >= NR_SUPER) {
				printk("Mounted inode hasn't got sb\n");
				if (empty)
					iput(empty);
				return inode;
			}
			iput(inode);
			dev = super_block[i].s_dev;  //切换到对应的设备上
			nr = ROOT_INO;   //指定i节点号为1，就相当于重新找
			inode = inode_table;
			continue;
		}
		if (empty)
			iput(empty); 
		return inode;  //这里代表了对应的i节点已经被找到了，因此就释放之前申请的空闲的块，然后返回找到的块
	}
	if (!empty)
		return (NULL);
	inode=empty;   //没有找到对应的就使用申请的一个新的i节点
	inode->i_dev = dev;
	inode->i_num = nr;
	read_inode(inode);
	return inode;
} 
```

**iput.c**

```
void iput(struct m_inode * inode)
{
	if (!inode)
		return;
	wait_on_inode(inode);
	if (!inode->i_count)  //在释放的之前计数值就已经是0了
		panic("iput: trying to free free inode");
	if (inode->i_pipe) {  //说明它是一个管道i节点，这个操作应该要在另一个pipe文件中看到
		wake_up(&inode->i_wait);
		if (--inode->i_count)
			return;
		free_page(inode->i_size);
		inode->i_count=0;
		inode->i_dirt=0;
		inode->i_pipe=0;
		return;
	}
	if (!inode->i_dev) {  //如果inode中的dev号已经为0了。
		inode->i_count--;
		return;
	}
	if (S_ISBLK(inode->i_mode)) {  //判断是否是块设备，否则需要和块设备的数据进行同步
		sync_dev(inode->i_zone[0]);
		wait_on_inode(inode);
	}
repeat:
	if (inode->i_count>1) {  //说明在释放的时候发现这个引用不止一个
		inode->i_count--;
		return;
	}
	if (!inode->i_nlinks) {  //如果这个i节点的链接数已经减少为0了，则释放该i节点并且释放所有使用到的逻辑块，此时也说明i_count已经为0并且对应的文件已经没了
		truncate(inode);  //释放这个inode对应的逻辑块
		free_inode(inode);
		return;
	}
	if (inode->i_dirt) {  
		write_inode(inode);	/* we can sleep - so do again */ //如果被修改了就需要写将节点信息写入设备
		wait_on_inode(inode);
		goto repeat;
	}
	inode->i_count--;
	return;
}
```

其中其实还有两个辅助函数write_inode和read_inode,分别是将文件系统中对应这个i节点的逻辑块的内容复制到指定的inode结构中和将inode的信息写回文件系统中（先写回缓冲区，再写回设备），执行方法如下：

```
read_inode.c:
if (!(bh=bread(inode->i_dev,block)))  //block是已经计算出的需要读的i节点的逻辑块号
		panic("unable to read i-node block");
	*(struct d_inode *)inode =
		((struct d_inode *)bh->b_data)
			[(inode->i_num-1)%INODES_PER_BLOCK];
write_inode.c:
if (!(bh=bread(inode->i_dev,block)))
		panic("unable to read i-node block");
	((struct d_inode *)bh->b_data)
		[(inode->i_num-1)%INODES_PER_BLOCK] =
			*(struct d_inode *)inode;    
```

###### super.c

这个文件处理的是对于文件系统超级块，主要就是get_super,put_super和read_super。当然在这个文件中还有处理文件系统挂载和卸载的函数sys_unmount和sys_mount。我们直接来看这些函数是怎么操作的把。

**get_super**  //获取超级块

```
struct super_block * get_super(int dev)  //取指定设备的超级块
{
	struct super_block * s;

	if (!dev)
		return NULL;
	s = 0+super_block;  //全局的super_block数组
	while (s < NR_SUPER+super_block)
		if (s->s_dev == dev) {
			wait_on_super(s);  //等待超级块被释放
			if (s->s_dev == dev)
				return s;
			s = 0+super_block;
		} else
			s++;
	return NULL;
}
```

**put_super**  //释放超级块，这是在调用umount()函数卸载一个文件系统时会调用的函数。

```
void put_super(int dev)
{
	struct super_block * sb;
	struct m_inode * inode;
	int i;

	if (dev == ROOT_DEV) {    //根文件系统不能释放
		printk("root diskette changed: prepare for armageddon\n\r");
		return;
	}
	if (!(sb = get_super(dev)))
		return;
	if (sb->s_imount) {
		printk("Mounted disk changed - tssk, tssk\n\r");
		return;
	}
	lock_super(sb);
	sb->s_dev = 0;   //设备置空
	for(i=0;i<I_MAP_SLOTS;i++)
		brelse(sb->s_imap[i]);   //释放对应的i节点占用的缓冲块
	for(i=0;i<Z_MAP_SLOTS;i++)
		brelse(sb->s_zmap[i]);   //释放占用的对应的逻辑块的缓冲块
	free_super(sb);  //释放超级块
	return;
} 
```

**read_super**  //这个函数从设备上将超级块的信息读取到内存中

```
static struct super_block * read_super(int dev)
{
	struct super_block * s;
	struct buffer_head * bh;
	int i,block;

	if (!dev)
		return NULL;
	check_disk_change(dev);
	if (s = get_super(dev))   //如果这个设备的超级块已经在缓存中了就直接返回这个超级块就行了
		return s;
	for (s = 0+super_block ;; s++) {
		if (s >= NR_SUPER+super_block)
			return NULL;
		if (!s->s_dev)
			break;
	}
	s->s_dev = dev;
	s->s_isup = NULL;
	s->s_imount = NULL;
	s->s_time = 0;
	s->s_rd_only = 0;
	s->s_dirt = 0;
	lock_super(s);
	if (!(bh = bread(dev,1))) {  //读取磁盘上的超级块，超级块就在块设备的第二个逻辑块
		s->s_dev=0;
		free_super(s);
		return NULL;
	}
	*((struct d_super_block *) s) =
		*((struct d_super_block *) bh->b_data);  //缓冲块的b_data就是磁盘上的超级块信息
	brelse(bh);
	if (s->s_magic != SUPER_MAGIC) {
		s->s_dev = 0;
		free_super(s);
		return NULL;
	}
	for (i=0;i<I_MAP_SLOTS;i++)  //初始化位图
		s->s_imap[i] = NULL;
	for (i=0;i<Z_MAP_SLOTS;i++)
		s->s_zmap[i] = NULL;
	block=2;  //i节点位图保存在设备2号块上
	for (i=0 ; i < s->s_imap_blocks ; i++)
		if (s->s_imap[i]=bread(dev,block))
			block++;
		else
			break;
	for (i=0 ; i < s->s_zmap_blocks ; i++)  //紧接着存放的就是逻辑块位图
		if (s->s_zmap[i]=bread(dev,block))
			block++;
		else
			break;
	if (block != 2+s->s_imap_blocks+s->s_zmap_blocks) {
		for(i=0;i<I_MAP_SLOTS;i++)
			brelse(s->s_imap[i]);
		for(i=0;i<Z_MAP_SLOTS;i++)
			brelse(s->s_zmap[i]);
		s->s_dev=0;
		free_super(s);
		return NULL;
	}
	s->s_imap[0]->b_data[0] |= 1;  //置位第一个i节点位图全1
	s->s_zmap[0]->b_data[0] |= 1;  //同理
	free_super(s);             
	return s;
}
```

说一下接下来的三个函数：

sys_unmount:这个函数是从系统中卸载某个文件系统，这个函数首先会取设备的超级块，然后看这个设备被安装到的i节点，随后查找i节点表看是否存在进程正在这个设备上运行，正常情况下要求在卸载的时候不能有进程正在运行在该设备上了。这时置空这个i节点，随后释放设备的超级块，并且释放位图占用的缓冲块。

```
int sys_umount(char * dev_name)
{
	struct m_inode * inode;
	struct super_block * sb;
	int dev;

	if (!(inode=namei(dev_name)))  //根据设备名找到对应的i节点
		return -ENOENT;
	dev = inode->i_zone[0];  // 设备一般i_zone第一个是设备号
	if (!S_ISBLK(inode->i_mode)) {
		iput(inode);
		return -ENOTBLK;
	}
	iput(inode);  //释放这个i节点
	if (dev==ROOT_DEV)  //不能卸载根文件系统
		return -EBUSY;
	if (!(sb=get_super(dev)) || !(sb->s_imount))
		return -ENOENT;
	if (!sb->s_imount->i_mount)
		printk("Mounted inode has i_mount=0\n");
	for (inode=inode_table+0 ; inode<inode_table+NR_INODE ; inode++)  //查找是否有进程还在使用这个i节点
		if (inode->i_dev==dev && inode->i_count)
				return -EBUSY;
	sb->s_imount->i_mount=0;  //释放文件系统安装i节点
	iput(sb->s_imount);
	sb->s_imount = NULL;
	iput(sb->s_isup);
	sb->s_isup = NULL;
	put_super(dev);  //释放超级块
	sync_dev(dev);
	return 0;
}
```

sys_mount:就是挂载某个文件系统了，那么显然它也应该是卸载i节点的逆操作。那么首先函数根据对应的设备文件名找到对应的i节点，然后取到其中的设备号。文件系统必须被加载到一个目录名，因此需要由给定的目录名找到对应的i节点，然后读取该文件系统的超级块，然后将这个i节点置位。

```
int sys_mount(char * dev_name, char * dir_name, int rw_flag) //dev_name是设备名，dir_name是安装到的目录，rw_flag是文件系统的读写标志
{
	struct m_inode * dev_i, * dir_i;
	struct super_block * sb;
	int dev;

	if (!(dev_i=namei(dev_name)))  //根据设备名，找到对应的i节点
		return -ENOENT;
	dev = dev_i->i_zone[0];  //获得设备号
	if (!S_ISBLK(dev_i->i_mode)) {
		iput(dev_i);
		return -EPERM;
	}
	iput(dev_i);  //先释放该i节点
	if (!(dir_i=namei(dir_name)))  //根据目录名获得对应的i节点
		return -ENOENT;
	if (dir_i->i_count != 1 || dir_i->i_num == ROOT_INO) {  //判断引用计数是否为1，或者是否为根
		iput(dir_i);
		return -EBUSY;
	}
	if (!S_ISDIR(dir_i->i_mode)) {  //判断当前i节点是否为一个目录
		iput(dir_i);
		return -EPERM;
	}
	if (!(sb=read_super(dev))) { //读取了设备的超级块信息  
		iput(dir_i);
		return -EBUSY;
	}
	if (sb->s_imount) {  //如果这个设备已经被挂载了。
		iput(dir_i);
		return -EBUSY;
	}
	if (dir_i->i_mount) {  //该i节点已经挂载了其他文件系统
		iput(dir_i);
		return -EPERM;
	}
	sb->s_imount=dir_i;  //超级块上注明挂在位置
	dir_i->i_mount=1;  //i节点上注明了已经挂载了文件系统
	dir_i->i_dirt=1;		/* NOTE! we don't iput(dir_i) */
	return 0;			/* we do that in umount */
}
```

mount_root这个函数的目的是在开机初始化的时候挂载根文件系统。这个函数的调用位置是在初始化硬盘的时候。

```
void mount_root(void)
{
	int i,free;
	struct super_block * p;
	struct m_inode * mi;

	if (32 != sizeof (struct d_inode))
		panic("bad i-node size");
	for(i=0;i<NR_FILE;i++)  //初始化全局的文件表
		file_table[i].f_count=0;
	if (MAJOR(ROOT_DEV) == 2) {  //如果是软盘上存在根文件，则需要提示插入软盘
		printk("Insert root floppy and press ENTER");
		wait_for_keypress();
	}
	for(p = &super_block[0] ; p < &super_block[NR_SUPER] ; p++) {  //初始化全局的超级块表
		p->s_dev = 0;
		p->s_lock = 0;
		p->s_wait = NULL;
	}
	if (!(p=read_super(ROOT_DEV)))  //读取根文件系统的超级块
		panic("Unable to mount root");
	if (!(mi=iget(ROOT_DEV,ROOT_INO)))  //给他获取1号i节点，那么一开始肯定是给了一个空的i节点
		panic("Unable to read root i-node");
	mi->i_count += 3 ;	/* NOTE! it is logically used 4 times, not 1 */
	p->s_isup = p->s_imount = mi;  //设置文件系统根目录和被安装节点都是该节点
	current->pwd = mi;  //当前进程工作目录和当前进程的根目录是该节点
	current->root = mi;
	free=0;
	i=p->s_nzones;
	while (-- i >= 0)  //统计一下当前设备上空闲逻辑块个数
		if (!set_bit(i&8191,p->s_zmap[i>>13]->b_data))
			free++;
	printk("%d/%d free blocks\n\r",free,p->s_nzones);
	free=0;
	i=p->s_ninodes+1;
	while (-- i >= 0)  //当前设备上空闲i节点的个数
		if (!set_bit(i&8191,p->s_imap[i>>13]->b_data))
			free++;
	printk("%d/%d free inodes\n\r",free,p->s_ninodes);
}
```

###### namei.c

这个文件我觉得是比较关键的一个文件之一，为什么这么说，因为在这个函数中定义了如何创建目录，删除目录，创建文件和删除文件等系统调用，同时主要实现了根据目录名或者文件名寻找对应i节点的函数namei。而这一系列的操作的本质，其实就是对于i节点的操作，所以我认为在文件系统中对于i节点的操作的核心就在这个文件中了。

在存储的时候，目录下其他所有文件名对应的目录想都会存放在这个目录文件名对应的数据块中，而我们已经提到了，文件目录项有一个存放了文件名以及i节点。而对于那个目录下的文件名对应的文件信息，都被保存在对应的i节点中。我们需要注意的是，一个目录下还有两个特殊的目录项.和..，这两个目录项一个是绑定了当前的i节点，另一个则是绑定了当前节点父节点的i节点号。

在其中有两个使用比较核心的函数：find_entry和add_entry函数。

**find_entry**

这个函数是在指定的目录中去查找指定目录项的函数

```
static struct buffer_head * find_entry(struct m_inode ** dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
	//参数中dir代表的是目录i节点，name代表文件名，res_dir返回找到的目录，而本函数返回的是找到的缓冲块
{
	int entries;
	int block,i;
	struct buffer_head * bh;
	struct dir_entry * de;
	struct super_block * sb;

#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
		namelen = NAME_LEN;
#endif
	entries = (*dir)->i_size / (sizeof (struct dir_entry)); //目录i节点中的i_size字段包含了目录包含的数据长度
	*res_dir = NULL;
	if (!namelen)
		return NULL;
/* check for '..', as we might have to do some "magic" for it */
	if (namelen==2 && get_fs_byte(name)=='.' && get_fs_byte(name+1)=='.') {
	//如果当前已经在根目录下了，但是用户的输入中还是打了..，那么不能退回到父节点，应该进行修改
/* '..' in a pseudo-root results in a faked '.' (just change namelen) */
		if ((*dir) == current->root)
			namelen=1;
		else if ((*dir)->i_num == ROOT_INO) {
/* '..' over a mount-point results in 'dir' being exchanged for the mounted
   directory-inode. NOTE! We set mounted, so that we can iput the new dir */
			sb=get_super((*dir)->i_dev);
			if (sb->s_imount) {
				iput(*dir);
				(*dir)=sb->s_imount;
				(*dir)->i_count++;
			}
		}
	}   //表示看不懂
	if (!(block = (*dir)->i_zone[0]))  //目录i节点对应的数据块信息
		return NULL;
	if (!(bh = bread((*dir)->i_dev,block)))
		return NULL;
	i = 0;
	de = (struct dir_entry *) bh->b_data;  //获取了这个数据块中存放的目录信息
	while (i < entries) {
		if ((char *)de >= BLOCK_SIZE+bh->b_data) { //因为这里相当于只读了第一个数据块，走到这里说明在这个数据块中没有找到对应的目录项
			brelse(bh);
			bh = NULL;
			if (!(block = bmap(*dir,i/DIR_ENTRIES_PER_BLOCK)) || // 计算目录文件中的块号，也就是在这个i节点中的块号，那么通过bmap可以获得对应逻辑块的块号 
			    !(bh = bread((*dir)->i_dev,block))) {  //读取这个块
				i += DIR_ENTRIES_PER_BLOCK;
				continue;
			}
			de = (struct dir_entry *) bh->b_data;  //获取对应的数据块内容
		}
		if (match(namelen,name,de)) {  //这里是在匹配是否找到了匹配名字的目录项
			*res_dir = de;  //res_dir就是该目录项
			return bh;  //返回的是缓冲块
		}
		de++; //下一个目录项
		i++; 
	}
	brelse(bh);
	return NULL;
}
```

**add_entry**

```
static struct buffer_head * add_entry(struct m_inode * dir,
	const char * name, int namelen, struct dir_entry ** res_dir)
{
	int block,i;
	struct buffer_head * bh;
	struct dir_entry * de;

	*res_dir = NULL;
#ifdef NO_TRUNCATE
	if (namelen > NAME_LEN)
		return NULL;
#else
	if (namelen > NAME_LEN)
		namelen = NAME_LEN;
#endif
	if (!namelen)
		return NULL;
	if (!(block = dir->i_zone[0])) //获取了目录所在逻辑块的块号
		return NULL;
	if (!(bh = bread(dir->i_dev,block)))  //读取了这个逻辑块的块数据
		return NULL;
	i = 0;
	de = (struct dir_entry *) bh->b_data;
	while (1) {
		if ((char *)de >= BLOCK_SIZE+bh->b_data) {  //说明没有找到空目录项
			brelse(bh);
			bh = NULL;
			block = create_block(dir,i/DIR_ENTRIES_PER_BLOCK);  //读取或者创建设备上对应的逻辑块，也就是看是否有下一块逻辑块，如果没有新建一块
			if (!block)
				return NULL;
			if (!(bh = bread(dir->i_dev,block))) {
				i += DIR_ENTRIES_PER_BLOCK;
				continue;
			}
			de = (struct dir_entry *) bh->b_data;
		}
		//下面的说法是当序号乘上目录结构大小超过目录指出的i_size则说明这个目录项并没有被使用，那么我们就可是使用它。
		if (i*sizeof(struct dir_entry) >= dir->i_size) { //说明整个目录文件数据中没有空目录项了
			de->inode=0;  //注意这一步先置空i节点
			dir->i_size = (i+1)*sizeof(struct dir_entry);
			dir->i_dirt = 1;
			dir->i_ctime = CURRENT_TIME;
		}
		if (!de->inode) { //否则这就找到了一个有用的目录项
			dir->i_mtime = CURRENT_TIME;
			for (i=0; i < NAME_LEN ; i++)
				de->name[i]=(i<namelen)?get_fs_byte(name+i):0;  //输入这个目录项对应的名字
			bh->b_dirt = 1;
			*res_dir = de;  //res_dir指向这个新的目录项
			return bh;  //返回对应的缓冲块
		}
		de++;
		i++;
	}
	brelse(bh);
	return NULL;
}
```

有了这两个函数，那么其他函数理解起来就十分方便了

``static struct m_inode * get_dir(const char * pathname, struct m_inode *inode)``

这个函数的目的是通过路径名来找到对应的i节点。inode参数是当前的其实目录的i节点，而pathname是需要搜索的目录。对于pathname每隔一个/就获取目录名。当我们获得了下一个目录的目录名后，使用find_entry从当前目录寻找下一个目录的i节点和缓冲块。根据拿到的目录指针获取对应的i节点号，随即拿到i节点内容。直到这个路径上已经没有了可以查找的目录。

``static struct m_inode * dir_namei(const char * pathname,int * namelen, const char ** name)``

这个函数的目的是根据路径找到i节点的同时还返回对应的目录或者文件名，这里有个有意思的地方，这个函数是使用了get_dir函数去寻找的目录i节点，但是它只会返回最后一个/之前的目录，意思是其实真正完整的目录路径应该类似'/usr/local/'，但是它确实返回了路径上的最高一级的路径。

中间还要穿插一个寻找符号链接的操作follow_link，这个操作就是查找某个符号链接连接到的文件的i节点。

**namei**

取得指定路径的i节点，你可以看到namei就是对于dir_namei的又一层封装。

```
struct m_inode * namei(const char * pathname)
{
	const char * basename;
	int inr,dev,namelen;
	struct m_inode * dir;
	struct buffer_head * bh;
	struct dir_entry * de;

	if (!(dir = dir_namei(pathname,&namelen,&basename)))
		return NULL;
	if (!namelen)			/* special case: '/usr/' etc */
		return dir;
	bh = find_entry(&dir,basename,namelen,&de);  //为什么这边又要根据basename去找下一层节点，就是因为如果在namelen不为0的情况下当前的目录其实是上一级的目录。
	if (!bh) {
		iput(dir);
		return NULL;
	}
	inr = de->inode;
	dev = dir->i_dev;
	brelse(bh);
	iput(dir);
	dir=iget(dev,inr);  //获取的是i节点
	if (dir) {
		dir->i_atime=CURRENT_TIME;
		dir->i_dirt=1;
	}
	return dir;
}
```

下面开始就是各个系统调用的实现，其实大同小异，因为有了上面这些函数的铺垫

**open_namei**

这个函数是open系统调用使用的函数，打开文件，使用上面的namei

```
int open_namei(const char * pathname, int flag, int mode,
	struct m_inode ** res_inode)
{
	const char * basename;
	int inr,dev,namelen;
	struct m_inode * dir, *inode;
	struct buffer_head * bh;
	struct dir_entry * de;

	if ((flag & O_TRUNC) && !(flag & O_ACCMODE))  //先对这个打开函数中使用的标志位进行处理
		flag |= O_WRONLY;
	mode &= 0777 & ~current->umask;
	mode |= I_REGULAR;
	if (!(dir = dir_namei(pathname,&namelen,&basename)))  //根据文件名路径找到对应的最高层目录i节点
		return -ENOENT;
	if (!namelen) {			/* special case: '/usr/' etc */
		if (!(flag & (O_ACCMODE|O_CREAT|O_TRUNC))) {
			*res_inode=dir;  //如果全是到达了最后的节点，那么返回
			return 0;
		}
		iput(dir);
		return -EISDIR;
	}
	bh = find_entry(&dir,basename,namelen,&de);  //上面这些代码依然是基本操作，就是在找最后以及文件的i节点
	if (!bh) {  //如果没有找到的话，说明最后一级并没有对应的缓冲块，那么就要新建一个
		if (!(flag & O_CREAT)) {
			iput(dir);
			return -ENOENT;
		}
		if (!permission(dir,MAY_WRITE)) {
			iput(dir);
			return -EACCES;
		}
		inode = new_inode(dir->i_dev);  //为这个设备在i节点位图上新找一个i节点
		if (!inode) {  
			iput(dir);
			return -ENOSPC;
		}
		inode->i_uid = current->euid;
		inode->i_mode = mode;
		inode->i_dirt = 1;
		bh = add_entry(dir,basename,namelen,&de);  //这样就在当前的目录下新填了一个目录项
		if (!bh) {
			inode->i_nlinks--;
			iput(inode);
			iput(dir);
			return -ENOSPC;
		}
		de->inode = inode->i_num;
		bh->b_dirt = 1;
		brelse(bh);
		iput(dir);
		*res_inode = inode;
		return 0;
	}  //从这里往下，是假设在之前最后以及目录项找到了，那么说明已经存在对应的文件或者目录了，那么打开
	inr = de->inode;
	dev = dir->i_dev;
	brelse(bh);
	iput(dir);
	if (flag & O_EXCL)
		return -EEXIST;
	if (!(inode=iget(dev,inr)))
		return -EACCES;
	if ((S_ISDIR(inode->i_mode) && (flag & O_ACCMODE)) ||
	    !permission(inode,ACC_MODE(flag))) {
		iput(inode);
		return -EPERM;
	}
	inode->i_atime = CURRENT_TIME;
	if (flag & O_TRUNC)
		truncate(inode);   //这个函数释放了该i节点上占用的所有逻辑块。
	*res_inode = inode;  //这就是最终需要打开的文件所在的i节点
	return 0;
}
```

好了，那么我也不累赘的一个个函数这么说了，上面的这个函数基本已经告诉了你这样的系统调用怎么写了，首先就是通过dir_namei去按目录找到对应的目录i节点项以及获取到最高一级的目录名，随后就根据最高一级目录名获取对应的缓冲块。这里就需要分两种情况了，如果我找到了对应的缓冲块那么应该如何做？如果没有找到又该如何做？

这样的函数还包括了sys_mknod（按照指定的路径创建一个文件的i节点），sys_mkdir（创建一个目录，注意创建目录的时候要为目录读入第一个数据块，因为一个目录中必然包含了'.'和'..'，然后再将这个目录项插入）,sys_rmdir（删除一个目录，先根据路径找到对应的目录i节点，然后有几种特殊情况是无法删除的，权限不足，链接数大于1，当前目录就是删除的目录，如果目录非空。可以想象删除需要原目录bh，源目录i节点，该目录的目录结构，该目录的i节点），empty_dir（判断是否目录为空，这时一个辅助函数），sys_unlink（删除一个硬文件链接，）,sys_link（创建一个文件硬链接，就是获取那个文件i节点号，然后将它放到新目录指定i节点的数据块中就行了），sys_symlink（创建一个符号链接，创建符号链接的过程其实就是先找到新的文件名的路径，然后给它分配一个新的i节点，在这个i节点的第一个zone里面的数据块内容中放入文件名，然后插入上级目录的i节点中）。

###### block_dev.c

该文件是块设备数据访问操作类程序。这个文件中一共只有两个函数block_read()和block_write()，这两个函数都是通过用户给出的pos，去寻找对应缓冲块的对应位置，然后将数据从缓冲块中复制到用户buf中或者是将数据从用户的buf中复制到缓冲区。

**block_read**

```
int block_read(int dev, unsigned long * pos, char * buf, int count)
//pos给的是偏移，count给的是长度，这样就是将给定长度的内容写入设备的某个偏移位置
{
	int block = *pos >> BLOCK_SIZE_BITS;
	int offset = *pos & (BLOCK_SIZE-1);  //这两步可以看出通过一维的pos计算出在第几块的偏移位置
	int chars;
	int read = 0;
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
		chars = BLOCK_SIZE-offset;  //第一个块还有多少
		if (chars > count)   //如果剩余的需要读的数据不足chars
			chars = count;
		if (!(bh = breada(dev,block,block+1,block+2,-1)))  //预读出数据块
			return read?read:-EIO;
		block++;  
		p = offset + bh->b_data; //块上需要读的数据的首地址
		offset = 0;
		*pos += chars;
		read += chars;
		count -= chars;  //为下一次读入初始化数据
		while (chars-->0)
			put_fs_byte(*(p++),buf++);  //一个字符一个字符读入缓冲区
		brelse(bh);
	}
	return read;
}
```

**read_write**

```
int block_write(int dev, long * pos, char * buf, int count)
{
	int block = *pos >> BLOCK_SIZE_BITS;
	int offset = *pos & (BLOCK_SIZE-1);
	int chars;
	int written = 0;
	struct buffer_head * bh;
	register char * p;

	while (count>0) {
		chars = BLOCK_SIZE - offset;
		if (chars > count)
			chars=count;
		if (chars == BLOCK_SIZE)
			bh = getblk(dev,block);  //如果长度为一个块长，根据设备和逻辑块号找到对应的写的块
		else
			bh = breada(dev,block,block+1,block+2,-1);  //否则前一块不止一块的长度，需要预读
		block++;
		if (!bh)
			return written?written:-EIO;
		p = offset + bh->b_data;
		offset = 0;
		*pos += chars;
		written += chars;
		count -= chars;
		while (chars-->0)
			*(p++) = get_fs_byte(buf++);   //写入p指向的告诉缓冲区中
		bh->b_dirt = 1;
		brelse(bh);
	}
	return written;
}
```

###### file_dev.c

这个文件就是用于访问文件的数据

**file_read**

```
int file_read(struct m_inode * inode, struct file * filp, char * buf, int count)
//inode是该文件对应的i节点，而filp代表了该文件结构
{
	int left,chars,nr;
	struct buffer_head * bh;

	if ((left=count)<=0)
		return 0;
	while (left) {
		if (nr = bmap(inode,(filp->f_pos)/BLOCK_SIZE)) {  //先取该文件当前读写的位置在设备上对应的逻辑块号
			if (!(bh=bread(inode->i_dev,nr))) //取对应的缓冲块
				break;
		} else
			bh = NULL;
		nr = filp->f_pos % BLOCK_SIZE;  //这里计算的就应该是当前那一块的读写位置
		chars = MIN( BLOCK_SIZE-nr , left );
		filp->f_pos += chars;
		left -= chars;
		if (bh) {
			char * p = nr + bh->b_data;
			while (chars-->0)         //读取文件中数据
				put_fs_byte(*(p++),buf++);
			brelse(bh);
		} else {
			while (chars-->0)
				put_fs_byte(0,buf++);  //如果没有读到数据就用0填充
		}
	}
	inode->i_atime = CURRENT_TIME;
	return (count-left)?(count-left):-ERROR;
}
```

**file_write**

```
int file_write(struct m_inode * inode, struct file * filp, char * buf, int count)
{
	off_t pos;
	int block,c;
	struct buffer_head * bh;
	char * p;
	int i=0;

/*
 * ok, append may not work when many processes are writing at the same time
 * but so what. That way leads to madness anyway.
 */
	if (filp->f_flags & O_APPEND)
		pos = inode->i_size;  //如果是向文件后添加数据，指针指向文件末尾
	else
		pos = filp->f_pos;    //否则指向当前读写位置
	while (i<count) {
		if (!(block = create_block(inode,pos/BLOCK_SIZE)))  //创建逻辑块
			break;
		if (!(bh=bread(inode->i_dev,block))) //读取对应的缓冲块
			break;
		c = pos % BLOCK_SIZE;  //写的位置
		p = c + bh->b_data;  //指针位置
		bh->b_dirt = 1;
		c = BLOCK_SIZE-c;
		if (c > count-i) c = count-i;
		pos += c;
		if (pos > inode->i_size) {
			inode->i_size = pos;
			inode->i_dirt = 1;
		}
		i += c;
		while (c-->0)
			*(p++) = get_fs_byte(buf++);  //将buf中的数据写入p指向的位置
		brelse(bh);
	}
	inode->i_mtime = CURRENT_TIME;
	if (!(filp->f_flags & O_APPEND)) {
		filp->f_pos = pos;
		inode->i_ctime = CURRENT_TIME;
	}
	return (i?i:-1);
}
```

###### pipe.c

管道在linux系统中也是一个特殊的结构，也是在linux系统中进程之间进行通信的最基本的方式，它的目的也是读取数据到指向管道的缓冲块内，同样也可以从这个区域中将数据读出。使用管道时，管道i节点的i_size字段会被设置为指向管道缓冲区指针，管道头部指针存放入i_zone[0]，管道数据尾部指针存放在i_zone[1]中。对于管道的读操作是从管道尾部读出，写操作是从管道头部写入。

**pipe_read**

```
int read_pipe(struct m_inode * inode, char * buf, int count)
{
	int chars, size, read = 0;

	while (count>0) {
		while (!(size=PIPE_SIZE(*inode))) {  //size获取了管道中还需要读出数据的多少
			wake_up(&inode->i_wait); //如果没有数据了，需要唤醒对于当前管道i节点的写进程
			if (inode->i_count != 2) /* are there any writers? */  //判断是否有向管道中写入的请求
				return read;
			sleep_on(&inode->i_wait);  //然后挂起
		}
		chars = PAGE_SIZE-PIPE_TAIL(*inode);  //读取字符的数量
		if (chars > count)
			chars = count;
		if (chars > size)
			chars = size;
		count -= chars;
		read += chars;
		size = PIPE_TAIL(*inode);  //暂存尾指针
		PIPE_TAIL(*inode) += chars;  //移动尾指针，向头部移动
		PIPE_TAIL(*inode) &= (PAGE_SIZE-1);  //如果超过缓冲区则绕回
		while (chars-->0)
			put_fs_byte(((char *)inode->i_size)[size++],buf++);  //读取chars个字符
	}
	wake_up(&inode->i_wait);  //唤醒写进程
	return read;
}
```

**pipe_write**

和pipe_read十分类似，就不需要重复来看了。

**sys_pipe**

这个文件中还有一个初始化管道的一个函数叫做sys_pipe，所做的事就是初始化管道的读和管道写句柄，然后将这两个句柄复制到用户空间中。这里使用了一个参数fildes，这个是文件的句柄数组，0是读管道数据，1是写管道数据，这两个文件句柄都指向了同一个pipei节点。

```
int sys_pipe(unsigned long * fildes)
{
	struct m_inode * inode;
	struct file * f[2];   //两个文件结构
	int fd[2];  //两个文件句柄
	int i,j;

	j=0;
	for(i=0;j<2 && i<NR_FILE;i++)
		if (!file_table[i].f_count)
			(f[j++]=i+file_table)->f_count++;   //在全局的文件表中找到两个空的文件项
	if (j==1)
		f[0]->f_count=0;
	if (j<2)
		return -1;   //如果没找到就返回
	j=0;
	for(i=0;j<2 && i<NR_OPEN;i++)  //再在当前进程中找到两个空的文件句柄项
		if (!current->filp[i]) {
			current->filp[ fd[j]=i ] = f[j];
			j++;
		}
	if (j==1)
		current->filp[fd[0]]=NULL;
	if (j<2) {
		f[0]->f_count=f[1]->f_count=0;
		return -1;
	}
	if (!(inode=get_pipe_inode())) {   //get_pipe_node应该是获取在初始化的时候就生成的一个pipe拥有的i节点
		current->filp[fd[0]] =
			current->filp[fd[1]] = NULL;
		f[0]->f_count = f[1]->f_count = 0;
		return -1;
	}
	f[0]->f_inode = f[1]->f_inode = inode； //让这两个句柄中的i节点指针都指向这个pipe节点
	f[0]->f_pos = f[1]->f_pos = 0;
	f[0]->f_mode = 1;		/* read */
	f[1]->f_mode = 2;		/* write */
	put_fs_long(fd[0],0+fildes);
	put_fs_long(fd[1],1+fildes); //这两个的内容复制到对应的用户空间中
	return 0;
}
```

###### char_dev.c

这个文件包括一些字符设备的文件的访问没其中有很多函数还没有实现，简单的说一下：rw_ttyx是向串口终端设备读写，主设备号是4；rw_tty是向控制台读写函数，主设备号是5；rw_mem是内存设备文件读写，主设备是rw_char是对字符设备读写函数的接口。

###### read_write.c

这个文件就是实现了read，write和lseek系统调用的文件。这里按一共涉及三个函数，使用的就是上面讲到的四个文件，对于块设备、字符设备、管道、文件的读写。

你可以很简单的想到read函数首先根据fd文件描述符从当前进程中读取对应的文件。然后获取该文件所在的inode，根据inode中的标志来判断该文件是一个管道文件还是字符文件还是块文件还是普通文件。write函数也是如此。lseek函数是返回一个文件的读写位置指针。

**sys_lseek**

这个函数的目的是重定读写指针，意思是当前的文件指针选择某个地方进行offset个偏移选项后定位指针，其中参数offset代表了新的读写指针偏移值，而origin代表了偏移的起始位置。

```
int sys_lseek(unsigned int fd,off_t offset, int origin)
{
	struct file * file;
	int tmp;

	if (fd >= NR_OPEN || !(file=current->filp[fd]) || !(file->f_inode)
	   || !IS_SEEKABLE(MAJOR(file->f_inode->i_dev)))  //判断打开文件数，文件句柄，i节点是否正确
		return -EBADF;
	if (file->f_inode->i_pipe)  //管道文件头尾指针不能够随意移动
		return -ESPIPE;
	switch (origin) {  //对于这origin参数，有三种选择
		case 0:  //将文件起始作为文件读写指针
			if (offset<0) return -EINVAL;
			file->f_pos=offset;  //设置文件开始指针
			break;
		case 1:  //将文件当前位置开始重定位文件读写指针
			if (file->f_pos+offset<0) return -EINVAL;
			file->f_pos += offset;
			break;
		case 2:  //使用文件末尾作为文件读写指针
			if ((tmp=file->f_inode->i_size+offset) < 0)
				return -EINVAL;
			file->f_pos = tmp;
			break;
		default:
			return -EINVAL;
	}
	return file->f_pos;  //返回文件重定位后的指针
}
```

**sys_read**

```
int sys_read(unsigned int fd,char * buf,int count)  //文件描述符为参数
{
	struct file * file;
	struct m_inode * inode;

	if (fd>=NR_OPEN || count<0 || !(file=current->filp[fd]))
		return -EINVAL;
	if (!count)
		return 0;
	verify_area(buf,count);
	inode = file->f_inode;  //取该文件的i节点
	if (inode->i_pipe)  //如果这个文件i节点是管道
		return (file->f_mode&1)?read_pipe(inode,buf,count):-EIO;  
	if (S_ISCHR(inode->i_mode))  //字符设备
		return rw_char(READ,inode->i_zone[0],buf,count,&file->f_pos);
	if (S_ISBLK(inode->i_mode))  //块设备
		return block_read(inode->i_zone[0],&file->f_pos,buf,count);
	if (S_ISDIR(inode->i_mode) || S_ISREG(inode->i_mode)) {  //否则是文件读写，判断是否为目录文件还是常规文件
		if (count+file->f_pos > inode->i_size)
			count = inode->i_size - file->f_pos;
		if (count<=0)
			return 0;
		return file_read(inode,file,buf,count);
	}
	printk("(Read)inode->i_mode=%06o\n\r",inode->i_mode);
	return -EINVAL;
}
```

sys_write函数也是同样的原理。那么对于一个用户进程而言，一个读写的过程就已经可以完整的描述出来了。对于用户程序而说，它们并不直接调用系统调用，而是通过调用函数库libc.a中的子程序来操作，这类子程序就相当于是系统调用的一个包裹层，工作于引用程序和内核系统之间。在linux系统中，所有的输入与输出都通过读写文件来实现，因为它将外设也表示为了文件形式。libc中的read和write函数如果将它们展开，起始就是执行了一次int80的系统调用，然后在执行时指明了功能号，由内核可以知道是调用了sys_read或者sys_write。内核代码从文件描述符对应的文件表中找到文件i节点，再对不同的文件类型进行对应的处理。

###### open.c

这个文件除了像文件名所述的这样和打开文件有关，同时还包含了创建文件，关闭文件，文件属性修改，文件访问权限修改等操作，其实对于文件的打开，在namei中就已经基本接触了文件的打开操作，就是根据文件路径找到对应的i节点和缓冲块。那么来看看其他函数是怎么操作的。

*int sys_utime(char\*filename, struct utimbuf\* time)*

这个函数设置了文件的访问和修改的时间，time这个结构体中包含了访问时间和修改时间。

*int sys_access(const char\* filename, int mode)*

这个函数检查了文件的访问权限，根据filename来查找i节点，然后提取其中的i_mode字段。

*int sys_chdir(const char\* filename)*

这个函数改变当前的工作目录，将filename对应的i节点赋给对应的用户进程，应该是cd的系统调用

```
int sys_chdir(const char * filename)
{
	struct m_inode * inode;

	if (!(inode = namei(filename)))  //根据文件名获取i节点
		return -ENOENT;
	if (!S_ISDIR(inode->i_mode)) {  //如果这个i节点不是表示目录就报错
		iput(inode);
		return -ENOTDIR;
	}
	iput(current->pwd);  //放回当前工作目录
	current->pwd = inode; //将工作目录切换到这个i节点
	return (0);
}
```

*int sys_chroot(const char\* filename)*

这个函数改变了根目录，将某个指定的而路径改成了根目录，这个也是根据文件名找到i节点，然后将该进程中的根目录项修改掉。

*int sys_chmod(const char\* filename, int mode)*

这个函数的目的是修改文件的属性，首先通过文件名找到对应的i节点，随后修改这个i节点中的i_mode属性。

*int sys_chown(const char\* filename, int uid, int gid)*

这个函数的目的是修改了宿主，包括修改文件的用户标识符和组标识符。方法和上面修改属性一样。

**sys_open**

open系统调用

```
int sys_open(const char * filename,int flag,int mode)
{
	struct m_inode * inode;
	struct file * f;
	int i,fd;

	mode &= 0777 & ~current->umask;
	for(fd=0 ; fd<NR_OPEN ; fd++)   //查找进程结构中的文件空闲项，这一步相当于拿到了文件描述符
		if (!current->filp[fd])
			break;
	if (fd>=NR_OPEN)
		return -EINVAL;
	current->close_on_exec &= ~(1<<fd);  //这个close_on_exec是当前进程打开的所有文件的位图，这个在后面的execve里会提到
	f=0+file_table;  //查看全局
	for (i=0 ; i<NR_FILE ; i++,f++)   //查找空闲文件结构项
		if (!f->f_count) break;
	if (i>=NR_FILE)
		return -EINVAL;
	(current->filp[fd]=f)->f_count++;  //这个的意思是让当前进程中的第fd个文件指向了全局文件中的f
	if ((i=open_namei(filename,flag,mode,&inode))<0) {  //这边就是调用了open_namei打开这个文件，inode是该文件的i节点
		current->filp[fd]=NULL;
		f->f_count=0;
		return i;
	}
/* ttys are somewhat special (ttyxx major==4, tty major==5) */
	if (S_ISCHR(inode->i_mode))  //检查对应的的是否为字符设备
		if (MAJOR(inode->i_zone[0])==4) {
			if (current->leader && current->tty<0) {
				current->tty = MINOR(inode->i_zone[0]);
				tty_table[current->tty].pgrp = current->pgrp;
			}
		} else if (MAJOR(inode->i_zone[0])==5)
			if (current->tty<0) {
				iput(inode);
				current->filp[fd]=NULL;
				f->f_count=0;
				return -EPERM;
			}
/* Likewise with block-devices: check for floppy_change */
	if (S_ISBLK(inode->i_mode))   //检查是否为块设备
		check_disk_change(inode->i_zone[0]);
	f->f_mode = inode->i_mode;
	f->f_flags = flag;
	f->f_count = 1;
	f->f_inode = inode;
	f->f_pos = 0;  //以上在初始化
	return (fd);  //返回文件描述符
}
```

sys_create就是使用了open这个函数来进行调用的，因为open_namei这个函数支持新建一个i节点。

**sys_close**

close系统调用

```
int sys_close(unsigned int fd)
{	
	struct file * filp;

	if (fd >= NR_OPEN)
		return -EINVAL;
	current->close_on_exec &= ~(1<<fd);
	if (!(filp = current->filp[fd]))
		return -EINVAL;
	current->filp[fd] = NULL;  //找到进程中对应文件描述符的文件然后释放
	if (filp->f_count == 0)
		panic("Close: file count is 0");
	if (--filp->f_count)
		return (0);
	iput(filp->f_inode);  //如果文件已经没有引用句柄了，则释放对应的i节点
	return (0);
}
```

###### exec.c

本文件实现了二进制可执行文件或者shell脚本的加载和执行，是系统调用exec所在。在linux早期的版本中仅支持了a.out格式的可执行文件。通常当一个进程使用fork来创建一个子进程时，会在子进程中调用exec函数执行一个新程序，此时子进程的堆栈会被新程序替换。

在上文中提到过每个文件描述符都有一个执行时关闭的close_on_exec标志，如果一个文件对应的那一位被设置，则在执行execve时将被关闭，否则该描述符将默认保持始终打开。

比如说我们在命令行中敲ls，实际上就是由shell进程创建了一个新进程来执行ls程序。

在这个文件中，它将对参数和环境变量进行初始化；根据文件的头部数据结构，对信息进行处理；随后对当前调用进程进行一些处理以方便新的文件运行；随后替换堆栈。

**create_table**

![kernel7](..\..\img\kernel7.png)

这个函数的目的是在新任务的栈中创建参数和环境变量指针，返回这个新的堆栈指针。



```
static unsigned long * create_tables(char * p,int argc,int envc)
// p是数据段中参数的偏移地址,下面程序可以对照着上面的图
{
	unsigned long *argv,*envp;
	unsigned long * sp;

	sp = (unsigned long *) (0xfffffffc & (unsigned long) p);
	sp -= envc+1;  //环境变量起始处
	envp = sp;  //环境变量指针指向此处
	sp -= argc+1;  //参数变量起始处
	argv = sp;  //参数指针指向此处
	put_fs_long((unsigned long)envp,--sp);
	put_fs_long((unsigned long)argv,--sp);
	put_fs_long((unsigned long)argc,--sp);  //将这三个参数分别压入堆栈
	while (argc-->0) {
		put_fs_long((unsigned long) p,argv++);
		while (get_fs_byte(p++)) /* nothing */ ;
	} //排放参数
	put_fs_long(0,argv);
	while (envc-->0) {
		put_fs_long((unsigned long) p,envp++);
		while (get_fs_byte(p++)) /* nothing */ ;
	}// 排放环境变量
	put_fs_long(0,envp);
	return sp; //返回新的堆栈指针（指向argc）
}
```

**copy_string**

从用户空间复制参数和环境字符串进入内核空闲页面中。内核中默认给每个程序提供了128K的参数表，参数字符串是以堆栈操作方式逆向往其中复制存放的

```
static unsigned long copy_strings(int argc,char ** argv,unsigned long *page,
		unsigned long p, int from_kmem) //from_kmem是字符串来源，p一开始会指向参数表最后一个长字处
{
	char *tmp, *pag;
	int len, offset = 0;
	unsigned long old_fs, new_fs;

	if (!p)
		return 0;	/* bullet-proofing */
	new_fs = get_ds();
	old_fs = get_fs();
	if (from_kmem==2)  //说明来源于内核，也就是从内核到内核
		set_fs(new_fs);
	while (argc-- > 0) {
		if (from_kmem == 1)  //注意字符指针是在内核空间，下一步取指针时需要先到内核数据段
			set_fs(new_fs);
		if (!(tmp = (char *)get_fs_long(((unsigned long *)argv)+argc)))  //获得内核数据段中的字符串数组指针
			panic("argc is wrong");
		if (from_kmem == 1)  //返回用户空间
			set_fs(old_fs);
		len=0;		/* remember zero-padding */
		do {
			len++;
		} while (get_fs_byte(tmp++));  //获取一个个参数
		if (p-len < 0) {	/* this shouldn't happen - 128kB */
			set_fs(old_fs);
			return 0;
		}
		//接着逆向把字符串逐个字符地复制到参数和环境空间末端处。
		while (len) {  //进入内核空间了
			--p; --tmp; --len;
			if (--offset < 0) {
				offset = p % PAGE_SIZE;
				if (from_kmem==2)
					set_fs(old_fs);
				if (!(pag = (char *) page[p/PAGE_SIZE]) &&
				    !(pag = (char *) page[p/PAGE_SIZE] =
				      (unsigned long *) get_free_page())) //偏移p对应的页面如果不存在则重新申请页面 
					return 0;
				if (from_kmem==2)
					set_fs(new_fs);

			}
			*(pag + offset) = get_fs_byte(tmp);  //将数据复制到内核页面中
		}
	}
	if (from_kmem==2)
		set_fs(old_fs);
	return p;  //返回复制后的p指针
}
```

**do_execve**

```
int do_execve(unsigned long * eip,long tmp,char * filename,
	char ** argv, char ** envp)
{
	struct m_inode * inode;
	struct buffer_head * bh;
	struct exec ex;
	unsigned long page[MAX_ARG_PAGES];
	int i,argc,envc;
	int e_uid, e_gid;
	int retval;
	int sh_bang = 0;
	unsigned long p=PAGE_SIZE*MAX_ARG_PAGES-4;  //首先指针指向了参数和环境字符串空间最后一个长字处

	if ((0xffff & eip[1]) != 0x000f)  //eip[1]指明了当前段寄存器CS值，它只能是000f
		panic("execve called from supervisor mode");
	for (i=0 ; i<MAX_ARG_PAGES ; i++)	/* clear page-table */
		page[i]=0;   //清空用来存放环境变量和参数的页表
	if (!(inode=namei(filename)))		/* get executables inode */
		return -ENOENT;  //找到对应可执行文件的i节点
	argc = count(argv);
	envc = count(envp);
	
restart_interp:
	if (!S_ISREG(inode->i_mode)) {	/* must be regular file */ //检查是否为常规文件
		retval = -EACCES;
		goto exec_error2;
	}
	i = inode->i_mode;
	e_uid = (i & S_ISUID) ? inode->i_uid : current->euid;
	e_gid = (i & S_ISGID) ? inode->i_gid : current->egid;
	if (current->euid == inode->i_uid)
		i >>= 6;
	else if (current->egid == inode->i_gid)
		i >>= 3;
	if (!(i & 1) &&
	    !((inode->i_mode & 0111) && suser())) {
		retval = -ENOEXEC;
		goto exec_error2;
	}
	//以上在查询可执行文件的文件权限
	if (!(bh = bread(inode->i_dev,inode->i_zone[0]))) {  //读取第一个逻辑块数据
		retval = -EACCES;
		goto exec_error2;
	}  //读取可执行文件的第一块数据
	ex = *((struct exec *) bh->b_data);	/* read exec-header */  //获取头部
	if ((bh->b_data[0] == '#') && (bh->b_data[1] == '!') && (!sh_bang)) { //如果头部是#！开始的说明这是一个shell程序
		/*
		 * This section does the #! interpretation.
		 * Sorta complicated, but hopefully it will work.  -TYT
		 */

		char buf[1023], *cp, *interp, *i_name, *i_arg;
		unsigned long old_fs;

		strncpy(buf, bh->b_data+2, 1022);  //复制了文件第一行也就是从#！开始的数据
		brelse(bh);
		iput(inode);
		buf[1022] = '\0';
		if (cp = strchr(buf, '\n')) {
			*cp = '\0';
			for (cp = buf; (*cp == ' ') || (*cp == '\t'); cp++);
		}
		if (!cp || *cp == '\0') {   //说明没有内容，出错
			retval = -ENOEXEC; /* No interpreter name found */
			goto exec_error1;
		}
		interp = i_name = cp;
		i_arg = 0;
		for ( ; *cp && (*cp != ' ') && (*cp != '\t'); cp++) {
 			if (*cp == '/')
				i_name = cp+1;  //取得了shell程序对应的解释程序名
		}
		if (*cp) {
			*cp++ = '\0';
			i_arg = cp;  //这里说明存在参数
		}   //以上在处理shell脚本文件
		/*
		 * OK, we've parsed out the interpreter name and
		 * (optional) argument.
		 */
		if (sh_bang++ == 0) {  //sh_bang保证了当前执行的这个程序不会被再次执行
			p = copy_strings(envc, envp, page, p, 0);
			p = copy_strings(--argc, argv+1, page, p, 0);
		}  //从用户空间复制环境变量和参数
		/*
		 * Splice in (1) the interpreter's name for argv[0]
		 *           (2) (optional) argument to interpreter
		 *           (3) filename of shell script
		 *
		 * This is done in reverse order, because of how the
		 * user environment and arguments are stored.
		 */
		p = copy_strings(1, &filename, page, p, 1);  //文件名在用户空间但是文件指针在内核
		argc++;
		if (i_arg) {
			p = copy_strings(1, &i_arg, page, p, 2);  //如果有参数
			argc++;
		}
		p = copy_strings(1, &i_name, page, p, 2);  //执行程序信息
		argc++;
		if (!p) {
			retval = -ENOMEM;
			goto exec_error1;
		}  //复制程序文件名和解释程序文件名
		/*
		 * OK, now restart the process with the interpreter's inode.
		 */
		old_fs = get_fs();
		set_fs(get_ds());
		if (!(inode=namei(interp))) { /* get executables inode */
			set_fs(old_fs);
			retval = -ENOENT;
			goto exec_error1;
		}
		set_fs(old_fs);
		goto restart_interp;
	}  //因为获取了解释程序的i节点，所以使用解释文件，然后重新运行
	brelse(bh);
	if (N_MAGIC(ex) != ZMAGIC || ex.a_trsize || ex.a_drsize ||
		ex.a_text+ex.a_data+ex.a_bss>0x3000000 ||
		inode->i_size < ex.a_text+ex.a_data+ex.a_syms+N_TXTOFF(ex)) {
		retval = -ENOEXEC;
		goto exec_error2;
	}
	if (N_TXTOFF(ex) != BLOCK_SIZE) {
		printk("%s: N_TXTOFF != BLOCK_SIZE. See a.out.h.", filename);
		retval = -ENOEXEC;
		goto exec_error2;
	}
	if (!sh_bang) {  //sh_bang没有被设置说明不是运行的脚本文件，则复制对应的参数和环境变量
		p = copy_strings(envc,envp,page,p,0);
		p = copy_strings(argc,argv,page,p,0);
		if (!p) {
			retval = -ENOMEM;
			goto exec_error2;
		}
	}
/* OK, This is the point of no return */
	if (current->executable)  //原程序如果是个可执行程序释放，并且重新指向该i节点
		iput(current->executable);
	current->executable = inode; //指向当前可执行程序的i节点
	for (i=0 ; i<32 ; i++)
		current->sigaction[i].sa_handler = NULL;  //清除信号
	for (i=0 ; i<NR_OPEN ; i++)
		if ((current->close_on_exec>>i)&1)
			sys_close(i);  //关闭对应设置执行时关闭位的文件
	current->close_on_exec = 0;
	free_page_tables(get_base(current->ldt[1]),get_limit(0x0f));  //释放源程序占用的代码段和数据段内存页
	free_page_tables(get_base(current->ldt[2]),get_limit(0x17));
	if (last_task_used_math == current)
		last_task_used_math = NULL;
	current->used_math = 0;
	p += change_ldt(ex.a_text,page)-MAX_ARG_PAGES*PAGE_SIZE; //将对应的参数信息移动到进程逻辑空间的末端，并且修改描述符表中的基质和段限长。
	p = (unsigned long) create_tables((char *)p,argc,envc);  //为该进程建立参数表
	current->brk = ex.a_bss +
		(current->end_data = ex.a_data +
		(current->end_code = ex.a_text));
	current->start_stack = p & 0xfffff000;
	current->euid = e_uid;
	current->egid = e_gid;
	//以上修改老进程中的一些信息
	i = ex.a_text+ex.a_data;
	while (i&0xfff)
		put_fs_byte(0,(char *) (i++));
	eip[0] = ex.a_entry;		/* eip, magic happens :-) */  //代码指针替换为新程序入口
	eip[3] = p;			/* stack pointer */  //堆栈指针替换为新程序堆栈指针
	return 0;
exec_error2:
	iput(inode);
exec_error1:
	for (i=0 ; i<MAX_ARG_PAGES ; i++)
		free_page(page[i]);
	return(retval);
}
```

###### stat.c

这个文件实现了读取文件状态的作用，通过系统给调用stat和fstat来实现，总的来说就是使用文件名或者是文件描述符来查找对应i节点上保存的状态，然后将信息保存到了用户缓冲区，stat是使用了文件名获取，fstat使用了文件描述符。

###### fcntl.c

这个文件实现的是系统调用dup，dup2和fcntl操作。dup和dup2是复制文件描述符函数，而区别在于dup返回当前最小的未用描述符，dup2返回新的描述符。fcntl是对于文件系统的控制函数，通过这个函数对文件系统中的文件进行操作。

**dupfd**

```
static int dupfd(unsigned int fd, unsigned int arg)  //fd是将要被复制的文件描述符， arg是指定的新文件描述符的最小值
{
	if (fd >= NR_OPEN || !current->filp[fd]) 
		return -EBADF;
	if (arg >= NR_OPEN)
		return -EINVAL;
	while (arg < NR_OPEN)  //找一个当前进程文件中没有用过的最小的一项
		if (current->filp[arg])  //如果这一个文件描述符已经被占用
			arg++;
		else
			break;
	if (arg >= NR_OPEN)
		return -EMFILE;
	current->close_on_exec &= ~(1<<arg);  //复位执行时关闭位，这让exec这个文件的时候不会关闭这个文件
	(current->filp[arg] = current->filp[fd])->f_count++;  //将当前找到的文件描述福对应的文件赋值为原描述符对应的文件
	return arg;
}//那么dup函数就是使arg为0找到一个最小的未用的，而dup2将arg改为一个新的fd这样直接将老fd的文件描述符对应的结构赋值给新fd
```

###### ioctl.c

这个文件实现的是对于输入和输出的控制，是系统调用ioctl程序所在之处，是各个具体设备的驱动程序的ioctl函数所在，该函数将调用文件句柄指定设备文件的驱动程序中的 IO 控制函数，主要是其中调用了之前所说的tty_ioctl函数来加以控制。

```
int sys_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
{	
	struct file * filp;
	int dev,mode;

	if (fd >= NR_OPEN || !(filp = current->filp[fd]))
		return -EBADF;
	mode=filp->f_inode->i_mode; //取文件描述符代表的文件的模式
	if (!S_ISCHR(mode) && !S_ISBLK(mode))  //判断当前的文件是否为字符设备和块设备，因为这个是设备的驱动控制程序
		return -EINVAL;
	dev = filp->f_inode->i_zone[0];  //取设备号
	if (MAJOR(dev) >= NRDEVS)
		return -ENODEV;
	if (!ioctl_table[MAJOR(dev)])  //如果没有对应的接口函数返回错误
		return -ENOTTY;
	return ioctl_table[MAJOR(dev)](dev,cmd,arg);  //调用对应的接口函数
}
```

###### select.c

这个文件是解决这样的一个问题，如果一个程序使用多个文件描述符进行读写，则会出现读写阻塞的问题，如果不能很好处理这样的问题，可能会出现一个问题被阻塞，而后面的文件却无法进行读写。那么select函数让内核同时监控了多个文件描述符的状态，如果状态没有发生变化则使它进入睡眠的状态，那么如果某个描述符已经准备好了，那么就返回这个进程的这个描述符。

总的来说，当 select()返回-1 时表示出错；当 select()返回一个 0 值时表示在规定的条件下还没有描述 符准备好；当 select()返回一个正值时，表示描述符集中已经准备好的描述符个数。此时 3 个描述符集中 仍然置位的比特位对应的描述符就是已准备好的描述符。 

这个文件表达的十分复杂。中心的函数是do_select这个函数，它首先检查每个文件描述符的有效性，然后对每个描述符检查，然后统计准备好的文件，如果其中有准备好的就返回，否则进程会被插入对应的等待队列，直到超时或者被唤醒，则会重新判断这个进程是否有准备好的文件描述符。

处理描述符的等待使用了wait_table结构，这个结构有一个数组wait_entry，每一个结构又分为两个字段，wait_address指向当前正在处理任务的等待队列，old_task指向等待队列头指针原来指向的哪个等待任务。我们阔以使用下图来看一下添加到了队列上变成了什么样：

![kernel8](..\..\img\kernel8.png)

![kernel9](..\..\img\kernel9.png)

其实这么一看，select所作的事和sleep_on所作的事相同

```
int sys_select( unsigned long *buffer )
{
/* Perform the select(nd, in, out, ex, tv) system call. */
    int i;
    fd_set res_in, in = 0, *inp;
    fd_set res_out, out = 0, *outp;
    fd_set res_ex, ex = 0, *exp;
    fd_set mask;
    struct timeval *tvp;
    unsigned long timeout;

    mask = ~((~0) << get_fs_long(buffer++));
    inp = (fd_set *) get_fs_long(buffer++);
    outp = (fd_set *) get_fs_long(buffer++);
    exp = (fd_set *) get_fs_long(buffer++);
    tvp = (struct timeval *) get_fs_long(buffer);

    if (inp)
        in = mask & get_fs_long(inp);
    if (outp)
        out = mask & get_fs_long(outp);
    if (exp)
        ex = mask & get_fs_long(exp);
//1.当用户设置的timeout转为jiffies放在全局的current->timeout中
    timeout = 0xffffffff;                        -->timeout设为-1
    if (tvp) {
        timeout = get_fs_long((unsigned long *)&tvp->tv_usec)/(1000000/HZ);   //看清楚这儿是等号
        timeout += get_fs_long((unsigned long *)&tvp->tv_sec) * HZ;           //将用户设置的timeout在这儿转为jiffies
        timeout += jiffies;                                                   //加上当前的jiffies就是超时时的jiffies 
    }
    current->timeout = timeout;                                               //将这个超时值放在全局的current->timeout中
    cli();
//2.在do_select中使用
    i = do_select(in, out, ex, &res_in, &res_out, &res_ex);                   //在do_select中会用到这个current->timeout
    if (current->timeout > jiffies)
        timeout = current->timeout - jiffies;
    else
        timeout = 0;
    sti();
    current->timeout = 0;
    if (i < 0)
        return i;
    if (inp) {
        verify_area(inp, 4);
        put_fs_long(res_in,inp);
    }
    if (outp) {
        verify_area(outp,4);
        put_fs_long(res_out,outp);
    }
    if (exp) {
        verify_area(exp,4);
        put_fs_long(res_ex,exp);
    }
    if (tvp) {
        verify_area(tvp, sizeof(*tvp));
        put_fs_long(timeout/HZ, (unsigned long *) &tvp->tv_sec);
        timeout %= HZ;
        timeout *= (1000000/HZ);
        put_fs_long(timeout, (unsigned long *) &tvp->tv_usec);
    }
    if (!i && (current->signal & ~current->blocked))
        return -EINTR;
    return i;
}
```

```
int do_select(fd_set in, fd_set out, fd_set ex,
    fd_set *inp, fd_set *outp, fd_set *exp)  //inp是读入描述符，outp是写描述符，exp异常描述符
{
    int count;
    select_table wait_table;
    int i;
    fd_set mask;

    mask = in | out | ex;
    for (i = 0 ; i < NR_OPEN ; i++,mask >>= 1) {
        if (!(mask & 1))
            continue;
        if (!current->filp[i])
            return -EBADF;
        if (!current->filp[i]->f_inode)
            return -EBADF;
        if (current->filp[i]->f_inode->i_pipe)
            continue;
        if (S_ISCHR(current->filp[i]->f_inode->i_mode))
            continue;
        if (S_ISFIFO(current->filp[i]->f_inode->i_mode))
            continue;
        return -EBADF;
    }
repeat:
    wait_table.nr = 0;
    *inp = *outp = *exp = 0;
    count = 0;
    mask = 1;
    for (i = 0 ; i < NR_OPEN ; i++, mask += mask) {  //对每个文件进行一个判断
        if (mask & in)  //如果这个文件在读描述符集中
            if (check_in(&wait_table,current->filp[i]->f_inode)) {  //检查读设备是否主备好
                *inp |= mask;  //设置读准备好的标志位
                count++;  //准备好的数量加1
            }
        //下面也是一样
        if (mask & out)
            if (check_out(&wait_table,current->filp[i]->f_inode)) {
                *outp |= mask;
                count++;
            }
        if (mask & ex)
            if (check_ex(&wait_table,current->filp[i]->f_inode)) {
                *exp |= mask;
                count++;
            }
    }
    if (!(current->signal & ~current->blocked) &&  (wait_table.nr || current->timeout) && !count) {  //如果还没有超时，有任务，并且没有收到信号，count == 0说明并没有人准备好，那么此时先去调度别的任务
        current->state = TASK_INTERRUPTIBLE;
        schedule(); 
        free_wait(&wait_table);  //如果被唤醒了，执行一次释放，然后再进行查找
        goto repeat;
    } 
    free_wait(&wait_table); //说明已经有准备好的了，那么就唤醒队列上的任务
    return count;
}
```

