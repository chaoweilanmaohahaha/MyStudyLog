# 在进入内核代码前的一些杂事

### 微机结构

一个传统的微机的结构就如下面所说。CPU通过地址线、数据线和控制信号线组成本地或者说是内部总线，这使得它可以和系统的其他部分进行通信。地址线提供内存或者IO设备寻址，即可以得知读写数据的具体位置。数据线的目的是向内存单元或者是IO设备传输数据。信号线就是起到控制作用。对于80386CPU而言，地址线和数据线都是32位。

我们碰到的外部设备适配器，需要通过总线插槽来和总线连接。所谓总线插槽就是总线和设备控制器的一个标准连接接口，包括所谓的ISA，PCI。现在有很多的适配器的功能已经集成在了计算机主板上的超大集成芯片中了，因此现代的PC主要使用了两个超大集成芯片：南桥芯片和北桥芯片。北桥芯片用于CPU与内存和AGP，南桥芯片用于管理中、低速的组件。

### IO寻址和访问方式

当CPU和IO适配器要进行数据传输时，需要获取所谓的端口地址。IO的访问控制，一般有轮询，中断和DMA三种。通常而言，IO控制器上包含数据端口，命令端口，状态端口，而且端口编址方式也包括统一编址和独立编址。所谓的统一编址就是让IO控制器的端口地址归入存储器寻址空间范围，这样做CPU寻址的方法和内存寻址一样，指令也是一样的。而独立编址是把IO适配器和控制器的寻址空间作为一个独立的地址空间对待，每个端口有一个IO地址与之对应，并且使用专门的访问的指令。IBM PC主要使用独立编址方式，有1024个IO端口地址可供使用，地址范围为0x000 --- 0x3FF。

IO的接口有其自身访问控制，数据传输控制方式一般可采用轮询、中断和DMA三种。轮询的本质是程序自己通过循环来查询IO的状态端口，但是这样极大的消耗了CPU时间。中断方式则是在控制器向CPU提出中断请求的时候才会去响应。DMA方式则直接让外设和系统内存进行批量数据的传输，这个过程则无需CPU插手。

### 主存、BIOS和CMOS

PC机上一般都有这么三种存储设备，其中包括主存用来运行程序以及存放所必须的临时数据，BIOS存放开机诊断和初始化硬件程序，CMOS存放计算机时钟以及系统硬件配置信息。

最初的主存只有640K，CPU使用20条地址线，因此寻址空间为1MB，在当时这个空间大小已经足够使用，但是到现在逐渐有了更大的内存空间，地址线也增加到了32条。为了与原来的PC机在软件上兼容，系统1MB以下物理内存使用和分配仍然和原来保持一致，而原来系统中BIOS一直处于CPU能够寻址的内存最高处，而对于现代的系统，依旧在原来BIOS的位置上在计算机开机时初始化出一个影子BIOS区域，BIOS的内容会被复制到这里。在物理内存0-1M中，640K到1M之间的384K有着保留用途，1M到16M用作主存（对于物理内存16M的来说），0-640K存放内核数据和代码。

在ROM中的BIOS主要用于开机时的执行自检，建立操作系统要使用的一些配置表，并且将处理器和系统其余部分初始化到一个已知状态。**但是要记住的一点是，linux操作系统只有在初始化的时候才使用BIOS，后面将不会再使用了。**那么当我们按下电脑电源时，CPU会自动的把代码段寄存器设置为0xF000，段基地址设置为0xFFFF0000，IP设置为0xFFF0,则代码指针指向了0xFFFFFFF0，也就是最后16个字节处，这里就是BIOS存放的地址，并且指向的这个位置会有一条jmp指令，跳转到BIOS其中的某个位置执行代码。如果BIOS代码长度已经超过了1M，那么BIOS程序会使用32位的寻址方式，将原本兼容的64KB BIOS代码复制到1M顶端的64K处，然后跳转到其中并让CPU真正运行在实模式下。

CMOS存放了它存放了一些和时间硬件有关的配置信息，位置在基本内存空间之外，需要使用另外的IO指令。

### 控制器和控制卡

所谓控制器指的是集成在主板上的控制部件，而控制卡是通过扩展槽插入计算机的控制卡部件。这两个部件均是用来进行传输数据和控制计算机运行的。

###### 中断控制器

在80X86兼容微机中使用两片8259A芯片级联，用来实现IO设备的中断控制，它能够提供15个设备独立的中断控制功能。理论上在内存开始处0x000到0xFFF区域内会建立一个中断向量表，其中从0x08开始的中断向量就映射了这些中断。但是intel公司给CPU预留了从0x00到0x1F这些中断，因此会有所冲突。那么Linux初始化的时候就会对8259A进行重新初始化，把所有中断映射到0x20以后的中断号上。

###### DMA

DMA的主要功能是让外部设备能够直接与内存传输数据增强系统的性能。在PC/AT机上，它会使用两片8237芯片，有8个独立的通道可使用。像软盘控制器就专门在通道2上。

###### 定时计数器

只是通过intel 8253/8254芯片实现的，它用于处理计算机的精确时间延迟。这个芯片有三个独立的16位计数器通道。程序员是可以通过配置8253/8254芯片来实现延时的功能的。

###### 键盘控制器

这本书使用的是PC/AT微机的兼容键盘，上面有一个称为键盘编码器的处理器专门用来扫描收集所有按键松开和按下的信息，然后发送给键盘控制器。键被按下时发送的是接通扫描码，松开时发送的是断开扫描码。那么键盘控制器的目的就是对接收到的扫描码进行解码，然后传递给操作系统。其中键盘控制器在这里还有的一个作用就是需要将发送的扫描码转换成与PC/AT机兼容的扫描码。

###### 串行控制卡

串行通信是指在线路上以比特位数据流一次一个比特进行传输的通信方式。串行通信可分为异步和同 步串行通信两种类型。它们之间的主要区别在于传输时同步的通信单位或帧的长度不同。异步串行通信以 一个字符作为一个通信单位或一帧进行传输，而同步串行通信则以多个字符或字节组成的序列作为一帧数 据进行传输。

对于异步传输通信而言，传输格式包括起始位、数据位、奇偶校验位和停止位。起始位用于同步，恒为0；奇偶校验位可有可无，由程序决定；停止位恒为1。

###### 显示控制

包括了MDA显示标准，仅支持黑白两色，并且支持BIOS显示方式7这一种。CGA显示标准支持7中彩色和图形显示方式，也就是BIOS显示方式0-6。

###### 软盘和硬盘

软盘和硬盘都由各自的盘片和驱动器组成，不同的是硬盘是固定不可拆卸的，而软盘可以随身携带。硬盘容量大并且读写速度较快，称为了系统中所谓的外存。位于磁盘上的磁头分别带有一个读线圈和写线圈。那么一个盘面上是存在这多个磁道的，在读取数据时是需要将磁头移动到某个磁道，而这一圈磁道又包含了多个扇区的信息，那么通过磁头就可以读取扇区上的信息。因此通过柱面号，磁头号和扇区号可以确认唯一的一片扇区。

读写磁盘上的数据需要磁盘控制器。磁盘控制器是 CPU 与驱动器之间 的逻辑接口电路，它从 CPU 接收请求命令，向驱动器发送寻道、读/写和控制信号，并且控制和转换数据 流形式。而软盘控制器一样，也是接收CPU发送的命令然后进行转换等操作。对于磁盘控制器的设置通过IO端口来设置，而软盘的读写需要使用到DMA，硬盘的读写则直接需要块设备进行读写。

---

### 内核编程环境

在linux中使用了两种汇编器，一种是能够产生16位代码的as86，使用ld86进行链接；另一种是GNU的汇编器gas。汇编器是用来将低级汇编语言程序编译为含机器码的二进制文件或者是目标文件，语法通常是：

`as [选项] -o objfile srcfile `

**一条汇编语句通常由标号，指令助记符和操作数构成。**标号代表的是所在位置的地址，汇编器编译产生的目标文件 objfile 通常起码包含三个段或区3（section），即正文段（.text）、数据 段（.data）和未初始化数据段（.bss）。

as86的使用方式：
`as 的使用方法和选项： `

 `as [-03agjuw] [-b [bin]] [-lm [list]] [-n name] [-o objfile] [-s sym] srcfile `

ld86的使用方式：

对于生成 Minix a.out 格式的版本： 

ld [-03Mims[-]]  [-T textaddr] [-llib_extension] [-o outfile] infile... 

对于生成 GNU-Minix 的 a.out 格式的版本： 

ld [-03Mimrs[-]] [-T textaddr] [-llib_extension] [-o outfile] infile... 

上面提到的as86只是用来编译引导程序中的bootsect和setup两个汇编文件。而真正系统中遇到的其他汇编语言统统使用的是gas来编译的。**在编译 C 语言程序时，GNU gcc 编译器会首先输出一个作为中间结果的 as 汇编语言文件，然后 gcc 会调用 as 汇编器把这个临时汇编语言程序编译成目标文件。**这个as汇编器使用AT&T汇编语言，这和intel的汇编语言有很多不同。首先它需要在立即操作数前面加上字符$，在寄存器操作数前加上%。绝对跳转和调用前面加上*；并且它的语法中源操作数和目的操作数次序正好和intel的语法相反。在AT&T语法中指令操作码名称最后一个字符用来指明操作数的长度有b，w，l。

对于内存引用而言，在AT&T语法中是这样表示的：section:disp(base, index, scale)，这个的意思是在section段中的base+scale*index+disp确定的内存地址。

在汇编中，所谓区的概念表示的是一个地址范围，它用来表示使用编译器生成的目标文件中的不同的信息区域。ld链接器会将目标文件中各个部分分配一个不同的地址，然后移动到执行程序运行的地址处。这些固定的块就是区。而这些区在运行时重新分配的地址的操作称为重定向。输出的目标文件至少有三个区，其 text 区从地址０开始，随后是 data 区，再后面是 bss 区。

**如果不定义就使用一个符号，as 就会假设其所有属性均为 0。这指示该符号是一个外部定义的符号。**

as通常只是用来编写32位的代码，因为在linus编写linux的时候，as还不支持16位代码，因此在实模式下的引导程序必须使用as86来编写。

接下去提及有关c语言的一些事情：

老生常谈的是，c语言到可执行程序要经过的过程：预处理阶段（指示符和宏定义的替换）、编译阶段（生成as汇编代码）、汇编阶段（转换为机器代码）、链接阶段（相关目标文件组合链接一起生成可执行文件）。在C语言中可能会接触到一些内嵌的汇编代码，内嵌汇编代码如下：

 asm(“汇编语句”     : 输出寄存器         : 输入寄存器         : 会被修改的寄存器); 

在这里c语言中也是能够直接使用寄存器变量。其中局部寄存器变量需要内嵌的asm汇编语句来指定输入输出专门的寄存器。例如：

 register int res __asm__("ax");   //ax是res希望使用的寄存器

在操作系统中还会出现很多inline定义的内联函数，这个的目的只是在其他函数调用它的时候，直接将函数体集成进去，这样可以更快的进入函数体。

接下来谈一下C语言和汇编语言的调用关系。C语言中单个函数调用时使用的是栈帧结构，它通过帧指针ebp和栈指针esp来指定。esp会根据入栈和出栈发生变化，所以数据的访问使用ebp。那么在调用函数后，会先把对于原函数的返回地址压入栈中，然后把原函数的ebp压入栈中，随后开始就是新函数的内容了。在汇编程序调用一个 C 函数时，程序需要首先按照逆向顺序把函数参数压入栈中，即函数最后（最右 边的）一个参数先入栈，而最左边的第 1 个参数在最后调用指令之前入栈，然后执行call指令。在执行 CALL 指令时，CPU 会把 CALL 指令下一条指令的地址压入栈中。

接下去看一下这里使用的目标文件格式，也就是a.out格式文件。它由一个文件头开始，随后是代码区，数据区，然后是代码和数据重定向信息，接下去是符号表和字符串表。

![aout](..\..\img\aout.png)

最后提一句，在编译内核时最后会生成一个System.map文件，这个文件存放了内核的符号信息，即将链接时生成的链接信息重定型到了这个文件中。

---

### 8086保护模式下的编程

8086提供了一个标志寄存器EFLAGS和几个系统寄存器。EFLAGS中的标志用于控制任务切换、中断、任务追踪和访问权限，而系统寄存器主要用于内存管理和控制处理器操作。系统标志和 IOPL 字段用于控制 I/O 访问、可屏蔽硬件中断、调试、任务切 换以及虚拟-8086 模式。

**TF** 为跟踪标志，当设置该位时可为调试操作启动单步调试，复位则禁止单步调试。
**IOPL**是IO特权字段，指明了当前正在运行的程序或者任务的IO特权级，当前运行程序或者任务的CPL必须小于等于这个等级才能访问IO地址空间，修改这个字段只有在CPL为0的时候进行。

**NT**嵌套任务标志，在中断任务和调用任务之间的链接关系。使用call指令，中断，iret等指令的时候会设置这一位。

**RF**恢复标志，控制处理器对断点指令的响应。

**VM**虚拟8086模式。

在8086下提供了4个内存寄存器：GDTR，LDTR，IDTR，TR。这些是用来指定分段管理系统所有表的基地址。

**GDTR**：全局描述符寄存器，它存放着全局描述符表GDT的32位线性基地址和16位表长。基地址指定 GDT 表中字节 0 在线性地址空间中的地址，表长度指明 GDT 表的字节长度值。在机器刚加电或处理器复位后，基地址被默认地设置为 0，而长度 值被设置成 0xFFFF。在保护模式初始化过程中必须给 GDTR 加载一个新值。 

**IDTR**：中断描述符表寄存器，和IDTR一样，存放着中断描述符表IDT的32位线性基地址和16位表长。其余也和GDT类似

**LDTR**：局部描述符寄存器，存放着局部描述符表LDT的32位线性基地址和16位表长。包含LDT表的段必须在GDT中有一个段描述符项。当进行任务切换时，处理器就把新的任务的LDT加载到LDTR中。

**TR**：任务寄存器，存放当前任务 TSS 段的 16 位段选择符、32 位基地址、16 位段长度和描述符属性值。 它引用 GDT 表中的一个 TSS 类型的描述符。当发生任务切换时，新的任务的TSS段信息也会加载到TR中。

8086下还提供了4个控制寄存器，分别为CR0（控制处理器操作模式和状态的系统控制标志）、CR1、CR2（导致页错误的线性地址）、CR3（页目录物理内存基地址）。

对于CR0而言，只需要知道几个特定的标志位。**PE**是启用保护位，这一位决定了当前运行的是保护模式还是实模式。这个只是开启了段级保护，PG位是分页标志，表示是否开启了分页。**WP**写保护标志，禁止超级用户向用户只读页面执行写操作。

**当改变 PE 和 PG 位时，我们必须小心。只有当执行程序起码有部分代码和数据在线性地址空间和物 理地址空间中具有相同地址时，我们才能改变 PG 位的设置。此时这部分具有相同地址的代码在分页和未 分页世界之间起着桥梁的作用。无论是否开启分页机制，这部分代码都具有相同的地址。另外，在开启分 页（PG=1）之前必须先刷新页高速缓冲 TLB。**？

为了减少地址转换所要求的总线周期数 量，最近访问的页目录和页表会被存放在处理器的页高速缓冲器件中，该缓冲器件被称为转换查找缓冲区 TLB（Translation Lookaside Buffer）。 

接下来看一下8086中的内存寻址：

8086使用了一种叫做段的寻址技术，这种寻址方法把内存空间分成一个或者多个称为段的线性空间，那么寻找内存对象就需要段基址和段偏移。段地址使用16位的段选择符其中的14位选择，那么段内偏移就是使用32位的值来决定。因此程序中使用的由16位段地址和32位偏移构成的48位地址称为虚拟地址或者逻辑地址。8086中就提供了CS，DS，ES，SS，FS，GS六个段寄存器。

分段机制隔绝了多个代码段、数据段和堆栈区域，这样保证多个任务运行在处理器上不会互相干扰。一个系统中所有使用的段都包含在处理器线性地址空间中。段 选择符提供了段描述符表（例如全局描述符表 GDT）中一个数据结构（称为段描述符）的偏移量。段描述符指明段的大小、访问权限和段的特权级、段类型以及段的第 1 个字节在线性 地址空间中的位置（称为段的基地址）。

对于分页机制而言，通常需要使用的线性地址空间都会比物理空间大，那么就会使用虚拟化的线性空间地址。使用分页时，每个段都会被分成一个个页面，而操作系统就需要维护一个页目录和一些页表。实际上，段表存储在线性地址空间，而页表则存在物理地址空间。

**那么程序中的地址转换的过程就是逻辑地址--->线性地址--->物理地址**

从这里可以思考，在8086中会给每个任务不同的逻辑地址，这样就完成了对不同的任务的隔离。所以在8086中每个任务都有自己不同的段表和页表。操作系统会被存储在一片公共的虚拟地址空间中，每一个任务都可以共享，这片区域被称为全局地址空间，而每一个任务又有它自己的虚拟地址空间，称为局部地址空间。

同时每个内存段中都包含了一个特权级，即CPL，这个限制了用户是否有权利访问这个段，而每个特权级拥有不同的堆栈。

###### 段

段由段基址（段在线性地址空间中的开始地址）、段长、段属性构成，这些统统存储在段描述符中，当我们要将虚拟地址转换为线性地址时，首先使用段选择符中的偏移来定位相应的段描述符，然后经过校验后，然后将段描述符中的段基址加上里面的偏移量构成线性地址。

段描述符表是段描述符的一个数组，有全局的和局部的两种。段描述符是存储在仅由操作系统保护的内存区域中，它把虚拟地址空间切分成成了两半，分别分为了GDT和LDT。当发生任务切换时，LDT 会更换成新任务的 LDT，但是 GDT 并不会改变。所以GDT映射的空间是所有任务共有的，**包括含有操作系统的段以及所有任务各自的包含 LDT 的特殊段。LDT 段可以想象成属于操作系统的数据。** 

**段选择符**：就是在虚拟地址前面的16位，其中包括最后两位请求特权级，倒数第三位TI用来区分GDT还是LDT，和索引值。**对应用程序来说段选择符是作为指针变量的一部分而可见，但选择符的值通常是由链接编辑器或链接 加载程序进行设置或修改，而非应用程序。** 

**段描述符**：是在段描述符表中通过段选择符定位的一个结构，目的是提供一个段的位置和大小。每个段描述符有8个字节，里面主要包含了段基址、段限长和段属性，**段描述符通常由编译器、链接器、加 载器或者操作系统来创建，但绝不是应用程序**。S标志区分了是系统段还是用于数据和代码，那么如果S被置为，则需要通过类型字段中的两位区分是数据还是代码，而使用类型字段中的AWE三个字段来区分类型。而如果是没有置为，则同样使用类型字段中的对应位来区分类型。

###### 页

页表存放在物理地址空间中，可以看成是一个2的20次方个数组元素的数组。线性地址到物理地址就是通过到这个数组中进行查找。线性地址的高20位定义了物理地址的基地址，而低12位是偏移。那么在实际使用中为了减少内存的占用量，8086使用了两级页表，高10位是页目录索引，中10位是页表索引。所以物理地址的查找过程就是线通过目录索引加上CR3中给出的页目录表基地址，计算出对应的页表基地址，再根据页表索引计算出对应的物理基地址，再加上页内偏移计算出实际的物理地址。页目录项中会有一个P标志位表明下一级表是否存在，而这一位也可以用来处理虚拟内存技术，即通过缺页异常去磁盘上调对应的页面进入内存。而剩余比如进入位A和修改为D页有助于完成虚拟存储中的细节。

---

### 保护机制

8086提供了分段保护机制和分页保护机制。

对于段级别的保护：

1. 段限长。在段描述符中有一个标志位G限制了段长，我们还知道在段段描述符中也存在了段长的值，如果G位没有置为，则段限长就是段描述符中的长度；如果置位，则需要将段描述符中的段长*4K。
2. 经过段类型检查。
3. 特权级的检查。其中包括了要检查当前程序的特权级，描述符特权级（程序访问某个段时）、请求特权级

对于页级别的保护：

在页目录和页表上存在标志位R/W，U/S区分了超级用户与普通用户对于页面的读写权限问题。

### 中断和异常

中断和异常是指程序运行到某个位置发生一个事件，必须处理器去处理，因而当前运行的程序会转移到中断处理程序中。中断一般是响应某个信号，异常则是执行指令时可能出现了错误。为了便于处理中断和异常，系统给每个中断和异常赋予了一个标识号--向量，而这个向量被用作中断描述符IDT中的索引，定位中断异常程序入口。向量范围是0-255，其中0-31是8086保留的。常见的中断源是硬件产生的中断（8259上的INTR）和软件中断int，异常可被细分为故障，陷阱和中止。对于故障而言，保存的EIP会指向当前出错的指令，而对于陷阱则会保存后一条指令。

中断描述符表IDT是一个项为8个字节的数组。为了构成IDT的索引值，需要将中断号*8计算出对应索引。IDT驻留在线性空间的任意位置，由IDTR中的基地址指明存在的位置。IDT中包含了中断门描述符，陷阱门描述符，任务门描述符。

### 任务管理

任务（Task）是处理器可以分配调度、执行和挂起的一个工作单元。。与过程不过，任务不可重入。任务切换不会把任何信息压入堆 栈中，处理器的状态信息都被保存在内存中称为任务状态段（Task state segment）的数据结构中。 一个任务包含了任务执行空间和任务状态段TSS，一个任务使用指向其 TSS 的段选择符来指定。 当一个任务被加载进处理器中执行时，那么该任务的 段选择符、基地址、段限长以及 TSS 段描述符属性就会被加载进任务寄存器 TR（Task Register）中。TSS中包含了代码段，数据段和堆栈段的信息。

在任务切换期间，当前运行任务的执行环境（称为任务的状态或上下文）会被保存到它的 TSS 中并且暂停该任务的执 行。此后新调度任务的上下文会被加载进处理器中，并且从加载的 EIP 指向的指令处开始执行新任务。 

任务管理中涉及的数据结构有任务状态段TSS，TSS描述符，任务寄存器TR，任务门描述符，标志寄存器EFLAGS中的NT标志。在任务状态段中会保存用来恢复任务执行的处理器状态信息。其中包括了通用寄存器，段寄存器等，同时也包括段选择符，CR3寄存器等静态寄存器。TSS描述福只能存放在GDT中。任务寄存器存放着段选择符。

任务自己有自己的地址空间，TSS 中的 LDT 字段可以用于给出每个任务自己的 LDT，而TSS中的CR3寄存器字段又可以让每个任务有它自己的页表。