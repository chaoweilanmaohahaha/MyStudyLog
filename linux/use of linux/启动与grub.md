# 启动与 grub

## 启动流程

以一台个人计算机为例，当按下电源键后计算机硬件会主动读取 BIOS 或者 UEFI BIOS 来加载硬件信息并做自我测试，然后又主动读取 BIOS 设置的第一个可启动的设备，然后读入引导程序。启动引导程序可以指定使用哪一个内核文件来启动，并且实际加载内核到内存中解压缩与执行。等到内核检测硬件与加载驱动程序完毕后，操作系统就可以在 PC 上运行了。

### BIOS

这是首先要加载的程序，它会去加载 CMOS 中的信息，然后借助其中的值取得各个硬件的配置，取得这些信息后 BIOS 会进行自我检测。大部分系统软件都会被放置在硬盘中，**BIOS 会指定启动的设备**这样可以读取操作系统内核文件。**但是各个操作系统的文件系统格式又不同，所以必须要一个启动引导程序来辅助加载，这就是 boot loader**。

这里值得说明的是，BIOS 读取 MBR 的方法是使用INT13 中断，这样读取的方法和文件系统就无关了。

### Boot Loader

boot loader 的最主要的功能就是识别操作系统的文件格式，因此必须使用自己的 loader 才能加载属于自己的操作系统内核。但是如果安装的是多个系统呢？

理论上在 MBR 和 boot sector 都会安装一份 loader，所以每安装一个系统就会被覆盖一次，boot loader 除了引导功能，还有控制转交功能，**不过 Windows 的 loader 不具有控制权的转交功能**。

### initramfs

读取了内核文件后，就会将其解压缩到内存，然后测试与驱动各个设备。而一般这些内核文件都存放在 /boot 下。**启动的过程中内核必须要挂载根目录的，这样内核才能读取到内核模块的加载驱动程序功能**。但是有个问题，当下的 Linux 发行版很多驱动程序都是以模块形式存在(比如硬盘)，但是在启动时并不认识该驱动，那么怎么挂载目录呢？

Linux 会使用 initramfs 虚拟文件系统来完成这个任务。这个文件的一个特点是它能够通过 loader 来加载到内存中，并且抽象出一个根目录，通过这个虚拟文件系统里面配备了启动时必要的一些模块，这是就可以完成模块的运行。当一切都完成后，最终系统会卸载 initramfs，并实际挂载系统的根目录。

### systemd

内核加载完，驱动也加载完了，systemd 是系统第一个调用的程序，可以作为默认操作环境的项目包括 multi-user.target 和 graphical.target。当然还有其他一些比较特殊的环境。而这些操作环境就对应原版的 System V 中的运行级别 runlevel，这是可以通过 init 命令切换的。

根据查看这两个环境的依赖，可以发现 systemd 的启动流程：

* local-fs.target + swap.target：挂载本机的 /etc/fstab 规范以及内存交换分区
* sysinit.target：检测硬件，加载需要的内核模块，**这个是任何系统都必须的工作**。
* basic.target：加载外围硬件驱动程序与防火墙相关任务
* multi-user.target：加载一般系统或网络服务的加载
* gdm.service 等图形界面相关服务

systemd 有自己的配置文件，而其中还有主要关于模块的一些配置存放在了 /etc/modprobe.d/\*.conf 和 /etc/modules-load.d/\*.conf。这样个文件中主要**包含了加载内核模块的位置和可以加上的模块参数**。

## 内核模块

目前的内核已经不全是把硬件驱动什么的一股脑编译到内核中了，它们都具有可读取模块化驱动程序。如果有一个新的硬件需要加入到系统中，那么除非重新编译内核，加入最新硬件的驱动程序代码；要么就将该硬件的驱动程序编译成为模块，然后加载。

内核模块的放置位置一般都在 /lib/modules/$(uname -r)/kernel 中。模块之家是存在依赖的，但是不见得需要人为去检测吧，所以使用 depmod 命令就可以建立模块之间的依赖性，最终生成 modules.dep 文件。使用 lsmod 命令可以查看模块的信息，包括名称、大小和依赖性。当我们要加载一个模块时，最暴力的方法使用 insmod 方法加载，但是这样会忽略模块间的依赖关系，因此 modprobe 是较好的选择，因为它就是基于 modules.dep 文件做的。如果不想要某个模块了，就是用 rmmod 卸载。

## grub2

grub2 是目前最流行的 loader 之一了，因为它**能够识别的文件系统和磁盘分区格式非常多**。在 Linux 中加载 loader 也需要两步，这是因为 MBR 或者 GPT 都没有他打的空间直接存储 loader 的所有数据。所以第一步要加载 loader 的主程序，这个主程序肯定装在 MBR 中。随后再是通过 boot loader 加载所有配置文件和相关环境参数，这些文件统统放在 /boot/grub2 下。

grub2 的优点除了识别较多的文件系统外，它支持自行修改配置，并且可以在修改完后下一次启动就生效。它最主要的配置文件就是 grub.cfg。**其中对于硬盘有它自己的代号格式，与 /dev/sda1 格式不同**。详细的内容这里不展开，一般是不会修改这个 grub.cfg 文件的，因为该文件内容特别复杂。

那么我们是可以通过修改 /etc/default/grub 和 /etc/grub.d/ 内的相关配置文件来处理。像前者一般包含了倒数时间参数、是否隐藏选项、默认启动选项等信息。当修改完该文件后使用 grub2-mkconfig 重建 grub.cfg 即可。

当然在 /etc/grub.d/* 内也包含了相关的脚本，其中包括了：

* 00_header：建立初始的现实项目，包括一些加载的模块分析等；
* 10_linux：根据 /boot 下的文件，找到正确的 Linux 内核与读取这个内核需要的文件系统的模块和参数
* 30_os-prober：默认会到系统上找到其他分区里面的操作系统
* 40_custom：额外手动添加需求

因此一般而言只需要修改 40_custom 这个文件即可，比如你想在其中添加一个 menu 的选项。当然其中你可以直接指定某个内核，也**可以使用 chainloader**这种移交 loader 的方法。

initramfs 这个文件在上面提到过，它是在启动过程中非常重要的文件，因为它可以为我们添加一些必要的模块。但是如果你有特殊需求，其实也能重置这个文件，比如使用 dracut 和 mkinitrd 命令。

如果 Linux 并非使用 grub2，还可以使用  grub2-install 命令安装 grub2，他会把必要的文件复制到 /boot/grub2 中。那么真正在启动的过程中，如果仔细观察能够发现，在 grub 界面上会有一行提示，告诉你按下 e 可以在线编辑配置，确实打开后其实就是配置 grub.cfg 里面的内容。

最后要提一点，就是 grub 还支持给特定的选项设置用户名和密码，这是对进入系统的选择提供限制。该设置优点像 Linux 本身的账号管理，它包括了 superuser 和 user，其中 superuser 可以修改配置，但是一旦设置所有选项都会有所限制；而 user 只可以选择选项，不能进行配置的修改。

在系统中最好的添加方法是建立一个 01_users 的脚本文件，然后在里面填上用户名和密码。随后在你的 40_custom 中的选项入口处添加对于用户登录的限制。

## 杂项

如果 root 密码忘记了怎么办，通过一个叫做 rd.break 的内核参数来处理。

如果文件系统错误无法启动怎么办，这时同样会让你输入 root 密码获取 bash ，然后挂载根目录，对出错的扇区进行修复。