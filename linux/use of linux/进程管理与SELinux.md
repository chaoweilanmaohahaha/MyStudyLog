# 进程管理

在 Linux 中，触发任意一个事件系统都会将它定义为一个进程，并且赋予这个进程一个 ID，这个 ID 就是 PID。进程和程序到底是什么关系，其实简单的说程序就是一个二进制文件，以物理形式存储在磁盘上；但是进程是指程序被触发之后，执行者的权限等信息都会加载到内存中，所以进程就是一个正在运行的程序。

进程之间是存在父子关系的，父子关系可以通过 PPID 来判断，一般而言如果某个子进程出现了问题，怎么都杀不死，则可以考虑将其相关的父进程杀死。父子进程之间的调用关系在 Linux 中通常是 fork-and-exec 的流程，先通过 fork 方式产生一个一模一样的子进程，随后再使用 exec 执行新的进程。**fork 后的子进程除了 PID 之外其他都与父进程相同，而只有通过 exec 后才真正修改了运行的程序**。

在系统中往往会存在常驻在内存中的进程，我们将这些进程称为**服务**。

Linux 是一个多人多任务环境，允许多个人登录系统，并且由于 CPU 的运行速度，切换任务时非常快。

## 任务管理

任务管理的意思是指**登录到了 bash 后在单一终端下执行的多个任务之间的管理操作**。也就是说每个任务都是 bash 的子进程，任务管理无法从 tty1 的环境去管理 tty2 的 bash。

假设目前只有一个终端，那么**可以出现提示让你操作的环境称为前台**，而其他任务就可以放到后台去暂停或运行，并且放入后台的任务不能够与用户进行交互，并且一旦放入后台后就不能使用 ctrl+c 停止。

如果你想将任务直接放到后台运行，则在执行的命令后加上 &。比如：

```
tar -xzvf aaa.tar.gz &
```

仔细地看，bash 会给这个命令一个**任务号码**。而任务号码往往会跟上这个命令进程的 PID。但是如果只是像上面执行这个命令，它的输出信息还是会显示在前台，因此在**处理该后台命令时还需要考虑输出数据的重定向**。除此，对于前后台的操作还有如下：

* ctrl-z：将目前的任务丢到后台，并处于暂停状态；在任务号码后会有一个 + 号，代表这时最近一个丢到后台的任务。
* jobs：查看后台任务的状态，同样带 + 的任务是最近被放入后台的任务，- 代表最近第二个被放到后台中的任务。
* fg：将后台任务拿到前台来处理，它的目的就是修改最近被放入的是哪一个任务；
* bg：将任务的状态变为运行中；
* kill：删除任务，一般而言常用的是 kill -9 或者 kill -15。后者是默认值代表以正常步骤结束一项任务，而 -9 通常是在强制删除一个不正常的任务(比如强行关闭 vim，会留下 swp 文件)。

上面提到的后台，详细地说应该被称为终端后台，因为**任务管理始终与终端有关**。这样在远程连接到终端的时候，脱机时任务就会中断。**使用 nohup 这个命令可以在脱机或注销后依旧让命令继续执行**。

## 进程管理

最常见的管理就是查看进程的状态，最常用的命令就是 ps，`ps -l` 可以只查看自己的 bash 进程，而 `ps aux` 能够查看系统运行的所有进程。通过查看进程状态可以分辨**僵尸进程**的存在。

僵尸进程产生的原因是在该进程已经执行完毕是但是父进程没有完整将该进程结束掉。如果系统中出现了很多僵尸进程，则需要好好寻找它的父进程优化系统环境。事实上僵尸进程都是已经无法管理的，而应该直接交给 systemd 这个进程来负责，但是这个进程是系统的第一个执行的进程无法杀死。因此又是只好**重启**。

ps 命令是一种静态查看进程的方法，使用 top 命令就可以持续对进程的运行情况进行检测。而 pstree 命令也是一个很好的工具，它能查看进程之间的相关性。

进程之间是可以相互控制的，那么进程之间是怎么管理的呢？他们通过信号去告知进程要做什么。使用 kill 或者 killall 可以给某个进程发送信号。

绝大多数进程都处于休眠，一旦被唤醒后应该先处理哪一个进程呢？这时由优先级决定的，用户可以通过调整进程的优先级来改变进程执行的顺序。对于一个进程而言能够影响顺序的有两个变量 Priority 和 Nice，理论上 Priority 越低优先级越高，但是这个值只能由内核调整，用户无法直接调整，但是用户可以调整 Nice 值来控制优先级，因为：

> PRI(new) = PRI(old) + nice

可以使用 nice 命令给某一个新执行的命令一个新的 nice 值，当然也可以通过 renice 命令调整进程的 nice 值。

下面再列举一些能够查看系统资源信息的命令：

* free：查看内存的使用情况；
* uname：查看系统和内核相关信息；
* uptime：查看系统启动时间与任务负载；
* netstat：追踪网络或者 socket 文件；
* dmesg：分析内核产生的信息；
* vmstat：检测系统资源变化；

* fuser：借由文件找出正在使用该文件的进程；
* lsof：列出被进程所使用的文件名称；
* pidof：找出某个正在执行的进程的 PID；

对于进程而言还有两个比较特殊的内容，就是之前提到的 SUID 权限的生效是由于具有该权限的程序被触发，当触发某个带有 SUID 权限的程序时，会获得一个新的进程和 PID，此时该 PID 产生时通过 SUID 来给 PID 特殊的权限设置。

还有一个特殊的地方就是进程都是存在于内存中，而内存中的数据都是写入到 /proc/ 这个目录中的。

## SELinux

SELinux 全称是 Security Enhanced Linux，也就是被安全强化过的 Linux，**它所解决的问题在于资源误用**，比如误用网络服务往系统的某个文件夹中写入文件。其实 SELinux 是再进程、文件等详细权限配置时依据的一个内核模块。那么为何需要 SELinux？

* DAC：当某个进程要读写文件时，系统依据进程的拥有者和用户组，比对文件的权限。这种读写文件系统的方式叫做自主访问控制，就是依据进程拥有者和文件资源的 rwx 权限来决定有无读写的权限。
* MAC：DAC 有自身的缺点，如果用户对 Linux 系统不熟，则会造成资源误用的问题。MAC 是强制访问控制，它所针对的对象变成了进程而不是用户，SELinux 就是一种 MAC，每个文件资源针对主体进程设置了可使用的权限。

SELinux 这种防护**主要管理的是进程**，针对的是**文件系统**，它会依据某些服务来制定基本的读写安全策略，这些策略还会有详细规则来指定不同的服务是否开放某些资源的读写。目前一共有 targeted、minimum 和 mls 三种主要的策略。SELinux 审计步骤总的来说可以总结成这么三步：

* 主体进程必须要通过 SELinux 策略内规则放行后，可以于目标资源进行安全上下文比对；
* 如果安全上下文比对成功后，才能开始读写目标；
* 最终能否读写目标还是要看文件系统的权限设置；

什么是安全上下文？可以理解为 SELinux 中的权限，它被放置在文件的 inode 中，可以使用 ls -Z 来查看，你可以看到一个有如下内容的上下文标记：

> 身份识别：角色：类型

其中

* 身份识别基本有两种，一种是不受限的用户 unconfined_u，不受 SELinux 管制；system_u 则是系统用户。

* 角色一般也分为两类，object_r 代表的是文件或者目录，system_r 代表进程。

* 类型是最重要的部分，如果选择 targeted 策略，前两者并不重要。所以一个主体进程能不能读取文件资源就和这个部分有关，这个部分对于文件和进程不太相同：

  * 文件资源伤这个叫做 Type
  * 进程上这个叫做 Domain

  那么为什么这个部分是最重要的呢？假设我们已经触发了一个可执行文件变成了主体进程，而对于这个进程的域我们制定了很多规则，比如如果对于这个域而言它能读取规则为 A 的目标文件，则就需要比对是否目标文件存在 A 这个类型。

并不是所有的 Linux 都支持 SELinux，所以面临了它的开启和关闭，SELinux 一共有三种运行模式：

* Enforcing：强制模式，代表 SELinux 运行中并且已经正确开始限制 domain 和 type
* Permissive：宽容模式，代表了 SELinux 在运行但是不会实际限制 domain 和 type
* Disabled：关闭模式

可以用 getenforce 命令来查看 SELinux 目前的状态。而对于 SELinux 而言在系统正在运行时只能实现强制模式和宽容模式的互换，如果想通过修改配置文件 /etc/selinux/config 来调整模式，则需要重新启动。而使用 setenforce  就可以切换前两者。

### 规则管理

首先看一下 targeted 策略中有多少影响进程的规则，使用 getsebool 能够完成查询。当然使用 seinfo 和 sesearch 方法能够更细致的读取文件的 SELinux 类型。当然使用 setsebool 可以修改某条规则的关闭和开启状态。

### 上下文修改

可以使用 chcon 手动修改文件的 SELinux 类型，当然最常用的是直接使用 restorecon 让文件恢复正确的 SELinux 类型，当然能够使用 restorecon 的前提就是系统中已经配备了一套默认的上下文规则了，如果需要修改默认的上下文规则就需要用到  semanage 命令。

