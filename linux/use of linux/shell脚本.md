# shell 脚本

shell 脚本类似一个程序，但是它都是利用了 shell 功能所完成的。这个程序是一个纯文本文件，就是将一些 shell 的语法和命令，以及正则表达式、管道命令以及数据流重定向的功能，并且相关工具还对它有 debug 的效果。

为什么要学 shell 脚本呢？它可以用来对系统进行自动化分析，它也可以用来跟踪或者管理系统的工作(服务)；如果做更高级一点的事，它还可以进行简单的入侵检测功能。对于普通使用的用户，shell 脚本只是批量地执行命令，做一些简单地数据处理。并且 shell 脚本在类 Unix 系统上有兼容性。可是要注意的是，**shell 脚本在大量数值运算上速度很慢，所以不适合用它来处理大量运算。**

## 执行

执行 shell 脚本时，依旧遵守从左到右，从上到下分析并执行，空白行会被忽略，而当读到 Enter 键时会尝试执行该行的命令，除非使用了 \\Enter 进行转义。

想要执行一个 shell 脚本，一个 shell 脚本如果需要直接执行，必须拥有 rx 两个权限(因为要通过解释器读)。你可以使用绝对路径或者相对路径，或者使用 PATH 路径去找到该脚本。也可以使用 bash 程序间接运行该程序，而此时就只需要有 r 权限就行了。

在编写脚本的过程中，只需要注意几个问题：

1. 第一行会注明所使用的 shell 名称。比如 `#!/bin/bash`，这样就能够加载 shell 的相关配置
2. 一般在编写的时候都需要包含一些脚本的信息，比如功能、版本、作者、日期、历史记录。
3. 最好在编写真正的程序之前先设置好环境变量
4. 在程序结束时能够最好使用 exit 命令退出，相当于返回给系统一个值，这个值就和 $? 获得返回值

### 执行差异

真正要执行一个 shell 脚本其实方法有很多，上面有提到过使用直接执行或者间接执行的方法，这样执行脚本**都会使用一个新的 bash 环境来执行脚本内的命令**。更详细地说，在一个子进程中执行，这样其中定义和使用的临时变量都不能在父进程中使用。

但是还有一种执行 shell 脚本的方法，那就是 source 命令。source 命令会在父进程中执行脚本，这也就是为什么我们每次都用 source 来执行类似 ~/.bashrc 这种配置脚本。

## 编写

### 判断式

如何简单地证明目标是否存在，比如一个文件，一个目录是否存在，最官方的是使用判断式，比如使用 test 命令，test 命令的功能就是为了检测某个文件或者权限是否存在，是一个很好用的功能。

但是除了 test 命令，[ ] 也被经常使用。不过这个符号用的时候限制非常多，比如如下：

```
[ "a" == "b" ]
```

可以发现，基本每个符号之间都需要使用空格分隔，并且两边的变量等最好都用双引号引起来，防止发生解释错误。

### 变量

这里指的是 shell 脚本中可能用到的变量，怎么说呢？在每一次需要和外部交互的地方，当然可以使用 read 命令读入，但是如果要尽可能的自动化，就希望能在外部把值预先传入。

```
./aaa.sh A B C ...
```

常常能够看在调用脚本的时候是如上所示的。其实对于一个脚本而言，每一段你输入的都是变量，比如这里的 ./aaa.sh, A, B 等等。那么：

* 每一个变量一次用 $0,$1 ... 编号，比如 `$0 = ./aaa.sh` , `$1 = A` 依次类推。
* $# 代表变量的个数
* $@ 代表 ["$1", "$2" ...] 

### 条件判断

下面都是一些比较简单的语法了，在编写程序中，多数是有分支的，类比一下脚本也需要。条件判断在脚本中的表现如下：

```
# 单层条件
if []; then
	...
fi

# 双层条件
if []; then
	...
else
	...
fi

# 多层条件
if []; then
	...
elif []; then
	...
...
else
	...
fi
```

其实一般有以上的写法就能应付分支的情况了，但是实际上在早期很多系统的服务启动脚本用的是另一种分支结构，有点类似 switch：

```
case $var in
 "var1")
 	...
 	;;
 "var2")
 	...
 	;;
 ...
esac
```

### 函数

重复可以利用的执行部分当然可以浓缩成一个函数，这样只需要调用该 function 就可以了：

```
function func () {
	...
}
```

要注意的是由于 shell 脚本的执行方式是自上而下，所以 **function 必须要放在程序的最前面**。对于每一个 function，它们也是包含内置变量的，即 $0,$1 等，因此调用某个函数的方式和执行脚本一模一样：

```
function printitem () {
	echo $1
}

printitem AAA
```

### 循环

循环结构的目的就是执行很多轮相同的功能，如果硬是要对循环结构有个分类，那么可以分成定循环和不定循环，其中：

```
# 不定循环
while []
do
	...
done

until []
do
	...
done
```

不定循环有两种，while 和 until 所表示的恰好是相反的两种循环，while 表示直到判断条件不成立才停止，而 until 正好与 while 相反。

相比于不定循环，固定循环能够限制到底会进行多少次循环：

```
for var in con1 con2 con3 ...
do
	...
done
```

那么一般还可以配合 seq 命令产生一些数字序列来配合循环，当然使用另一种数值计算的写法也是可以的：

```
for (( 初值；限制； 赋值))
do
	...
done
```

这个就和 c 程序中的循环非常类似了。

## 跟踪和调试

最后介绍以下对 shell 脚本一下的简单调试。使用 sh 执行脚本，有如下选项可以调试执行：

* -n：不执行脚本，仅查询语法问题；
* -x：将使用的脚本内容显示在屏幕上，这是很有用的参数；