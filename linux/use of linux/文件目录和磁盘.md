# 文件目录和磁盘

## 用户和用户组

为什么需要用户和用户组？因为 Linux 是一个多人多任务地系统，可能会有很多人同时使用某台主机进行工作，添加用户和用户组就是为了考虑每个人的隐私以及工作环境。所以用户组最有用的功能就是**和团队进行协同工作的时候**。

Linux 有着用户、用户组和其他人三层级别，这三层级别由左到右逐渐宽松。其中 root 用户例外，它是系统中最万能的。

系统上的账号和用户信息存放在 /etc/passwd 文件内，密码存放在 /etc/shadow 文件内，系统中的组名存放在 /etc/group 内。

## 文件权限和属性

文件权限和属性是 linux 中的一个很重要的内容，通过查看 list 命令，能够完整的查看一条文件的属性。如果简单的使用 `ls -al` 命令来查看，则一般的输出格式是：

```
[权限] [链接] [拥有者] [用户组] [文件大小] [修改日期] [文件名]
```

其中：

* 权限包含了 10 个字符，第一个字符代表这是一个目录、文件还是链接文件，其余 9 个字符每三个字符分别代表拥有者、群组和其他人的权限。
* 链接记录了有多少不同的文件名链接到了同一个 inode 号码。

文件权限有什么用？保护系统、共享数据。其中对于权限的后九个字符代表的意义，文件和目录是不同的。对于一个文件而言，r 代表的是对文件的读取权限；w 代表编辑、新增和修改权限；x 代表文件能否被执行。所以在 linux 下的一个文件能否被执行是被权限控制，而不是文件名。对于目录而言，r 代表能否列出目录结构的权限；w 代表对目录结果进行写入或者改动，包括新建、删除、改名、移动的权限；x 代表能否进入目录的权限。所以 x 对于目录也非常重要，即使对于目录拥有 r 和 w，没有目录的 x 也无法执行目录下的命令。

### 默认，隐藏和特殊权限

文件的默认权限是由 umask 指定的，它规定了当前的用户建立文件或者目录时的权限默认值。而且它的**值实际时要在最大权限上减去的权限**。

在 ext2、ext3 和 ext4 文件系统上，还存在着隐藏属性，这对文件的安全性上又提供了更多保障。使用 `chattr` 可以对其进行配置，使用 `lsattr` 用来显示隐藏属性。

使用 umask 查看的时候可能会发现，对于文件权限的说明，为什么有 4 位数字，而其实只用到了 3 位，剩下的 1 位代表的是特殊权限，其中包括：

* set UID：仅对二进制有用，且二进制文件有 x 权限。本权限只在执行过程中有效，执行者会获得拥有者的权限。
* set GID：同样对二进制程序有用，是的执行者获得用户组的支持。但是也能用在目录上，获得有效用户组会变为该目录用户组。
* 粘滞位：这个只对目录有效，代表用户在该目录下建立文件或者目录仅有自己或者 root 有权力删除。

### 路径

绝对路径就是从根目录出发的，相对路径是相对于当前的工作目录的。相对路径的作用就是在软件开发时避免了处理文件位置的麻烦。而绝对路径保证了正确性，一般用在 shell 脚本中。

需要知道的是一个关于执行文件路径的变量 `$PATH`，这个路径解释了为什么像 `ls` 命令可以随处使用，因为系统会去 `$PATH` 查找待执行的命令，一旦出现同名则先查到先执行，顺序由 `$PATH` 目录的输出顺序决定的。

### 命令：

* chgrp：修改文件所属用户组(用户组已存在)
* chown：修改文件拥有者(用户已存在)
* chmod：修改文件的权限
* pwd：显示当前工作目录，这通常为了防止搞错目录
* mkdir：-p 选项可以递归新建目录
* ls：能查很多，包括隐藏文件、inode 号码、atime、ctime、mtime
  * atime：代表文件内容数据修改的时间
  * ctime：代表文件状态发生变化的时间
  * mtime：代表文件内容被读取的时间
* cp：这个命令要注意一点，就是**默认情况下，cp的源文件和目标文件权限会发生变化，目标文件的拥有者将变为操作者**。同时 cp 还可以创建链接文件。所以使用 cp 想好源文件的属性问题。
* basename 和 dirname
* od：查看非纯文本的命令。
* touch：更新文件修改时间和创建新文件，所以 mtime 是最重要的，因为 ctime 几乎没法修改。
* file：查看文件基本信息
* which：查找执行文件，根据 `$PATH` 规定的路径查找
* whereis：从特定目录下查找文件， -l 选项可以查看特定的目录
* locate/updatedb：从建立的数据库查找文件，其中 /var/lib/mlocate 就是已建立的数据库， updatedb 就是根据 /etc/updatedb.conf 去更新数据库文件。
* find：查找或者可以执行额外操作，不到万不得已才使用 find 命令查找文件

## 文件种类

主要就是分为常规文件、目录、链接文件、设备文件、数据接口文件、数据传输文件。那么 Linux 上有所谓的扩展名吗?有，但是 linux 上的扩展名也只是帮助用户了解文件的用途，并不能完全代表文件的属性。

## FHS

由于存在着不同的发行版，所以如果每一个发行版都有自己的目录设置方案，则对软件的开发造成比较大的困难，因为很多软件在安装时还是有比较固定的路径选择。所以对于每一个软件开发商和系统制作者都维护了一个 FHS，也就是文件系统继承标准。这份标准也使得基本上所有安装的 linux 发行版系统的目录结构几乎是一致的。

---

## 磁盘和文件

为什么磁盘分区后需要进行格式化？因为对于每一种操作系统，文件设置的属性和权限都不完全相同，格式化的目的就是为了**让分区能够称为操作系统可以使用的文件系统格式**。传统而言一个分区只能格式化为一个文件系统，但是实际上像 LVM 和磁盘阵列**可以将一个分区格式化为多个文件系统，也可以将多个分区合成一个文件系统**。

要清楚一点，属性和数据是放在文件系统的不同的地方的，数据放在数据块中，属性和权限放在 inode 中。像 Linux 使用的一般是索引式文件系统，相比于 FAT 这种没有 inode 的文件系统，索引式不会有太多的碎片。

### ext2

ext2 就是使用了 inode 构建起的文件系统，但是这个文件系统会在一开始就将 inode 和数据块规划好，除非格式化。它在格式化时理论上会分为多个区块群组，而在这些群组最前面是启动扇区，存放启动引导程序。每个区块群组中包含了：

* 数据区块，每个区块只能防止一个文件的数据
* inode 表，文件系统中能建立的文件和 inode 数量有关
* 超级块，理论上只有一份超级块，其他都是备份
* 文件系统描述说明
* 区块对照表
* inode 对照表

你可以使用 dumpe2fs 来查看超级区块的信息。对于文件而言，数据区块会用来存储文件内容，对于目录文件系统会至少分配一个 inode 和至少一个区块存储目录信息，数据中存储的就是目录下的文件名和文件占用的 inode 号。

### ext3/ext4

ext2 的问题在于如果系统数据出现不一致，修复起来全靠超级块中的信息，但是这样是很复杂和费时的。ext3 和 ext4 属于日志式文件系统，它会在修改文件内容前现在日志记录区块记录某个文件准备写入的信息，随后再更新数据和 metadata。

### XFS

centos 使用的最新的文件系统时 xfs， 它其实也是一个日志式文件系统，它被开发来用于高容量磁盘以及高性能文件系统之用。它其实一共分为数据区、活动登录区和实时运行区。

### VFS

但是其实一个操作系统中是可以看到同时出现多个文件系统的，那么内核如何去识别各个文件系统的呢？Linux 使用的式 VFS 的功能去读取文件系统的。

那么到这里要看到，只有文件系统真正链接到目录树上才能被使用，而文件系统和目录树的结合操作就称为挂载。

### 操作

对于文件系统的一些操作，无非总结为下面这些：

* df： 能够列出整体磁盘的使用量
* du：查看文件系统的磁盘使用量
* ln：Linux 下有两种链接，硬链接共享同一个 inode，软链接属于新的文件，是一个独立的文件。而硬链接收到本身的属性的限制，它不能跨文件系统并且不能链接目录。

### 磁盘操作

如果我们希望往系统中新增一块磁盘，正确的步骤是怎样的?

* 建立可用磁盘分区
* 对硬盘分区进行格式化，建立系统可用的文件系统
* 文件系统的校验
* 在系统上建立挂载点，然后将其挂载上来

使用 lsblk 命令，你能列出所有存储设备，随后可以使用分区工具，MBR 使用 fdisk，GPT 使用 gdisk。格式化文件系统使用 mkfs 命令集，对于不同的文件系统的格式化，该命令都有不同的调用方式，比如 mkfs.xfs 适用于 xfs 文件系统。

最后需要将文件系统挂载到系统中，注意单一文件系统不应该被重复挂载在不同的挂载点，单一的目录也不应该挂载多个文件系统，挂载点应该是空目录才行。Linux 上的挂载使用的是 mount 命令，它可以用来挂载文件系统、CD/DVD 或者 USB 甚至是目录。mount 命令完成的是手动挂载，但是比如在你开机之后，你希望每次某个硬盘都能被挂载，这时就需要修改 /etc/fstab 文件进行启动挂载(挂载完后最好测试一下正确性，以免无法启动)。

其实可以直接使用文件作为磁盘的方式进行挂载，比如挂载镜像文件，这种称为特殊设备 loop 挂载。

最后假设电脑中内存不够，理论上需要设置交换分区兑换内存空间(实际在电脑休眠的时候运行的程序状态可能会被放入交换分区中)，建立这样的交换空间可以有两种方法：

* 设置内存交换分区，这个是要在磁盘上单独分区，使用 mkswap 命令就可以完成格式化
* 当然选择使用一个 loop 设备也可以建立一个内存交换文件

## 压缩和备份

压缩技术是什么？再整个磁盘存储的数据中，有很多其实都是无用的，比如一个数字 1 需要 8 位来存储，所以压缩的目的就是将这些无用的空间扣除，只保留那些有用的数据。像内核这种多是 ASCII 的文件就会产生很多的无用空间。

可以看到 Linux 上被压缩的文件会有多种多样的后缀名，但是上文也说过在 Linux 中其实后缀名是无用的，那么这里的后缀名的作用是帮助用户知道这个压缩包是由什么程序制作出来的，因为不同压缩程序解压有不同的命令。

### 压缩

* gizp：后缀名是 .gz，默认状态下被其压缩后文件源文件就不存在了。可以使用 zcat/zmore/zless 来查看压缩后的文件内容。
* bzip2：后缀名是 bz2，比 gzip 有更好的压缩比，但是大容量文件 bzip2 压缩时间较久。可以使用 bzcat/bzmore/bzless 来查看压缩后的文件内容。
* xz：后缀名是 xz，有更高的压缩比，但是压缩所花费的时间更长。可以使用 xzcat/xzmore/xzless 来查看压缩后的文件内容。

### 打包

Linux 上的压缩命令都是对于单个文件来压缩，如果选择对目录压缩就会变成对目录下各个文件进行压缩。为了实现打包一个目录，Linux 提供了一个 tar 命令，该命令相当于将多个文件打包形成一个大文件。现在的 Linux tar 总自己也会带有压缩的选项。

打包命令要注意的两个问题就是**权限**和**路径**，权限保证了你在解压之后是否还需要保留原本的程序的权限和属性，这个 cp 命令一致；路径问题在于，**在使用 tar 命令打包时要注意是否将根目录打包到了路径中去，因为在解压的过程中生成的目录是原封不动的，如果将根目录打包到路径中则就是绝对路径，可能会出现文件覆盖问题。**

tar 命令有很多功能，包括解压单个文件，打包目录，增量备份等

### 备份

tar 的功能笼统的说是对于目录树进行打包，而真正对文件系统进行备份的话，像 XFS 文件系统就有 xfsdump 和 xfsrestore 命令。xfsdump 命令是可以实现完全备份、增量备份以及查看备份内容的功能的。注意的是**它只能备份已经挂载的文件系统，并且它是通过文件系统的 UUID 来辨别各备份文件**。

那么相对来说，还有一种情况就是需要制作镜像文件，这个需要利用 mkisofs 命令，在使用这个命令的时候只有一个注意点就是**默认情况下， 它会把所有备份文件放到镜像中的根目录下，这样你在使用这个镜像的时候会让原先的目录结构乱套。**正确的做法是要使用 -graft-point 来指定目录。所以如果是自己要制作数据内容，最最简单的做是将所有的数据预先处理到某一个目录下。如果需要将这个镜像刻录到光盘中，则可以使用 cdrecord 来进行刻录。流程应该是：1、检测你的刻录机所在的位置；2、进行 CD 的刻录；

最后是对所有文件的一个备份。在 Linux 中有一个很好用的命令 dd，它最大的功能就是用来备份，也可以使用它来制作大的文件。dd 命令的操作是读取磁盘内容即一个个扇区的读写，所以**备份出来的文件非常大并且保留了原本文件系统的样子**(你甚至可以直接将备份的文件放到一个为格式化的分区中)！

cpio 命令是 Linux 中备份的一个利器，该命令可以备份任何的文件，但是 cpio 命令需要你告诉它具体文件的路径到底是什么，并且它不会理会你给的是绝对路径还是相对路径。一般该命令和 find 命令配合进行查找。