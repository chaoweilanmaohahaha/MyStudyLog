# 软件的安装

一般而言在 Linux 中要安装某个程序，一共能够想到两个方法，一个是从官网下载源码资源，然后通过软件的源码来安装；另一种是通过 rpm 或者 yum 等，使用已有的资源来安装程序。

## 源码安装

源码安装程序是最原始的，不过试想一下，比如说在 Windows 操作系统上面的软件在安装时无法修改软件的源代码，所以如果你需要增加或者减少软件功能时就必须和软件厂商沟通，这对于弥补软件漏洞是不利的。**但是 Linux 上的软件几乎都是经过 GPL 授权，所以每个软件几乎都提供了源代码，这样用户就能够自行修改代码**。

那么之前说过在 Linux 上一个文件能不能被执行是看某个文件是否有 x 权限，可是实际上如果你真的要运行某个程序，该程序必须是**二进制程序**。shell 脚本虽然也能被执行，但是实际上它是可以被脚本解释器解释，运行里面的二进制程序命令而已。这个本质是不同的。如果你想知道一个文件是否是二进制程序还是别的，直接使用 file 命令即可。

那么假设通过源码安装，一般的步骤是什么样的呢？程序代码一般是纯文本文件，那么需要**编译器**生成二进制程序。编译的过程中会产生所谓的**目标文件**，如果该程序还要调用外部的一些子程序，则还可能需要将该程序和**函数库**进行一个链接。

使用源码安装最多的是使用 configure 和 make 工具来安装，configure 的作用是检测用户的操作环境，以及该操作环境是否有软件开发商所需要的其他功能，检测完才会生成 makefile 文件。正是有了 makefile 文件，才能继续使用 make 来安装程序。一般而言 configure 检测的环境内容有以下这些：

* 编译器是否合适
* 是否已经存在本软件所需要的函数库
* 操作系统平台是否适合本软件
* 内核的头文件是否存在

一般而言，从网上下载的源码安装包都是所谓的 tarball，也就是将许多配置文件和源文件打包起来。究其原因还是因为下载的带宽问题，所以一般下载的都是 *.tar.gz 结尾的。那么怎么安装呢？那么只需要解压缩 tar 包，随后使用 gcc 编译源文件并且进行链接生成二进制执行文件，随后安装到主机上。其实比起安装，更值得注意的是怎么更新相应的软件，如果你觉得旧软件需要新的功能了、它存在安全缺陷了、执行的性能已经不佳了，那么你可以通过修改源码直接编译来升级，这个在源码级别其实也不复杂！

### make

其实使用 gcc 等编译工具已经满足需求了，但是为什么要使用 make。其实真正软件存在很多需要编译的源程序文件，make 能够主动判断每个目标文件相关的源代码文件。所以使用 make 一般有以下优点：

* 简化编译时所需要执行的命令；
* 如果修改某个源代码文件，则再使用 make 将只针对修改后的文件；
* 可以依赖性来更新执行文件；

使用 make 一定需要配合 makefile 文件，而一个 makefile 文件其实就是一个以下列格式存在的规则文件：

```
目标: 目标文件1 目标文件2
	gcc -o 最终目标文件 目标文件1 目标文件2
```

### 管理

整理一下使用源代码管理软件所需要的一些基础软件，你必须有类似 gcc 一样的语言编译器，同时还需要 make 以及 autoconfig 等软件，同时还需要内核提供的库以及头文件。

有了以上的配套程序，一般安装程序的过程如下：

* 在某个目录下解压缩
* 查看文件中 INSTALL 或者 README 相关文件内容
* 安装依赖的属性软件
* 使用类似 configure 检测操作环境，并建立 makefile 文件
* 使用 make 程序编译
* 使用 install 这个目标来安装这个程序

那么一般的命令序列：

```
./configure
make clean
make
make install
```

这里要注意的是这些命令都是按照顺序执行的，所以只要其中有一个项没有执行成功，后续的步骤将无法完成。那么对于安装还有一些事项，那就是一般的解压路径。

一般 Linux 发行版发布安装的软件大多是在 /usr 里面，而用户自行安装的软件则都在 /usr/local 中。所以对于 tarball 而言建议是将它解压在 /usr/local/src 中，那么配置文件就默认都安装在了 /usr/local/ 下，不过这样有一点不好管理的就是如果要删除某个软件，就可能需要去寻找相应的文件，这样就很麻烦。那么还有一种方法就是单独开辟一个文件夹，将软件相关的文件都安装在那个文件夹中，不过这样做就需要使用绝对路径执行程序。

如果需要更新或者升级某个程序，需要再下载新的 tar 包吗？不一定，使用 patch 和 diff 等程序就可以更新源代码文件。

### 函数库

函数库一共有静态链接和动态链接两种引用方式。对于动态函数库而言，我们最好将常用的动态函数库先加载到内存中，这样可以提升读取速度。那么如果需要将函数库加载道告诉缓存中，则只需要将函数库目录放到 /etc/ld.so.conf 文件中，随后使用 ldconfig 命令将数据读入内存。

那么假设想要看某个二进制文件依赖哪些动态函数库，此时可以使用 ldd 命令查看。

### 校验

为了防止下载下来的 tarball 已经被篡改过了，通常需要使用校验工具，最常用的方法就是使用摘要算法，比如 md5、SHA1 等。

当然这些工具除了帮助我们校验下载下来的 tarball 的完整性，同时如果你想要核对系统中默写文件有没有被篡改，则也可以使用摘要算法定期计算一些文件的摘要值。

## 软件安装器

上面介绍的使用 tarball 安装的方法，在每次安装软件的过程中都需要检测操作系统的环境，设置一些编译参数，最后还需要按照个人喜好来安装软件到特定位置。但是假设软件的出厂商和用户使用的系统一模一样，那么它在当时编译好的软件就能直接使用到用户的系统上。因此另一种软件的安装方式就是**厂商先在他们的系统上编译好用户所需要的软件，随后将这个编译好的可执行软件直接发布给用户。**那么像这样的比较常见的软件管理器包括 RPM 和 dpkg。

那么对于这样的软件安装器，开发商会在固定的硬件平台和操作系统平台上将软件安装、升级和编译好，然后将这个软件的所有相关文件打包成为一个特殊格式的文件。当客户端获得了这个文件时就可以通过特殊的命令来安装，那么该文件就会按照内部的脚本来检测依赖的辅助软件是否存在，如果安装的环境符合了需求，那么就可以安装。安装完成后还会将该软件的信息写道软件管理机制中，以便未来的升级和删除操作。目前能够完成上述过程的主流软件管理器主要有：

* dpkg：由 Debian 开发，许多 Debian 的衍生系统例如 Ubuntu 使用这种机制
* rpm：由 Red Hat 开发，那么像 Fedora、CentOS 等沿用了这个机制。

但是无论是哪种软件管理器，都无法避免在安装软件的时候处理依赖性问题。后来开发商提供了**在线升级**，这个功能也解决了软件依赖带来的难处。

### RPM 与 SRPM

RPM 是以一种数据库记录的方式来将你所需要的软件安装到你的 Linux 系统的一套软件管理机制，它会将要安装的软件先编译过，然后打包成 RPM 机制的文件。**所有软件的信息都已经记录在 Linux 主机的数据库上，所以会很方便查询、升级和反安装**。但是 rpm 包是已经被编译好的软件，并无法修改，所以兼容性很差，并且反安装比较困难。那么 SRPM 就是提供了软件的内容，也就是源代码。它需要先将该软件以 RPM 管理方式编译，生成 rpm 文件；随后将编译后的 RPM 安装到 Linux 系统中。

rpm 的命名是很有规律的：

> AAA-3.11-5-el7.x86_64.rpm

以 - 作为分隔符，一共有：

* 软件名称
* 版本信息
* 发布版本次数
* 操作硬件平台

最后提及 rpm 的优点：

* RPM 内包含已经编译过的程序与配置文件等数据，用户不需重新编译
* RPM 在被安装之前，会先检查系统硬盘容量等信息，避免文件错误安装
* RPM 本身有软件自身信息
* RPM 管理的方式是使用数据库记录相关的参数，便于升级、删除、查询和验证

### YUM

软件安装中最麻烦的一个环节其实是处理依赖问题，因为软件之间存在着互相调用的问题，这时因为软件发布时一般还会发布开发版供开发者调用。这样在安装某些软件之前就必须先要检查其他软件是否已经安装了。像 centOS 使用了 yum 作为属性依赖的解决方案，它对软件之间的依赖关系用一份清单记录了下来：

* 它会先将发布的软件放置到 YUM 服务器内
* 分析这些软件的依赖关系并记录下来生成依赖性列表，然后将软件存储在**源或者软件仓库**中

当客户端有升级或者安装需求时，yum 会向源要求更新软件列表，更新到本地的 /var/cache/yum 中，然后将其与本机的 RPM 数据库进行比较，这样就能确定从 yum 软件源服务器中下载什么软件。

### 使用 rpm

使用 rpm 安装软件同样会检查环境，当合格后就把软件相关信息写到 /var/lib/rpm 下的数据库中。一般有了一个现成的 rpm 包，使用 `rpm -ivh` 命令可以安装一个 rpm 包，当然还有很多附加选项可以辅助安装过程。使用 `rpm -U/Fvh` 完成对 rpm 包的更新工作。使用 `rpm -q` 后面再加一些再添加一些辅助选项可以查询 rpm 包的信息。

使用 `rpm -V` 命令可以使用 /var/lib/rpm 下的数据库内容来比对当前 Linux 系统的环境下的所有安装文件，也就是当不小心丢失、误删或者修改了某个文件内容，这个命令就可以用来验证。当然在 rpm 包中也包含了使用**数字签名**来验证软件来源的方法。

最后就是 rpm 包的反安装，使用 -e 选项就可以进行软件卸载，但是要注意的是卸载的过程**一定是由上层往下层解除**。

### 使用  yum

使用 yum 能够查找 Linux 发行版所提供的软件名称，并且能够查询软件的相应功能，只需要使用 `yum [list|info|search|provides|whatprovides]` ; 使用 `yum [install|update]` 可以安装或者升级软件；使用 `yum remove` 可以帮助删除软件。

如果要用 yum 安装一个大型软件呢？yum 本身还提供软件群组功能，可以使用 `yum grouplist` 来列出所有可使用的软件群，随后使用 `groupinstall` 和 `groupremove` 进行群组安装和群组移除。

yum 有它自己的配置文件，这个配置文件主要和源有关，因为获取依赖列表和软件都是要从 yum 服务器，所以肯定最好选择连接速度较快的服务器。比如：

> http://centos.ustc.edu.cn/centos/7/os/x86_64/

像这样的镜像网站上除了要安装的软件之外，最重要的就是 repodata 目录，里面存放了分析 RPM 软件后所产生的软件属性依赖数据存放处。而源配置文件一般是在 /etc/yum.repos.d/CentOS-Base.repo。在这个文件中可以添加许多源，而其中最重要的是 baseurl 这一栏目，后面跟的就是软件源的实际地址。

但是如果需要在 Linux 上安装第三方辅助软件，而在一般的 CentOS 软件源中并没有包含进去，那需要去一些特殊的源中去寻找，比如 EPEL 和 ELRepo。或者假设是使用本机的安装光盘，其实也可以将源地址修改为本地挂载的光盘：

```
baseurl = file:///mnt
```

最后提一嘴，如果想要全系统进行升级，只需要执行 `yum -y update`

---

那么到底是使用 rpm 来安装还是使用 tarball 来安装呢？那么书上是这么建议的：

* 优先选择原厂的 RPM 功能，因为上面的软件通常有一段时间的维护期；
* 一般选择软件官网发布的 RPM 或是提供的软件源地址
* 使用 tarball 来安装特殊软件
* 并且可以使用 tarball 测试新版的软件

### SRPM

SRPM 和 RPM 的区别在于 SRPM 中有源代码和配置文件，这样就可以对软件的功能进行调整。那么新版的 RPM 已经将 RPM 和 SRPM 的命令分开了， SRPM 使用的是 rpmbuild 命令。

如果你目前已经有一个 SRPM 包了，那么使用命令 `rpmbuild --rebuild` 可以完成编译与打包的操作，但是这样并没有将软件安装到系统上；使用命令 `rpmbuild --recompile`  最终就是能安装到系统上。如果这些步骤一切顺利，编译过程中可能产生的中间文件将不会保留，而如果一旦失败则中间文件会被保留下来方便查错。SRPM 使用的路径主要有如下几个：

* /root/rpmbuild/SPECS/：放置配置文件
* /root/rpmbuild/SOURCES/：放置软件原始文件
* /root/rpmbuild/BUILD/：缓存数据
* /root/rpmbuild/RPMS/：经过编译后会将打包后的文件放在这个目录中
* /root/rpmbuild/SRPMS/：这时 SRPM 封装的文件

当一个 SRPM 包编译完成没有问题后，只会剩下成功的 rpm 包，并且编译过程中肯定需要像 make、gcc 等程序。

对于 SRPM，最重要的就是它的配置文件，一般的操作都存放在这个配置文件中，并且如果用户需要自定义一些操作也是可以修改 *.spec 文件。仔细观察这个 .spec 文件，它一定是由 Summary 开始，这是最基础的说明内容；然后每个不同段落都是以 % 开头。那么一般一个 spec 文件由如下几个段落组成：

* 系统的整体信息，这是必须的！里面包含了很多软件的信息
* %description：对软件的简单的说明
* %prep：安装之前 RPM 要帮你做的一些事，比如补丁、备份
* %build：一般就是编译的过程了，这也是最有可能被修改的地方，比如重新赋予 ./configure 并给予新的参数设置。
* %install：编译成功之后，安装的过程
* %files：软件安装的文件都要写到这里，包括目录。
* %changelog：这个项目是在记录这个软件曾经的更新记录。

这时如果需要将 /root/rpmbuild 下面的数据编译或是单纯地打包成为 RPM 或者 SRPM 时，这依旧可以用 rpmbuild 命令，使用 `rpmbuild -ba|bb` 可以生成 SRPM 包或者 RPM 包。系统的做法是：

* 进入 /root/rpmbuild/BUILD 目录
* 依照 spec 文件的内容定义工作目录
* 进入新建的目录，针对 SOURCES 下的源文件，解压
* 根据 %build 和 %install 进行编译安装
* 最后将完成打包的文件放到该放置的地方

如果你热爱自定义创新，那么可以自行编写 spec 文件的各个部分，这样就可以自己打包一个软件，制作一个 rpm 包。