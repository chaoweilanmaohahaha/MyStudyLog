# 垃圾收集以及内存分配

Java这个语言并不是第一个考虑到内存回收的语言，对于这方面的只是还需要了解，是因为你要对这些技术实施进行必要的监控。那么其实本质实在回答三个问题：

* 哪些内存需要回收
* 什么时候需要回收
* 如何进行回收

在java虚拟机内存模型中，可以知道的是程序计数器、虚拟机栈和本地方法栈是随着线程生灭而生灭，这几个区域的内存分配和回收是具备确定性的。但是对于java堆而言则不是了。

### 哪些需要回收 --- 对象死了吗

如果需要回收堆中的对象，那么最先做的是要判断堆中的对象是否还活着。

###### 引用计数

也就是在对象实例中添加一个计数器，只要有一个地方引用了它就+1，引用结束则-1，那么如果为0则说明无人引用。这个方法在linux内核中多次使用。但是在java虚拟机中会出现两个对象相互引用对方的情况，这时很难解决到底是否需要回收的问题。jvm不是通过引用计数的方法来判断的。

###### 可达性判断

jvm使用的是可达性判断，通常jvm会有一个称为GC Roots的其实引用点，如果一旦有对象引用就会接在这个root下，如果从这个root向下搜索，没有找到某个对象，即可证明该对象不可用。在这棵树上挂着的包括：

* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法去中常量引用的对象
* 本地方法栈中JNI引用的对象

引用在Java中可以被定义为4类：

* 强引用：Object obj = new Object() 垃圾收集器是不会回收强引用的。
* 软引用：一些还有用但不是必须的对象。
* 弱引用：也是一些不必须的对象，但是它和软引用回收时机不同，软引用只有在内存溢出之前回收，而弱引用会在下一次垃圾回收时回收。
* 虚引用：无法通过该引用来获得一个对象实例，只是用作通知。

那么是不是在经过可达性分析之后就一定能判断是否死亡了呢?其实也并不是，当发现某个对象并没有和Root连接时，只是会暂时标记这个对象，在后续执行时还要查看是否这个对象是否有必要去执行一个finaize方法，如果finalize方法中这个对象把自己救活了，则能免于一死。

### 怎么回收 --- 垃圾回收算法

###### 标记清除算法

先对已经不使用的对象进行一次标记，用的就是前面讲到的可达性算法，然后对这些标记了的对象进行回收。但是这么做会有两个问题，一是会有很大的开销，二是容易留下内存碎片。

###### 复制

将内存区域划分为两部分，一部分保留一部分用作分配，如果某一部分进行了垃圾回收，就将存活的那些内存区域复制到保留区域上。但是这样做就缩小了内存区域。但是这是商业虚拟机多数都采用这种算法来回收新生代。

###### 标记整理算法

这个和标记清除算法的不同就在与第二步中并不是将标记的对象直接清除，而是将存活的对象向头部移动。

###### 分代收集

这个就是目前虚拟机都使用的算法。根据对象存活周期不同将内存划分为几块，一般分为新生代和老年代，然后根据每个区域使用合适的收集算法。一般在新生代中会使用复制算法，而在老年代中使用标记整理和标记清除算法。

**HotSpot中的实现**

###### 枚举根节点

在可达性分析中会出现两种情况，一个问题在于枚举树结点中的引用会消耗大量的时间，同时可达性分析还是对时间敏感的，因为它必须要保证一致性，即要保证在分析进行时不能让引用的关系在发生变化。这样GC在进行时会停止所有Java执行线程。在HotSpot中是使用了一种叫OopMap的数据结构，在类加载完成的时候就可以把对象内什么偏移量上是什么类型的数据给计算出来了（这一点需要查资料）

###### 安全点

那么在OopMap结构的帮助下是可以很快完成GC Root枚举的，但是是否执行每一条指令的时候都需要生成一个这样的结构呢？实际上在HotSpot中会在特定的位置才会生成一次该结构，而这个位置就是安全点，也就是说程序的执行只有到达安全点才会暂停。通常安全点的设置出现在能够让程序长时间运行下去的位置，即方法调用、循环跳转、异常跳转等地方。这里的一个问题在与当我们要进行垃圾回收时，那么就需要让所有的线程都运行到最近的安全点上，这里就有两种方法：抢先式中断和主动式中断。一般使用的是后者，思想是设置一个标志，这个标志的位置和安全点和内存分配的点是重合的，线程执行时会轮询这个标志，如果这个标志为真需要中断挂起。

###### 安全区域

这个是针对程序没有分配到CPU时间准备的，安全区域是指一段代码片段中，引用关系不会发生变化，在这个区域的任何一个地方都可以进行垃圾回收。所以在进入安全区域时，线程需要标识自己有没有进入安全区域，而出安全区域的时候就要保证自己已经经过根节点枚举了，才能让线程继续进行。

---

### 垃圾收集器

在HotSpot中垃圾收集器有许多种，而这许多种的垃圾收集器也可以配合着进行使用。

###### serial收集器

这个收集器是一个单线程收集器，意思是说这个收集器在进行垃圾回收的时候会让所有用户线程停止，等待垃圾回收。使用复制算法。

###### ParNew收集器

这个收集器是serial收集器的多线程版本，论每个线程上的垃圾回收和serial收集器一模一样，但是这个收集器有一个好处，它的定位是在hotspot青年代区域，而且是为数不多可以和老年代的CMS收集器配合使用的收集器。

###### Parallel Scavenge收集器

这个收集器本质上和ParNew收集器相同，都是多线程的收集器，但是和前两个有区别在于，其他的收集器都是考虑如何缩短停顿时间，但是这款收集器是一款吞吐量优先的收集器，并且他能通过设置对吞吐量进行自适应调整。

###### serial old收集器

这个收集器对应的就是serial收集器的老年版。使用的是标记整理算法。

###### parallel old收集器

这个收集器是parallel scanvenge收集器的老年版本，同样考虑吞吐量优先。

###### CMS收集器

这个收集器是活动在老年代的以获取最短回收停顿时间为目标的收集器，它是基于标记清除算法实现的。它一共要经过4个步骤：初始标记，并发标记，重新标记，并发清除。但是这一款收集器也存在缺点，首先就是CMS收集器对CPU资源很敏感，其次它无法收集浮动垃圾，最后就是会产生大量空间碎片。

---

### 内存分配

对象的内存分配，基本上可以认为就是往堆上分配，对象主要被分配在新生代Eden上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，只有在少数情况下会被直接分配到老年代中。在分配Eden上内存时，如果发生了内存不足的情况，则会调用一次minorGC的操作。如果系统中出现了大对象，也就是比如那些很长的字符串以及数组，这些对象很容易导致内存不足。因此在虚拟机中会设置一个阈值，如果超过该阈值则会直接将这样的对象移到老年区。同时虚拟机给每个对象定义了一个对象年龄计数器，如果对象经过了一次MinorGC还存活，则年龄加一，当到达一定的阈值则被移动到老年代。当然虚拟机在这方面还做了优化，如果在Survivor空间中存活的对象，年龄相同的对象占用的空间已经达到了survivor空间一半之上，则可以将这些对象直接移到老年代。

在这个中间存在一个空间分配担保机制，那就是当进行minorGC时，要检测是否老年代存在空间足够容得下所有存活的对象。这决定了系统是否要通过一次FullGC来为对象腾出空间。