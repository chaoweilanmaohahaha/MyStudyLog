# 垃圾收集以及内存分配

Java这个语言并不是第一个考虑到内存回收的语言，对于这方面的只是还需要了解，是因为你要对这些技术实施进行必要的监控。那么其实本质实在回答三个问题：

* 哪些内存需要回收
* 什么时候需要回收
* 如何进行回收

在java虚拟机内存模型中，可以知道的是程序计数器、虚拟机栈和本地方法栈是随着线程生灭而生灭，这几个区域的内存分配和回收是具备确定性的。但是对于java堆而言则不是了。

### 哪些需要回收 --- 对象死了吗

如果需要回收堆中的对象，那么最先做的是要判断堆中的对象是否还活着。

###### 引用计数

也就是在对象实例中添加一个计数器，只要有一个地方引用了它就+1，引用结束则-1，那么如果为0则说明无人引用。这个方法在linux内核中多次使用。但是在java虚拟机中会出现两个对象相互引用对方的情况，这时很难解决到底是否需要回收的问题。jvm不是通过引用计数的方法来判断的。

###### 可达性判断

jvm使用的是可达性判断，通常jvm会有一个称为GC Roots的其实引用点，如果一旦有对象引用就会接在这个root下，如果从这个root向下搜索，没有找到某个对象，即可证明该对象不可用。在这棵树上挂着的包括：

* 虚拟机栈中引用的对象
* 方法区中类静态属性引用的对象
* 方法去中常量引用的对象
* 本地方法栈中JNI引用的对象

引用在Java中可以被定义为4类：

* 强引用：Object obj = new Object() 垃圾收集器是不会回收强引用的。
* 软引用：一些还有用但不是必须的对象。
* 弱引用：也是一些不必须的对象，但是它和软引用回收时机不同，软引用只有在内存溢出之前回收，而弱引用会在下一次垃圾回收时回收。
* 虚引用：无法通过该引用来获得一个对象实例，只是用作通知。

那么是不是在经过可达性分析之后就一定能判断是否死亡了呢?其实也并不是，当发现某个对象并没有和Root连接时，只是会暂时标记这个对象，在后续执行时还要查看是否这个对象是否有必要去执行一个finaize方法，如果finalize方法中这个对象把自己救活了，则能免于一死。

### 怎么回收 --- 垃圾回收算法

###### 标记清除算法

先对已经不使用的对象进行一次标记，用的就是前面讲到的可达性算法，然后对这些标记了的对象进行回收。但是这么做会有两个问题，一是会有很大的开销，二是容易留下内存碎片。

###### 复制

将内存区域划分为两部分，一部分保留一部分用作分配，如果某一部分进行了垃圾回收，就将存活的那些内存区域复制到保留区域上。但是这样做就缩小了内存区域。但是这是商业虚拟机多数都采用这种算法来回收新生代。

###### 标记整理算法

这个和标记清除算法的不同就在与第二步中并不是将标记的对象直接清除，而是将存活的对象向头部移动。

###### 分代收集

这个就是目前虚拟机都使用的算法。根据对象存活周期不同将内存划分为几块，一般分为新生代和老年代，然后根据每个区域使用合适的收集算法。一般在新生代中会使用复制算法，而在老年代中使用标记整理和标记清除算法。

**HotSpot中的实现**

###### 枚举根节点

在可达性分析中会出现两种情况，一个问题在于枚举树结点中的引用会消耗大量的时间，同时可达性分析还是对时间敏感的，因为它必须要保证一致性，即要保证在分析进行时不能让引用的关系在发生变化。这样GC在进行时会停止所有Java执行线程。在HotSpot中是使用了一种叫OopMap的数据结构，在类加载完成的时候就可以把对象内什么偏移量上是什么类型的数据给计算出来了（这一点需要查资料）

###### 安全点

那么在OopMap结构的帮助下是可以很快完成GC Root枚举的，但是是否执行每一条指令的时候都需要生成一个这样的结构呢？实际上在HotSpot中会在特定的位置才会生成一次该结构，而这个位置就是安全点，也就是说程序的执行只有到达安全点才会暂停。通常安全点的设置出现在能够让程序长时间运行下去的位置，即方法调用、循环跳转、异常跳转等地方。这里的一个问题在与当我们要进行垃圾回收时，那么就需要让所有的线程都运行到最近的安全点上，这里就有两种方法：抢先式中断和主动式中断。
