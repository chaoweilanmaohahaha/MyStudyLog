# Java编译器

java的编译期是一个很模糊的概念，你可以认为java的编译是把.java文件编译成.class文件，也可以是运行时的编译（JIT），也可能是静态编译直接把java文件编译成机器代码。对于代码的优化来说，第一类编译并没有什么优化可言，真正进行优化的地方往往出现在第二种编译场景下。但是相当多的新生的java语言特性都是使用了编译器的语法糖来实现的，而不是底层实现。

### JavaC编译器

编译器不属于虚拟机的一部分，它本身就是用java语言编写的。编译的过程大改有如下三步：

* 解析与填充符号表过程
* 插入式注解处理器的注解处理过程
* 分析与字节码生成过程

##### 解析与填充符号表

这一步中使用的就是经典的词法和语法分析，词法分析是将源代码的字符流转变为标记集合的过程，而语法分析是将这个标记集合转化为抽象语法树的过程。当生成了抽象语法树之后，编译器就不会再对源代码进行操作了。紧接着需要填充符号表，符号表是一组符号地址和符号信息组成的表格。

##### 注解处理器

Java中注解也可以和代码一样在运行时发挥作用，插入式的注解处理器就是在编译的过程中对注解进行处理，这个插件可以对语法树击行修改，如果发现在处理注解阶段语法树被修改过，那么编译器就会回到第一步重新处理。

##### 语义分析和字节码生成

抽象语法树虽然可以表达源程序，但是它无法保证源程序一定是符合逻辑的。

* 标注检查：这一步需要检查代码中变量在使用之前有没有被声明，被赋值时变量类型是否匹配等；这一步中有一个重要步骤叫做常量折叠。
* 数据和控制流分析：这一步用来分析程序的上下文逻辑，查看一些更加深层的代码逻辑问题。

##### 解语法糖

虚拟机在运行时其实时不支持这些语法糖的语法的，需要在编译阶段将这些语法糖还原到简单的基础语法结构。

##### 字节码生成

字节码的形成除了直接的写盘，还有就是进行少量的代码添加和转换工作。比如实例构造器和类构造器就是在这个时候被添加到语法树上的。当所有所需的符号表信息交给编译器后，最终使用这个生成字节码程序。

### 语法糖

语法糖就是在计算机语言中添加某种语法，而对语言的功能没有任何影响的方法。

##### 泛型和类型擦除

在java中泛型只在源码中存在，在编译后的字节码文件中它被替换为原来的原生类型了，并且在对应的地方插入了强制转换类型的代码。因此java中的泛型被称为类型擦除。**这种类型擦除的问题很容易涉及到重载上的问题。**

##### 自动拆箱装箱、遍历

##### 条件编译

在java中的条件编译的意思是使用条件为常量的if语句。

---

### 即时编译器

当虚拟机遇到某一段使用特别频繁的代码的时候，它会默认把它认为是一段热点代码，而为了提高热点代码的运行，就会把这段代码编译成和本地相关的机器代码，这一个过程就是即时编译器所作的事。

**即时编译器并不是虚拟机的必须的部分，但是确实衡量一个虚拟机的优秀与否的指标。下面以hotspot的虚拟机为例，来看一下具体的细节。**

###### 为什么要同时依靠编译器和解释器？

java虚拟机大部分主流的都是同时使用了编译器和解释器，为了快速启动和快速执行，java会首先使用解释器；但是当代码的执行需要提升效率的时候，编译器就派上了作用；但是当内存资源不够了的时候，解释器又可以做到节约内存。所以这个过程是解释器和编译器相互配合的过程。

###### 为什么虚拟机实现了两个不同的编译器？

在hotspot中内置了两种即时编译器，即client compiler和server compiler（C1编译器和C2编译器），对于虚拟机而言会默认使用其中一个编译器直接配合来工作，具体和哪个编译器工作是取决于虚拟机当前处于的模式是客户端还是服务端，但是它们配合工作都是使用的混合模式。

###### 编译的对象和触发的条件

被编译的对象称为一段代码的热点代码，简单地说这段代码应该是多次调用的方法或者是多次执行的循环体。但是要注意的是无论是对于方法还是循环体，编译器都是会以整个方法作为编译的对象。

判断一段代码是不是热点代码被称为热点探测，在hotspot中有两种简单的方法来识别：

* 基于采样的热点探测：周期检查栈顶，看某个方法是不是经常出现在栈顶。
* 基于计数器的热点探测：虚拟机为每个方法建立计数器，统计执行次数，如果计数器超过一定的阈值就认为它是热点方法。

当不做设置时，执行的引擎会继续进行解释方式执行字节码，除非提出的请求被编译器编译完成了，此时方法的入口会被修改为新的入口。hotspot使用第二种方式，并且分别使用方法调用计数器和回边计数器来统计方法调用次数和循环语句执行次数。

###### 编译过程

上面也提到了，在编译还未完成的时候，程序仍然是以解释执行的方式运行的，那么编译的动作会放在后台继续进行。对于C1编译器，会使用简单的三段式编译器，在第一阶段会将字节码构造成高级中间代码，第二阶段会将高级中间代码转换为低级中间代码，第三阶段使用线性扫描算法在低级中间代码上窥孔优化，生成机器代码。而C2编译器则是一个充分优化过的高级编译器，执行所有经典的优化。