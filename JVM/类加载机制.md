# 类加载机制

现在已经知道的是，一个类要存储成字节码文件.class然后可以被虚拟机运行。那么当虚拟机要使用某个class文件时必然要把class文件中的数据加载到虚拟机中，形成虚拟机所能识别的java类型。

为了增加java的灵活性，加载类和连接以及初始化的过程都是在程序运行时完成的。

#### 类加载的时机

我们把类加载到内存到离开内存，这个过程一共分为7个阶段。

* 加载：在加载阶段要完成如下三件事：1、 通过一个类的全限名来获取这个类的二进制流；2、 将这个字节流中所代表的静态存储结构转化为方法区的结构；3、 在内存中生成一个代表这个类的java.lang.class对象，作为方法区的访问入口。这里简单的有个问题，那就是在最初只需要使用类的全限名来获取类的二进制流，但是却并没有指明要去哪获取，所以获取的途径就非常多了。
* 验证：这是为了保证读入的字节流符合虚拟机的要求。如果有问题，虚拟机会抛出java.lang.VerifyError的异常。大体上的验证做了如下四步：文件格式验证（对文件中的一些条件进行检查）、元数据检查（对java语言进行语义上的分析）、字节码检查（通过数据流和控制流的分析，来看代码的语义和逻辑是否正确）、符号引用验证（即查看类自身意外的信息进行匹配性的验证，确保解析能够成功）
* 准备：这个阶段会为类变量分配内存并设置类变量初始值（static），这一步一般把类变量初始化为0。但是如果这个变量是使用final修饰的，就会直接赋值。
* 解析：这一步就是虚拟机将常量池中的符号引用转换为了直接引用，符号引用就是描述引用目标的一组符号，但是直接引用就是直接指向目标的指针或者是间接指向目标的句柄，这和内存布局就有关了。
  * 解析类和接口时，当前的类会把下一个类或者接口的全限名交给该类的加载器，由它进行加载。
  * 字段解析，它会取字段表中的类符号引用进行解析，然后查找这个类中是否有这样的字段名、继承的接口，父类中是否有这样的字段名。
  * 类方法解析：同样需要从这个方法表中的类符号引用进行解析，随后在该类中查找、在其父类中以及该类实现的接口以及它们的父接口中查找是否有这样的字段名。
  * 接口方法解析：和上面的方法中的第一步一样，随后在该接口以及父接口中查找对应的字段。
* 初始化：这一步真正执行了java代码。这一步就是给类变量和其他资源进行初始化赋值。这一步就是执行类构造器<clinit>的过程
* 使用
* 卸载

---

### 类加载器

类加载器虽然只是负责加载类的动作，但是实际上，它也是判断两个类是否相等的标志，如果两个类不是由同一个类加载器加载，则说明这两个类不是相等的。对于java语言来说只有两种加载器，一种是启动类加载器（虚拟机自身一部分）和其他类加载器（虚拟机外部）。如果可以细分，则分为启动类加载器，扩展类加载器和应用程序加载器。我们的应用程序基本上就靠这三个加载器实现。而这三个加载器构成了一个双亲委派模型，这个模型要求在加载的时候，加载的请求会传给父欸加载器去完成，只有父类完不成才让子类去完成。

