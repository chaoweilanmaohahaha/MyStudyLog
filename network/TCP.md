# TCP

TCP: transmission control protocol 传输控制协议

TCP属于传输层协议，和UDP在同一层，但是它和UDP所给的服务是不同的，TCP给的服务是一种面向连接的端到端的可靠数据流服务。面向连接是指它会和目标主机建立一个连接，就好比我们打电话一样。谈到可靠的服务，那么TCP给出的就非常多了，比如重传，超时，缓存等等。数据流服务就和UDP有很大区别了，回想一下UDP它可以把整个要发的信息塞入数据报，但是TCP传递的是字节流，因此它就有两个特性了，一个是字节流是不断发送的，你无法直接看出这个字节流中的数据的归属；第二就是传输层是不会去解析字节流的信息，这个工作要交给上层应用层协议了。

**报文格式**

![TCP1](../img/TCP1.jpg)

一个个进行分析了，源端口和目的端口不用说对应源主机和目的主机的端口号，序号标识了在某个分段中的第一个字节，是一个32位无符号数；确认号指的是接收者预期接收到的下一个分段的第一个字节的序号；数据偏移也就是头部长度给出了整个TCP首部的长度；然后是六个标志位，后续介绍这六个标志位都有什么作用；窗口大小指的是接收者希望收到的数据大小；校验和没什么好说的，校验头部和数据的正确性；紧急指针是在TCP传输紧急消息时使用的，这只有在URG标志位置位的情况下才能使用；选项中最常见的是一个叫MSS最大分段长度的选项，后续也会提到。

![TCP2](../img/TCP2.png)

首先看一下TCP连接的建立和断开

## TCP连接的建立和终止

### 三次握手：

1. 客户端发送一个SYN分段指明了想要连接的服务器的端口号，并且初始化客户端的初始序列号。
2. 服务器发送一个响应SYN分段，这个分段包含了自己的初始化序列号，斌并且它需要ack客户端的序列号，即ack后跟上客户端序列号加1
3. 客户端响应服务器的报文，确认号是服务器序列号加1

**syn攻击！**

### 四次挥手：

这里有一个小tip，其实发起关闭连接不一定必须是客户端，任意一方都可以提出关闭连接，只不过一般都是由客户端发起，TCP连接的关闭一般而言是半关闭的，理解这个半关闭的意思是，如果A->B的连接关闭了，B仍能够在关闭连接前传输数据。

1. 客户端发送一个FIN分段告诉服务器我要关闭了，这里面包含了当前的序列号
2. 服务器发送回一个ACK作响应
3. 服务器端发送一个FIN分段告诉客户端我也要关闭了，这里就包含服务器端的序列号
4. 客户端发送回一个ACK作响应

#### 最大分段长度MSS

这个所谓最大分段长度是发送者告知另一方最大发送的负载长度为多少，这个长度是去掉了IP报文头部和TCP报文头部的，对方如果接收了这个长度则会按照协商的MSS来发送报文，如果拒绝了则默认的MSS为536字节。这个协商过程只能发生在建立连接的SYN分段中。那么这个MSS具体有啥用呢，想象一下其实如果一个连接中某个主机已经知道了自己接口的MTU，同时和对方协商好了接收的MSS，那么就可以巧妙地避免分段地可能，一般来说最好还是避免分段。这个MSS是可以和MTU挂钩地，当然也可以有自己地规范。还有一个说法，如果目标主机的IP地址不是本地的，那么MSS通常是536。

#### 2MSL wait state

在四次挥手的过程中，有一个地方值得注意的，那就是当最后一个ack发送出去后，客户端会进入一个wait state的状态，时长2MSL，这时为什么？

1、为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

2、他还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。

在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。

#### Reset Segments

这个分段就是在标志位中的RST置为时发送的分段。这种分段只有在受到的报文不正确的情况下会发送，例如当TCP请求发送到一个不存在的端口，突然终止应用，半连接状态，

#### 同步打开和关闭

同步打开区别于同时开启在两端开启tcp连接，这个要求两个同时处理一个active open的过程，每一端都必须传输一个SYN，并且需要每一端都有一个本地的端口号时其他主机所熟知的。

同理两边都处理active close方法，使得两边同时发送FIN分段，这样就可以造成同步关闭。这种情况十分少见。

#### TCP 选项

TCP的选项部分通常由如下一些字段：end of list(序列末尾)，nop(空操作),MSS，窗口大小，时间戳。每一个选项的开头一个字节时kind域，用来标识这个选项的类型。前两个都只有一个字节。这里讲一下nop这个选项的作用，我们会发现在一些选项中，需要我们将每一个域填充满4字节其中就用到了nop。

**有个有趣的现象是针对一个连接是否要接收或者拒绝这个是靠服务器端的应用程序决定的而不是由TCP决定的，当应用程序判断时三次握手已经完成了，也就是说只要客户端建立了连接，TCP层会直接与它三次握手，然后放入一个等待队列，等待应用程序是否接受它**



## TCP交互式数据流

什么是交互式数据流，通常看到的telnet就有交互式的意思。用户在命令行中没输入一些字符都会和远程的服务器有交互。例如Rlogin，如果你在它的命令行中输入某些字符，就会触发：client向server发送一个字符；server发送ack；server端回显字符；client端ack。

#### 延迟ack

在设计中，如果ack中携带了数据，那么会触发所谓的延迟ack，确认该数据的ack会检测是否ack中需要带有数据，然后延迟一段时间发送ack，这和tcp携带的计时器有关。延迟ACK的目的也是为了减少网络中传输大量的小报文数，但该报文数是针对ACK报文的。

#### Nagle算法

总是传输这些小的数据包有一个问题，就是会造成网络拥塞。针对这个问题提出了一种解决方案，就是在发送下一次报文之前必须受到ack，那么受到ack之前如果已经积攒了很多需要发送的字节怎么办呢？那么客户端会把这些字节组合在一个分段中，然后等待受到ack之后一起发送。Nagle算法的基本定义是**任意时刻，最多只能有一个未被确认的小段**。注意这个算法最好是用在两边交互时的命令只有一个字符，如果客户端发送的命令是多个字符的，则这个算法就并不奏效。



## TCP块状数据传输

TFTP也给出了块状数据传输的方法，它需要将数据发送给另一端后等待另一端回应一个ack方可继续传输，这种协议称为停等协议。在TCP中客户端向服务器端发送数据确实也需要受到服务器端响应确认才行，但是不同的是，TCP不一定要等待确认后才发送，因为它运行的是滑动窗口协议，这个协议可以加快客户端发送数据的速度。

在滑动窗口中，服务端会给客户端回复ack，但没有必要每一个报文都回复一个。事实上，在服务端受到一个报文之后会进入delayed ack的状态，如果在这个过程中受到报文，那么同样也可以在ack中确认。因此会出现多个报文只用一个ack就能全部确认。当客户端受到这个ack后意味着该序号以上的所有字节都已经全部收到了。

那么在传输数据的过程中，当客户端发送过快，服务端的接收缓冲区会立刻被填满，这个时候会出现回复的ack中指示它的接收窗口已经满了的情况。客户端并不会立马发送数据，只有当服务器端额外发送一个ack，这个ack是用来更新接收缓冲区的大小。

### 滑窗协议

**此处照着书上画一张图把！**

这个窗口由接收者通告，窗口左边的是已经发送出去并且已经接收到的报文，窗口中有部分报文可能是接收到但还没确认，还有的是还没发送的但可以发送的，而右边的是还未发送的并且还需等待发送的报文。

### push 标志

push标志的意思最初对于client来说就是希望客户端才发送其他数据之前先把自己发送出去，而对于接受方来说希望在别的数据到来之前先将自己交付给系统。但是对于客户端来说，最好的做法应该是让TCP自己去判断是否置为push位，那么现在的说法是如果发送方发送数据时一次性清空了发送缓存，那么就置为push。

### 慢启动

当TCP传输运行在局域网中是相当舒服的，但是如果是需要接入互联网，那么就会遇到类似路由缓存减慢包的传输等问题，发送端就需要方法去降低自己的发送速度。慢启动算法要求发送方维护一个拥塞窗口，当和某个主机连接是窗口初始化为1，然后每次都增加一个窗口大小（1，2，4……），直到出现拥塞。那么对于发送方而言，它只需要发送拥塞窗口和接收窗口的最小值就可以了。**要注意的是，拥塞窗口时由发送方维护，但是接收窗口是由接受方维护。**这个结合后面的重传机制一起详细来讲。

#### 紧急模式

TCP还给出了一种叫做紧急模式的选项，它可以让一端告诉另外一段存在着重要的数据在数据流中。要完成这些功能就必须要求在TCP头部置为URG位以及填写一个16位的紧急指针。这个指针指向了序列号以便获取该序列最后一个字节。那么当接收者遇到这个标志时就会进入紧急模式，然后再恢复正常。



## TCP超时和重传

首先先陈述一个事实，TCP一共管理四个不同的计时器。

1. 重传计时器负责查看从另一端获取的ack。
2. 持续计时器负责维持窗口信息
3. 保持存活计时器检测另一端在什么时候重启或者崩溃
4. 2MSL计时器，负责在FIN报文的最后维持一个TIME_WAIT的状态。

### RTT的计算

这个是超时和重传机制中比较重要的一个内容，要注意的是，ack和发送的报文本身没有任何序号上的关联，一个ack可能是响应多个收到的报文，那么怎么计算RTT呢？

目前普遍的一种算法是Jacobson算法，它首先计算当前的RTT--M，然后有一个估计值称为smoothedRTT--A，更新这个A

A<--- A+g(M-A)

其中g是一个权重一般设置为0.125，然后计算一个估计的平均误差--D

D <--- D+h(|Err|-D)

其中h也是一个权重一般设置在0.25，此时便可以计算重传的超时时间RTO = A+4D

计算时要注意几个细节，当一个报发出后，计时器已经开始工作，下面发出的包不会进入计算，除非收到ack后关闭计时器。 当出现重传时，不能更新当前的RTO，而需要使用指数回退的方法来计算RTO（Karn算法），因为你无法分辨这个ack时之前报文的ack还是重传报文的ack。

