# 学习Makefile

执行make时，需要有makefile文件，这会告诉make命令需要怎样去编译和链接程序。

我们需要尽可能做到：

1. 如果这个工程没有被编译过，那么所有的C文件都要被编译并被链接。
2. 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并进行链接。
3. 如果这个工程中几个头文件被修改了，那么需要编译引用这几个头文件的C文件，并链接。

### makefile的书写规则

```
target... : prerequisites ... 
command
...
...
```

target代表了目标文件，也可以是执行文件；prerequisites代表生成这个目标文件所需要的那些文件；command就是执行make这个命令时所需要执行的命令。

这样定义有个好处，如果prerequisites中有一个文件比生成的目标文件新，那么command就会被执行。

这里先举个小例子

```
hello: helloworld.o
        gcc -o hello helloworld.o

hello.o: helloworld.c
        gcc -c helloworld.c

clean:
        rm hello hello.o
```

**在输入命令的时候要注意的是在前面一定要打tab**

在命令行中输入了make后具体所做的事就是：

* 首先在当前目录下寻找Makefile或者makefile文件；
* 如果找到了，就会找是否有hello这个文件，将这个文件作为目标文件；
* 如果hello文件不存在，那么就需要查找后面带的.o文件或者比较新的.o文件，然后生成该文件
* 如果.o文件也不存在，则去后面查找依赖的文件，然后根据给出的命令生成对应的.o文件

像上面有一个特别的clean，这是在makefile中的类似于c语言中的标号的东西。在敲打make命令后，如果找到该文件的依赖后会自动执行，但是像clean这样的标号无法寻找依赖的就不会执行后面的命令了。

对于一个小工程而言，不会有那么多的文件，但是对于大工程而言，如果文件很多，像上面那种格式书写makefile会非常麻烦，因为许多文件可能要多次作为参数，那么如果需要修改就很麻烦，因此就会使用许多变量来代替。例如我在文件开始处定义hello = helloworld.o，那么我在下面使用helloworld.o处就可以直接以$(hello)的形式来使用该变量。

### Makefile详解

实际上Makefile里面一共有五个东西：显式规则、隐式规则、变量定义、文件指示和注释。

**显示规则**其实就是在上面定义的写法，**隐式规则**可以在编写的过程中省略一些依赖文件，让make程序自己去推导，相当于是简略版的makefile；使用的**变量**上一般选择使用字符串，就和c语言那样的；**文件指示**一共有两点，一是和C语言的include一样可以将其他Makefile文件包含进来，还有一点就是像预编译一样使用if来指定makefile的有效部分。makefile中的注释使用#开头。

makefile的文件名必须是Makefile,makefile和GNUmakefile中的一个。如果你使用其他的名字的话务必在命令后面添加-f选项。如果在调用make命令的时候，使用了**-I**参数指定了某个文件夹，那么make就会去指定的目录下去寻找，如果没有指定也会去/usr/local/bin和/usr/include。（其中还有一种方法是设置环境变量MAKEFILES，但是这种方法存在弊端在于它会影响到所有的makefile文件）。

### Makefile规则详解

在makefile中一些通配符也有很大的作用，在makefile中是几乎兼容linux的通配符的。它支持*，？和[]。\*就不用说了，这个通配符一般指代了多个匹配到的数据，比如如果是想要通过clean中的rm命令删掉所有的.o文件，就是可以写成\*.o。

在一些大型的项目中，会出现一些源文件被保存在不同的文件夹中，那么makefile需要去找这些源文件就要想办法去获取路径。在makefile中可以定义一个特殊变量VPATH，这个变量定义后如果在当前的目录下找不到，那么就可以到指定的路径下去找。例如：

```
VPATH = src:../headers // 不同的目录需要使用冒号分割
```

当然也可以在make命令中使用vpath选项。

makefile中还有一个内容称为伪目标，就比如之前提到的clean，这个不是一个目标文件，但是它的写法和目标文件一样。但是如果说存在一个目标文件就叫clean，岂不是很尴尬，因此需要使用.PHONY这个特殊的标记来标识这个伪目标。

```
.PHONY : clean
```

又比如对于makefile来说，按照之前的规则，它会把碰到的第一个目标文件作为最终生成的目标，但是在编写的时候又希望只敲一个make就生成多个目标文件，那就需要使用伪目标

```
all : prog1 prog2 prog3
.PHONY : all
```

当然伪目标也可以像依赖关系那样使用

```
.PHONY : cleanall cleanobj cleandiff
```

**在makefile中还支持多个目标使用相同的依赖，这个我们到后面看变量的时候讲**

有了多目标的概念之后，就可以看看常见的静态模式，这个模式下，需要使用如下语法：

```
<targets ...>: <target-pattern>: <prereq-patterns ...>  
<commands>  
....
```

比如：

```
objects = foo.o bar.o    
all: $(objects)    
$(objects): %.o: %.c  
$(CC) -c $(CFLAGS) $< -o $@ 
```

targets指定了你要生成的那些目标集合，而target-pattern则是目标文件的格式，prereq-patterns指定了依赖文件所需要的文件格式。

最后提到一点，在依赖文件中除了要使用的那些c文件之外，还有许多头文件，也就是c文件中include进来的一些头文件，这些文件在维护时比较麻烦，编写的时候需要找如果修改了还要进行修改。那么一些c/c++编译器的编译命令存在-M和-MM命令，这样可以自动去寻找依赖的头文件便于维护而重新生成指令。但是makefile中总不能重新生成一遍吧。因此规定可以为每一个源文件自动生成的依赖关系放入一个文件中，为每一个.c生成一个.d文件的makefile。总之就是希望在编译器生成的依赖关系中插入一个.d文件，然后再把这个.d文件使用进makefile就能起到自动更新的效果了。

---

在编写makefile命令时会用到的一些问题：

* 如果你你想不显示执行的命令可以在命令前加@，如果你只是想显示命令但是不想执行，则make命令后面跟上-n或者--just-print，make后面跟上-s是为了全面禁止命令显示。

* 如果你希望命令的执行是前后有依赖关系的，第二条命令是在第一条的基础上执行后执行的。那么需要讲两个命令写在一行上，并用；分割。

* 命令出错后会终止当前的规则，这将有可能终止所有命令的执行。因此有些类似于mkdir的命令很有可能出现这样的问题，为了防止这样的事情，要么在命令之前标记一个-，标识无论如何都是成功的；或者使用-i参数或者-k，表示忽略错误或者是继续执行其他规则。

* 如果你希望makefile写的更加简洁，就会使用嵌套的makefile，这样可以将总控的makefile写成：

  ```
  subsystem:  
  cd subdir && $(MAKE) 
  ```

  如果在这个途中你要给下层的makefile传递变量，那么使用export <variable>的形式。有两个参数注意SHELL和MAKEFLAGS都会向下传递。在嵌套执行中-w参数使用的较多，让你可以在执行过程中看到文件夹的变化。

* 最后可以为相同的命令序列定义一个命令包，使用define，开始endf结束。比如

  ```
  define run-yacc  
  yacc $(firstword $^)  
  mv y.tab.c $@  
  endef 
  ```

  这里run-yacc就是定义的命令包名，那么在调用这个命令包的时候，只需要像使用变量那样，使用$(run-yacc)就行了。

### Makefile的变量

makefile的变量就像c和c++那样，它的命名遵守c语言的标识符的规则，但是它的作用有点类似于c语言中的宏，是将定义的变量原封不动的复制到变量处。在makefile中变量是大小写敏感的。

上面也提到了，变量需要赋予它初值，并且在使用变量的时候需要使用$，最好使用（）将变量括起来使用。变量是可以嵌套定义的，就比如说：

```
foo = $(var)
var = djjd
```

这个是有它的用处的，就比如一开始定义了某个变量是其他变量的嵌套，那么只需要在下面修改嵌套的变量就可以了。但是使用不当会造成死嵌套，比如：

```
A = $(B); B = $(A)
```

为了防止上面情况的发生，可以采用:=

```
x := foo  
y := $(x) bar  
x := later
```

此时变量y无法使用到后来修改的值x，也就避免了这样一个问题。

还有一个比较好玩的?=，如果有 a?=b，意思是如果a没有被定义过，那么值初始化为b，否则使用原来的值。下面有两种更加高级的写法：

1. $(var:a=b)：意思是把var变量所有以a结尾的a变为b，比如把所有.o结尾的变成.c
2. $($(x))：把变量当成变量，这样就更有嵌套的感觉。

**我们还是要理解这里的变量和c语言的宏替换是一个概念。**

使用运算符+=可以在某个变量后面追加一些变量，这个和c语言的+=类似。

如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在 Makefile 中设置这类参数的值，那么，你可以使用“override”指示符。

前面曾经提到过一个叫做命令包的东西，还记得在定义一个命令包的时候需要使用define指示符来帮助定义多行的命令。

在makefile中有几种特殊的变量，其中环境变量就属于其中一种，我们经常能看到一些makefile中设置了CFLAGS变量，如果 Makefile 中定义了 CFLAGS，那么则会使用 Makefile 中的这个变量，如果没有定义则使用系 统环境变量的值，这统一了全局变量和局部变量。

在上面我们聊到的所有变量目前都属于全局变量，也就是在整个文件中都能被访问。当然也可以在文件中定义局部变量，让该变量只在局部生效。

```
<target ...> : <variable-assignment> 
```

也就是说在target这个目标依赖的作用下，执行右边的变量。

```
prog : CFLAGS = -g // 意思就是说在prog这个目标下，CFLAGS的值都为-g
```

最后一个提到的是模式变量，make的模式一般含有至少一个%那么可以使用：

```
%.o : CFLAGS = -O
```

---

### 条件判断

语法：

```
<conditional-directive>  
<text-if-true>  
endif    
以及：   
<conditional-directive>  
<text-if-true>  
else  
<text-if-false>  
endif
```

《conditional-directive》是条件语句，比如ifreq，ifneq，ifdef，ifndef

```
ifeq (<arg1>, <arg2>)  // arg1是否等于arg2
ifneq (<arg1>, <arg2>) // arg1是否不等于arg2
ifdef <var>  // var是否非空
ifndef <var> // var是否为空
```

---

### makefile中常用的一些函数

makefile中包括了许多内建的处理函数，这些函数通常用来处理文件中的变量。函数的调用和变量的使用十分相似，使用$(<fuction> <arguments>) ，前者function就是函数名，而arguments就是参数。参数间使用，隔开，函数名和参数之间使用空格分隔。下面来看一下一些函数的使用情况：

##### 字符串的处理函数

1. $(subst <from>, <to>,<text>) 

   字符串的替换函数将text中的from替换成to，注意是将所有from都替换成to。

2. $(patsubst <pattern>, <replacement>, <text>)

   根据pattern模式将符合模式的字符串替换为replacement表示的模式。

3. $(strip <string>)

   去掉string开头和结尾处的空字符

4. $(findstring <find>,<in>)

   从in这个字符串中查找find

5. $(filter <pattern...>, <text>)

   以pattern的模式过滤text字符串中的单词，只保留符合模式pattern的单词，这里面可以发现在pattern中可以带有多个模式。

6. filter-out

   和filter函数正好相反，去除了符合模式pattern的单词。

7. $(sort <list>)

   给字符串list中的字符串排序，按照字典序，你会发现sort会默认去掉重复的单词

8. $(word <n>, <text>)

   这是从字符串text中的取出第n个单词，注意是单词，而且序号是从1开始。

9. $(word <s>,<e>,<text>)

   从字符串text中第s个单词开始取到第e个单词

10. $(words <text>)

    统计text中包含的单词数

11. $(firstword<text>)

    返回text中的第一个单词

##### 文件名操作函数

1. $(dir <names...>)

   从后面的names路径名中取出目录名，所谓目录名就是最后一个反斜杠之前的部分，如果没有反斜杠则返回./。names可以包含多条目录名。

2. notdir

   和dir函数相反，它是取出路径名中的文件名。

3. $(suffix <names...>)

   这个函数的目的是取出对应的文件的后缀名，如果一个文件没有后缀名，就返回空字符串。

4. basename

   这个函数又与suffix函数相反，它是取处文件名的前缀，也就是除去后缀名的部分

5. $(addsuffix <suffix>, <names...>)

   给后面的每个文件加上一个后缀名，也就是给names对应的文件加上suffix

6. addprefix

   给后面的每个文件加上一个前缀名。

7. $(join <list1>,<list2>)

   将list2中的单词加到list1单词的后面。

##### 功能函数

1. $(foreach <var>,<list>,<text>)

   这个函数字面意思就是一个循环，但是和我们普通看见的那些循环又不一样，这个函数的功能是从list中取出一个个字符串，然后将这些字符串交给var这个变量，最后执行text中的表达式。所以在这个里面var充当一个临时变量，最后返回的是执行的结果。

2. $(if <condition>,<then-part>,<else-part>)

   就是普通的判断，如果condition代表的条件是真，那么返回then-part中的值，否则返回else-part中的值。

3. $(call <expression>, <parm1>, <parm2>...)

   这个函数的目的其实是执行expression中的表达式，其中在expression中你可以先使用类似$(1),$(2)这样留好空，然后在执行过程中会使用后面的parm1等参数代替。

4. $(origin <variable>)

   这个函数是告诉你这个variable是哪里来的，他会告诉你这个变量的定义情况。它一共可能返回如下的可能：undefined(从来没有定义过)、default(是一个默认的参数)、file(在这个makefile文件中被定义)、command line(是由命令行定义的)、override(是由override指示符重新定义的)、automatic(是一个命令运行中的自动化变量)。

5. $(shell)

   这个shell就是操作系统中对应的shell命令，也就是说这个函数的目的就是执行shell后面跟的命令。

6. $(error <text....>)

   输出错误信息

7. $(warning <text...>)

   输出警告信息

### make的运行

首先谈一下make命令本身，这个命令在执行之后会有三种不同的退出码。其中0代表make命令执行成功，1代表make命令在运行时出现错误时返回，2说明使用了-q选项，返回的值。

在之前提到过使用-f可以指定makefile文件。一般而言makefile文件将最终要生成的文件都放在开始，那么make也是默认将第一个目标文件作为最终的目标，当然make也能指定生成目标，就是形同make clean这样直接跟上目标文件。那么一般而言可以使用的规则有如下几个：all(编译所有目标)、clean(一般用来删除make创建的文件)、install(负责安装已经编译好的程序)、print(列出改变过的源文件)、tar(将源程序打包)、dist(创建压缩，将tar文件压成Z文件)、TAGS(更新所有的目标，以备完整重编译)、check和test(测试makefile流程)。

也像前面所说，如果想要使用makefile不执行其中定义的规则，但是想看看编译的过程，那么可以考虑设置q,W,t和n选项。其他的选项就参考一下make的使用说明了。

### make更新函数库

在讲隐含条件之前，先直接讲一下更新函数库的问题。函数库文件是对Object文件进行打包后生成的文件。如果在unix下这个功能是使用ar来完成的。

那么函数库文件是由多个文件所组成，你可以使用类似如下的代码来执行：

```
foolib(hack.o) : hack.o  
ar cr foolib hack.o 
```

如果要指定多个目标文件作为打包的目标，则只需要使用空格空开即可。

这里先说一下这里使用到的隐含条件，目标文件一般的形式是a(m)这样的格式，那么首先make会先将目标变成m，然后和之后一样去一步步运用隐含条件进行编译，我们在接下去的隐含条件中详细说明。**唯独要小心一点，就是注意make的并行机制，不要让ar命令在同一时间运行在同一个函数库的打包上。**

---

### 隐含规则

这是makefile的最后一个知识点了。所谓隐含规则，给人的一种感觉就是，这个规则是在makefile中默认就有了，因此不需要我们明确写出来。举个例子：

```
foo: foo.o bar.o
cc -o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)
```

在上述语句中，你可以发现并没有一个规则帮助你生成了.o文件，但是作为makefile而言它会去自动推导。当然如果你在编译的过程中已经写了规则，那么makefile也无需推导了。对于隐含规则，我们目前只需要直到如下一些：

##### 编译C程序的隐含规则

.o目标的依赖目标会自动推导为.c，然后去生成命令： $(CC) -c $(CPPFLAGS) $(CFLAGS)

##### 编译C++程序的隐含规则

.o的目标的依赖目标会自动推导为.cc或者.C，并且生成命令：$(CXX) -c $(CPPFLAGS) $(CFLAGS)

##### 汇编和汇编预处理的隐含规则

.o的目标依赖目标自动推导.s，默认使用的编译器是as，然后生成命令$(AS) $(ASFLAGS)；.s文件的目标依赖目标会自动推导为.S，默认使用编译器cpp，并且生成命令$(AS) $(ASFLAGS)

##### 链接Object文件的隐含条件

最终的目标依赖于.o，通常通过ld链接生成，命令是$(CC) $(LDFLAGS) .o $(LOADLIBES) $(LDLIBS)

那么可以看到在上述的推导命令中，其实都需要使用一些预先设置的变量，当然你可以在makefile中改变这些值，也可以在环境变量中设置，只有设置了这些变量才对隐含规则起作用。我们可以将这些默认使用的变量分为两组，一组是和命令有关的变量，一组是与参数有关的变量，在下面也只介绍一些常用的：

##### 关于命令的变量

AR：函数库打包程序，默认命令是ar

AS：汇编语言编译程序，默认命令是as

CC：C语言编译程序，默认命令是cc

CXX：C++语言编译程序，默认命令是g++

RM：删除文件命令，默认命令是rm -f

##### 关于参数的变量

ARFLAGS：AR打包命令使用的参数，默认为rv

ASFLAGS：汇编语言编译器参数

CFLAGS：C语言编译器的参数

CXXFLAGS：C++语言编译器参数

在makefile中，你可以使用一个模式规则来定义一个隐含规则。在规则中，在目标的定义中需要有%字符，它代表了多个或一个字符，而依赖目标中也可以使用%，只不过这个%的值取决于其目标。比如：

```
%.o: %.c
$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@
```

在这个规则中出现了两个很奇怪的符号变量，在makefile中这个称为自动化变量。为什么要使用自动化变量，因为在使用模式规则时都需要使用一系列的文件，那需要书写命令来完成从不同的依赖文件生成相应的目标，因为在每一次模式规则解析时都是不同的目标和依赖文件。自动化变量就是用来做这个的，它把模式中定义的一系列文件自动地挨个取出。目前经常看到的如下：

$@：目标文件集合

$%：函数库文件中，表示规则中的目标成员名

$<：依赖目标中的第一个目标的名字，如果是在模式规则中，那么这是将符合模式的一系列文件取出

$?：所有比目标新的依赖目标的集合

$^：所有依赖目标的集合

这里还要提一下后缀规则，这是一种老式定义隐含规则的方法。后缀规则中有两种方式：单后缀和双后缀。双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如".c.o" 相当于"%o : %c"。单后缀规则只定义一个后缀，也就是源文件的后缀。如".c"相当于 "% :%.c"。

最后需要了解以下在make中的隐含规则搜索算法：我们假设目标是T

1. T的目录部分会被抽出，记作D，剩余部分叫N。比如a/b.c  D=a/，N=b.c
2. 创建匹配T或者N的模式规则列表。
3. 如果模式规则列表中有%，那么从列表中移除其他的模式
4. 移除列表中没有命令的规则
5. 对于第一个模式规则，推导其茎部分S，S是T或者N中匹配于%的部分。然后把依赖文件中的%换成S，然后尝试把D放上，测试该文件是否存在。如果存在则退出。
6. 如果不存在则，要是规则终止，则继续下一条模式规则；否则继续计算依赖文件。
7. 如果最终没有隐含条件可以使用，则查看.DEFAULT规则，如果有对应的可用规则，就采用其中的而规则。一旦规则被找到，才会执行命令，此时自动化变量才生成。

