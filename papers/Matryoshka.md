# Matryoshka: Fuzzing Deeply Nested Branches

## Background

这篇文章的研究点在于所谓 Nested Branches。这里就不用再提普通的灰盒测试了，因为灰盒测试的目的是通过随机性来增大代码覆盖率。针对挖掘分支，一般都是和符号执行来进行比较的。但是在这篇论文中提出的观点里，符号执行得到的一些种子并不一定完全是对的，它受限于当前使用符号执行的方法都是借助了全局记录的符号状态来解析出解来的(这一点在后面的 Discussion 中会思考)。

那么所谓的 Nested Branches，是指比如某个 if 语句藏在了其他的 if 类型的语句中形成了嵌套。那么如果想挖掘深层的分支语句就要保证两个条件：

* 可达性：保证生成的种子一定能到达深层分支；
* 可满足性：深层分支的条件是可以被满足的。

并且可达性在任何情况下都应该优于可满足性，符号执行解析出来的种子总会由于为了满足可满足性而舍弃了可达性。

那么现在的这些 fuzzer 所做的工作一般是按照如下的过程：

1. 通过污点追踪的方法来识别影响到分支选择的字节；
2. 决定怎么修改输入；
3. 执行这个修改然后验证是否出发了对应的分支；

## Overview

作者设计的方法就是针对这个特殊情况的，在分析这种嵌套的分支结构的时候需要考虑一下三点：

1. 确定分支结构中的控制流依赖，作者把这个所谓的控制流依赖称为**先序条件**；
2. 确定分支结构中的污点流依赖，作者把这个称为**有效先序条件**；
3. 解析限制；

## Detail

### 控制流依赖

由于这一步的做法是为了保证种子的可达性，所以作者想要把当前分支 s 的先序分支找出来。

>设 r 是 s 的直接先序分支，意思是 r 和 s 中间没有其他的分支，那么如果 t 和 r也是这个关系，那么 t 就是 s 的先序条件。

根据上面的推论，那么作者思考如下两种递进的情况：

#### 函数内的先序分支

函数内的先序分支需要首先确定了目标分支 s，然后从 s 回退，如果找到的某个分支满足一下条件的第一个分支 r：

* 它和 s 在同一个函数内；
* s 没有后置支配 r；

> 后置支配的意思是从 s 继续执行无论如何都会执行 r

#### 函数间的先序分支

直接使用 LLVM 中的函数并不能实现这个功能。作者重新设计了一下方法：

1. 首先 r 和 s 在不同的函数中；
2. 当 s 执行的时候，fr 也在栈中；
3. 假设 rc 是 fr 最后执行的指令，如果 rc 没有后置支配 r，则 r 是 s的先序条件。

作者还分析了一种特殊情况，是有关处理异常流的，它规定异常流朝上的都可以作为先序条件。

### 污点流控制

在这里要讲解怎么确定有效先序条件。我们现在手上已经拿到了分支 s 的先序条件集合 ps 。现在我们假设 bs 代表的是想要进入分支 s 的输入字节情况，那么保证一点，s 是可达的，所以我们一定不能修改在 b(ps) 中的字节。

那么这里作者就提出了有效先序条件的概念。有效的意思是，只有这个进入这个分支的输入和进入 s 的有关，则是有效的。它主要包含了一下这个思想：如果 r 是 s 的一个有效先序条件，q 是 s 的先序条件并且，q 和 r 有相同的字节，则 q 也是 s 有效先序。

### 解析

这一步需要做的是确定哪一个字节需要被修改，针对这个问题，作者提出了三种方案：

* 可达性优先
* 可满足性优先
* 兼顾两者

#### 可达性优先

这种方法属于悲观方法。这种方法的思想主要是，如果我们简单地修改了那些在有效先序分支中输入的某些字节，则可能导致分支不可达。所以优先修改的是 b(s) \ b(e(s))，也就是流入该分支的输入变量中去掉了存在有效优先分支中的。

但是这种情况有一个弊端，就是可能出现误判，也就是在实际有修改对策的情况下无法进行修改。

#### 可满足性优先

这是一种乐观的修改方法。这种方法中有两个阶段，一个是前向阶段，一个是后退阶段。

前向阶段中，它会人为控制住所有前向条件，然后修改流入 s 的字节(b(s))，如果说无法找到合适的修改手段执行 s 分支。那么就进入了后退阶段。

后退阶段中，你会发现你已经无法修改 b(s) 中的值或者在 r 以后的 s 的所有有效先序分支中的相关输入，因为这个相当于已经确认了后续的分支的可达性，所以需要尝试修改其他输入。

这种方法也会出现误判，比如在强行满足后续分支的条件时，无法修改先序的分支。

#### 兼顾两者

也就是说在这个方法中，会同时考虑可达性和可满足性两种性质。

那么这里使用的方法几乎和 Angora 里面使用的方法一样，采用的是梯度下降的方法。把目标分支的条件想象成是函数 f(x) <= 0， x 是一系列输入字节的向量，然后从中搜索一个最优解的过程。

### 检测隐含的优先分支

以上能够如此分析的前提，都是发现了优先分析，而这些优先分支都属于是**明确的**，但是实际上存在这一些比如使用了函数指针调用这种方法的 隐含调用方式，那么这是很难检测出来的。

这里为了解决这个问题，提出的方法如下：
我们使用一个输入并且记录下所有这个输入路过的分支，然后修改了输入后再跑一遍，但是需要强迫程序走原来的分支，然后对这个执行序列按时间进行排序，如果不同或者执行序列中出现了为检测到的优先分支，则说明存在隐含序列。

## Evaluation

在 LAVA-M 上测试和在 13 个开源软件上测试都很优秀。

性能上面也很不错，和符号执行比起来也很出色。

## Discussion

其实在这篇论文中本身提出了很多讨论点，比如一些本来就无法满足的限制条件，由于外部库的引入导致污点流失踪，程序在执行过程中意外的崩溃，程序复杂性导致算法执行效率下降，无法解决分支依赖分支的情况等等。

那么它这边给出的解释是因为对于这个分支信息的分析是和 AFL 一样属于粗粒度的，所以许多问题可能无法分析全面。并且目前只对开源软件有用。

那么这里分析了这篇论文，其实我有理由相信这篇论文大概率就是在 Angora 的基础上写的。因为这里面包括源代码，以及实现方法上很多都来自 Angora。并且由于 Angora 已经十分在测试集上面表现十分优秀了，这篇文章在 Angora 的基础上，对分支的状态细节又进行了优化，这样给人的感觉必然是更加好了。

但是不知道这篇论文的思想是不是真的有用，因为这么思考还是有局限性的，毕竟这个做的点在其他工具的基础上相当于多走了一步。

这篇文章中一个点是要确认的，就是符号执行中对状态的保存是否真的是全局的，这个是值得确认的。

