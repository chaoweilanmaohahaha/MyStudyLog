# QSYM: A Practical Concolic Execution Engine Tailored for Hybrid Fuzzing

###### **Background**

传统的Fuzzing，模糊测试存在的问题是它通过输入进行变化然后测试，很容易能够通过一些有着简单判断的分支，但是很难通过一些复杂判断的分支。

传统的Concolic execution可以判断比较复杂的执行分支，但是自身却包含了许多的问题，其中包括了路径爆炸等问题，在这里的最后会谈一下符号执行的一些问题。

那么后来产生的hybrid fuzzing的方法，就是将符号执行和fuzzing结合，让符号执行的方法去探测比较复杂的分支的情况，用fuzzing能够做到更快的测试。

但是问题混合测试的问题主要出在在对于现实生活中真实的软件进行测试时，符号执行的限制降低了fuzzer的性能。本文就考虑怎样可以加快符号执行的方法，来提高fuzzer的整体的性能。

###### Motivation

作者主要思考了符号执行的性能瓶颈在哪里：

* 进行符号模拟很慢：

  首先进行符号模拟的前提是，是会将源程序生成中间表示（IR），这种做法的好处是实现起来十分方便，因为一般都有现成的转换技术比如使用llvm-IR。简单的说如果我们将代码直接翻译成机器指令，那么现如今的机器指令已经达到了大约1700多条，这时相当难以处理的。而IR所生成的指令就很有限，而且生成之后的格式和汇编也很类似。

  但是使用IR的问题在于，本来可能只需要生成一两个指令的，经过IR变化之后生成了更多的指令，比如文中提到的使用了VEX IR后会生成4.69倍多的指令。

  作者提出如果使用IR，则也阻碍了优化，特别是因为在进行IR翻译的时候，通常缓存了代码块而不是指令。

* 使用了快照技术：

  为什么使用快照技术？假设在一次执行中，遇到了一个分支后需要执行另一个分支的情况了，使用快照技术可以不重复执行所有的程序，而是直接从当前分支处的另一个分支继续执行。目的就是复用当前探索的状态。

  但是对于混合测试来说，符号执行是从fuzzer那里获取了大量不同的输入，而这些输入可能导致了前面并没有共享相同的分支，这样就没有必要进行快照技术了。

  快照技术不是很支持维持外部状态，程序在执行的过程中会更多的和外部的环境进行交互，那么在真正程序执行时是由内核保持着这种状态的。但是对于符号执行来说它需要自己来维护。

* 符号执行完备的分析方式：

  符号执行可以保证完备，因为它们会去检测所有的限制。

  但是很多情况下要进行完整的检测，需要花费很多精力，特别是对于复杂的，比如加密算法，压缩等。

  并且针对符号执行的策略，这种限制可能是过拟合的。比如一个例子就是一段程序在上下中出现了彼此矛盾的执行流，则此时符号执行会认为它是不能继续运行的。



###### Design

QSYM总体的架构如下：
QSYM会让目标程序和测试用例跑在一个DBT：二进制动态转换程序（只关注程序真正执行的地方）上，这个东西可以消除基本块。然后QSYM将执行结果交给instrument-level 执行器，有必要的话会配合concrete environmnent 模型，然后还有就是使用了消除了无关限制的技术，并且优化了解决方案，最后会产生新的测试用例给fuzzer。



###### Detail

**Instrument-level execution**：意思是说对于一个代码块的指令，QSYM并不会完整地执行，而是只通过几句指令生成约束。并且这里也强调了QSYM使用了DBT后可以让本地代码和符号执行运行在同一个进程中。

**Solving only relevant constraints**：其他的符号执行工具会使用增量式的方式去计算约束。它们使用之前的执行来解决这次运行所产生的约束。但是对于混合式的测试工具而言，它并不需要符号执行去生成很多的用例，而是由fuzzer提供很多用例来执行，这样对于符号执行而言会去重复的生成一些约束，这里可以就是用以前的使用的测试用例就行了，这也是去掉不相关的约束的一个方法。另外，增量式的方法需要使用完整的约束，但是实际上在解决某些约束的时候，并不需要完整的约束，只需要部分的就行了。

**preferring re-execution to snapshoting**：作者认为，因为QSYM的执行非常快，所以无须缓存运行时的快照。

**concrete external environment**： QSYM使用真实的一个外部执行环境，它将外部环境整体看成一个黑盒，这样只需要给调用外部环境的代码一个输入，获取它的输出就可以了。

**Optimistic Solving**：首先我们知道一点，在符号执行中有一个叫做**符号解析器**的东西，这个东西是专门给fuzzer跳过一些比较繁琐的判断的。为了解决上面提到的一个过拟合的问题，在QSYM中使用了最后一次执行路径上生成的约束条件。所以QSYM会消除那些和最后一次执行路径上生成的约束条件无关的那些约束。

**Prune basic block**：在生成约束的过程中，可能会遇到那些繁琐的需要重复性计算的代码块，这些代码块一般很难生成想要的约束，那么这时我们需要丢弃这些代码块，或者只是生成这些代码块的一个约束子集。



###### Evaluation

首先作者使用了QSYM和现在的一些fuzzer进行比较，去测试一些并不是十分繁琐的程序，然后可以发现QSYM的性能要比其他的fuzzer好很多。并且有很多的fuzzer并不能真正的适配许多程序。

代码覆盖方面，作者是将QSYM和AFL进行了比较，发现代码覆盖方面明显由于AFL。

在符号执行的速度方面，作者使用了QSYM和Driller进行对比，在执行固定的时间中，比较两者的代码覆盖率，比较的方式就是使用了各自生成的bitmap。

约束优化方面作者也是用了QSYM和其他的一些fuzzer进行对比，发现可以发现更多的bug。

重复代码块消除方面也是得到了很好的改善。

###### **Discussion**

1. 作者认为他提出的这些方法中，有很多的方法都是可以由其他符号执行方式借鉴的，这是一个通用的办法。
2. 并且他认为其他的fuzzer也是有许多指的借鉴的地方，可以将他们的长处加进来。
3. QSYM这个工具还是具有一定的限制，首先就是它还是会受到符号执行的限制，并且现在的QSYM还是一个受到架构限制的一个执行器，未来需要使得它对于架构来说是独立的，同时目前的QSYM可以处理的指令还是有限，未来需要继续扩充。

---

## Appendix： Concolic Executor

符号执行的本质是如果我们把输入看成一个变量，那么经过执行后就会得到一个输入所对应的一个函数关系。意思是通常程序的执行伴随着一系列的true和false的分支，那么当一个分支上的条件是true时就可以执行某一个分支，而false的时候就会执行另一个分支。

那么根据这个过程，很容易可以将整个代码的样式想象成是一棵树。那么自然就有了很多所谓的执行路径。现在符号执行的目标就是：**找到输出能够走遍所有的分支。**

OK，我们现在定义一下几个变量。符号执行会维护这样两个变量：a集合用来保存某个变量到值的一个映射关系，P保存路径上的约束关系。现在以一个例子来看一下这两个变量在符号执行过程中是怎么使用的：

```
int twice(int v) {
	return 2*v;
}
void test(int x, int y) {
    z = twice(y);
    if(z == x) {
        if(x > y+10) {
            ERROR;
        }
    }
} 
int main() {
	int x = input();
	int y = input();
	test(x, y);
    return 0;
}
```

在这个程序中我们假设用户的输入是1和2，那么过程是怎么执行的呢？首先程序遇到了一个输入语句，自然生成了映射var --> s，比如我可以获得两个映射对x-->x1, y-->y1。 然后我们继续执行，会遇到一个新的赋值语句，此时生成了一个新的变量，也就插入了一个新的映射对 z-->2*y1。现在开始遇到条件判断语句了，此时势必出现分支情况，那么对于一个当前状态P，它会建立一个当前路径P^e和一个分叉路径P^-e。此时如果某一个状态是可以满足的，那么就会赋予变量一些实际的值继续执行。如果出现了exit或者error句柄，那么就退出当前的状态，并且由状态解析器生成可执行的测试输入。

其实以上就是符号执行的整体思想了，那么真正的符号执行所做的工作呢？用户在使用符号执行的时候会给一个初始的输入，使用这个输入，符号执行会实际的与符号的执行程序。实际的执行是在探索分支路径，如果路径出现分支，那么就会生成一个有着相反条件的分支。然后继续探索直到最后使用解析器计算出一组可能的输入。

最后讲讲符号执行的问题所在：

**路径的选择：**程序足够的大，势必会使分支足够的多。怎样给出一个路径选择的策略能够尽可能使用较少的资源和时间探索更多的路径。

**约束的求解：**通常约束的求解采用增量式求解模型。这个方法也是为了重用重复的分支情况。这样会对路径的约束有一定的缓存。要清楚的一点是约束求解可以说依旧是符号分析的一个瓶颈。

**内存建模：**如果使用了一些指向内存单元地址的值，那么符号执行会把他当作是普通的表达式。并且有很多内存指向都是用别名的方式，所以十分复杂。

**并发处理**

我们在fuzzer里以KLEE这个工具来查看符号执行的更具体的使用。