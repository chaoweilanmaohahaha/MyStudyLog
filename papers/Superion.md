# Superion: Grammar-Aware Greybox Fuzzing

## Background

这篇文章的问题背景是针对结构化的输入提出的，而作者所提出的工具是建立在 AFL 的基础上拓展的。AFL 是一个比较有名的 Fuzz 工具了，但是它的机制使得它在 Fuzz 一些输入非结构化的程序的时候看上去更有效一些(比如输入是图片)，如果遇到输入是 XML 或者 JS 这样的结构化文件就会显得比较低效。

为什么会有上面的问题，这和 AFL 本身的机制有关。在 AFL 的裁剪输入(trim)和修改输入(mutate)两个步骤中，它都是执行和语法无关的操作，这样导致输入的结构会被破坏，因此像输入为 XML 这样的需要被解析的可能在解析这一步就通不过了。

本文针对这一点，思考如何借助语法来提升 AFL 对于结构化输入的 Fuzz 效率。

> 在这里要补充一下，关于 AFL 的修改机制就不用多说了，关键是它的裁剪机制。其实这本身也是 AFL 的一个优化。对于一个输入，AFL 会先对其进行分片，然后查看每个分片对最后的代码覆盖率是否有影响，如果没有影响就说明这个分片是没用的，可以直接删去

## Overview

作者提出的 Superior 的工作流程在原本 AFL 的工作流程上加上了语法的支持，也就是在每次对输入进行裁剪和修改的时候考虑语法，所以总的执行流程是类似的。为了加入语法的干涉，作者因此提出了一种语法相关的裁剪策略和两种语法相关的修改策略。

## Detail

### 裁剪策略

首先使用 ANTLR 对输入进行语法分析，生成输入的抽象语法树。那么在裁剪的过程中，从根开始对没个子树进行分析，如果在裁剪完该子树对代码覆盖有影响则递归地分析子树的各棵子树，否则如果对代码覆盖没有影响，则可以直接删除该子树。

### 修改策略

#### 基于字典的修改

> 这里又要补充一下，在 AFL 众多的修改策略中其中之一就是基于字典。简单的说就是使用一些给定的关键字替换或者插入到源程序中。

AFL 的基于字典的修改的一大问题是语法无关，盲目的修改会破坏语句的意思或者是表达式的意思，这样输入的结构依然会被破坏。

本文的方法就是需要保证两点：

* 插入时必须插入在语句的边界处，即要么在开头和末尾，要么一定插在两个表达式或者符号的中间。
* 替换时必须替换的是两个边界直接的表达式。

#### 基于语法树的修改

这个的目的是对于被修改的输入 input，从输入队列中找到另一个输入 pro，解析两个抽象语法树并将它们的每棵子树都放入一个子树池中。对于解析下来的 input 树，每棵子树都可以用子树池中的子树替换。

在这里为了保证 Fuzz 的效率，对一些参数进行了限制：

* 限制了输入的大小
* 限制了修改的次数
* 限制了子树的大小

## Evaluation

作者为了测试该工具的性能，对 XML 的库libplist 和 JS 的引擎进行了实验，和 AFL与jsfunfuzz 比较，设计了五个问题：

* 工具发现bug的效率(好)
* 代码覆盖率(并不优秀，也就是说这个方法并没有在实质上提高代码覆盖率)
* 裁剪的效率(正确性提高)
* 修改的效率(正确性提高)
* 工具的额外花费(可接受，这个和输入大小有关，主要是三部分：解析、修改和执行)

## Discussion

这篇文章其实就是在某种意义上保证了 AFL 输入的正确性，这样使得 AFL 在操作的过程中去掉不必要的一些操作。在这个层面上提高了 AFL 的性能。

但是仔细分析可以知道并没有在实质上帮助到 AFL，首先在自己的操作流程中，文中并没有比较详细的谈到替换的过程中可能发生的一些比如参数名不同导致的一些语义错误，这应该也要被考虑到。

那么仔细分析实验不难发现，可能效率是提高了，但是其实有关覆盖率并没有提高，原因可能还是对于整个 Fuzz 的流程上并没有进行太大的修改，所以没有影响到覆盖率。

当然文中给出了一个问题还是语法的依赖性，对于语法缺失的一些语言就很难使用这种方法去测试了。