# GRIMOIRE:  Synthesizing Structure while Fuzzing

## Background

这篇论文的一个背景是针对结构化的输入会对当前的 fuzz 技术造成很大难题的问题上。在很多论文中已经提到过，简单的灰盒测试很难客服这个问题，因为大部分情况下目标程序可能需要执行类似解析输入这样的步骤，那么灰盒测试就很难通过类似的步骤了。

这篇文章写的十分具体，在背景上可以说也写的十分详细。作者针对这个困难，对当前的五类不同类型的 fuzzer 进行了分析。

* blind fuzzer：盲目地进行种子变换的 fuzzer 其实是最为初始也是最为低效的，因为它们只是使用一些变换手段随机改变输入，但是没有任何的依据，所以更不用说是结构化的了。当然最初的盲目测试工具也会借助语法来通过一些手段随机构造符合语法的输入，但是缺少了一些 fuzzer 内部信息的支持，这些种子并不会非常优质。
* Coverage-guided Fuzzing：老生常谈 AFL，在最初的基础上，加上了使用代码覆盖率作为指标，来说明这个种子的好坏，对生成的种子有了一定的指向。但是这个问题也是老生常谈，那就是面对一些复杂分支，它力不从心。
* Hybrid Fuzzing：针对解决上面的问题，使用一些代码分析的手段确实有效。但是符号执行除了一直有的开销问题之外，面对类似代码文件这种高度结构化的输入仍然不能很好地推断出输入。
* Coverage-guided Grammar Fuzzing：为了克服复杂的类似编译器解释器这种程序，研究者决定借助语法文件，并且有了语法文件的支持，在做种子修改上也使用了**规模更大一点的修改策略**。但是问题就是它需要精确的格式文件指定语法。
* Grammar Inference：为了避免使用语法文件，还有的研究就转向了能否从程序中推断出语法来。

本篇文章着眼于不使用类似语法文件的帮助，也不适用类似语法推断的方法，直接通过修改策略，依旧能生成合法的输入种子，使 fuzz 能够高效。

### Details

为什么这边没有一个 Overview，因为这个工具本身借助已有的 REDQUEEN，所以整体的架构和 REDQUEEN 十分类似。

GRIMOIRE 的本质就是不想使用语法文件的依赖做到大规模地修改输入文件，而这些修改又是尽可能符合目标语言的语法的。

因此 GRIMOIRE 相当于在输入处存放了一个插件，而这个插件用来识别并且重组输入。在每一个句子中引入了一个 gap 的概念，所谓的 gap 就是作者认为**一个语句中可以被替换的地方，而这个替换不会影响到原来的覆盖率的地方。**

首先我们需要知道，一般这种种子修改，都需要一个所谓代码池的概念，使用其中的样本来对原本输入修改。在本工具中将这样的代码池分为两个不同的部分： generalization 和 substrings。在生成时，要根据不同步长删除语句中元素，这样执行后如果覆盖率没变，就可以将这个语句替换成 gap。当然为了简化，还需要根据**匹配括号**来快速得到 gap。**generalization 指的就是存有 gap 的语句；substrings 是 generalization 根据每个 gap 切割后得到的子串。**

而本文着重于阐述组合输入的方法，来生成新的输入。文中一共提出了三种修改手段：**输入扩展、递归替代和字符串替代。**前两者是在 generalization 上修改的，而后者是在源输入上修改的。

* 输入扩展：当前的输入进行 generalize 的过程，得到一个 generalization，随后随机从代码池中获取一个代码串，然后拼接输入的 generalization 的前面和后面。
* 递归替换：用代码串池中的代码串替换输入的代码串的 generalization 中的 gap。但是要注意的是对于每一个 generalization 还需要做一个扩展，在前后都拓展一个 gap。
* 字符串替换：在原本的输入上，使用预先设置的字典中的字符串，直接替换输入中的部分字符串。

## Evaluation

### 和当前的工具比较

和 AFL，QSYM，ANGORA 和 REDQUEEN 作对比。在选取的这些目标程序上，GRIMOIRE 基本上都表现得更好，唯一得例外可能是一些输入能够支持字节码的程序这是 GRIMOIRE 不擅长的。

### 和 Grammar-based 比较

因为有了语法文件的支持，所以理论上这类测试工具的效果应该比 GRIMOIRE 的效果更好。事实上确实是如此。但是为了证明 GRIMORE 的 fuzz 修改策略的效果，作者把 NAUTILUS （一种 Grammar-based 测试程序）的输入放入到 GRIMOIRE 中，然后发现此时 GRIMOIRE 有了更好的执行效果。

### 和 Grammar Inference 技术比较

和这列技术做对比发现 GRIMOIRE 在任意一个例子上都更优，并且实际上当前的 Grammar Inference 技术并不能很好生成合法的输入。

### 修改策略

 作者将自己设计的修改策略和以前的策略进行对比，从生成输入的角度来看显示出了更好的性能。

## Discussion

作者提出了这个工具中存在的几个问题，包括对于一些更复杂的语义结构，比如 XML 的标签。需要针对这样的标签提出一个新的修改手段。

第二点是作者认为他的替换算法还是比较粗粒度的，考虑更加细粒度的字节级别修改，但是这样和那些有语法支持的和使用语法推断技术的就很类似了。

