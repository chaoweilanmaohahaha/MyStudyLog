# NAUTILUS: Fishing for Deep Bugs with Grammars

## Background

这篇论文的的背景不用多说，是基于 Grammar 的一款 fuzzing 工具。那些已经说过的内容就没必要重复说了，只需要提一嘴，那就是原本的盲目 fuzz，灰盒 fuzz 和基于代码分析技术的 fuzz 都存在多多少少的缺陷。像针对**解释器**这种目标程序，最好的办法就是使用语法进行引导，这篇文章也是这种思路，但是很奇怪的是，这篇文章提出的方法其实和之前的文章提出的有着很类似的地方，可能是当年投稿的时候大家投的地方不同，时间不同吧。

这篇文章中给我们复习了一下编译原理中的一些知识点：

> 大部分的语言都可以用上下文无关文法表示，这也是之所以 Grammar based 测试工具可以使用的原因。
>
> 所谓上下文无关文法包括了一系列产生式规则，是由一个非终结符推导出一系列非终结符或者终结量。它包含了四个量：一系列非终结符，一系列终结符，一系列产生式规则和一个起始规则。
>
> 之所以是上下文无关的，是因为规则左边一般就是一个非终结符，和上下位没有关系。你可以看到下面对 XML 语法的分析，有时他就不是上下文无关的了。

## Challenge

* 生成的种子文件必须是合乎语法和语义的；
* 依赖于初始的种子池，大部分都是依赖于程序自带的一些测试用例；
* 高的覆盖率
* 好的性能

## Overview

这里分析一下 NAUTILUS 的架构。首先一个源程序依旧需要通过特殊的编译，插桩的过程生成可执行的二进制文件；随后需要将现成的语法文件解析；通过输入构造模块生成种子，交给**调度器**赋给程序；程序执行后通过**剪枝**，插入到输入队列中；执行后根据**反馈**，触发修改器对输入进行修改，再插回队列中，然后赋给调度器。

## Details

### 代码生成

代码的生成需要想办法生成尽可能多又不同的种子。注意对于一个非终结符进行推导，总会有很多种不同的推导规则，为了生成怎样选择产生式规则也是很重要的。这里作者提出两种方法：

* 简单生成：随机挑选规则，但是这种做法很有可能生成非常类似的结构；所以最好有一种方法可以避免使用最近使用过的规则。
* 规范生成：使用了一个现成的算法 **McKenzie**。你可以认为这个算法的输入就是一个三元组(n, l, r)，其中 r 是初始规则，l 是迭代长度，n 是需要生成语句的非终结符。这种方法可以弥补简单生成的一些问题，具体算法要参考 McKenzie。

### 代码剪枝

这一步是在执行完后将输入插入到输入队列时需要做的。当一个感兴趣的输入产生时，它需要构造出一个比较短的输入，并且保留所有触发新分支的地点。作者同样提出了两种方法：

* 子树剪枝：目的是让子树尽可能短，所以需要把所有的子树尽可能地缩短，来查看是否触发相同的路径。
* 递归剪枝：这一步是剔除代码中的多余的递归结构或者是循环结构，让循环结构只执行一次。

### 代码修改

这里也使用了多种不同的代码修改方法：

* 随机修改：挑选代码树中的任意一个节点用和该节点对应的非终结符生成的子树替代。
* 规则修改(这一点还要确认)：将输入中的每一个节点都替换成所有其他可能的规则生成的子树。
* 随机递归修改：将一个节点的一棵子树递归构造 2 的 n 次方次，构造出一个迭代的结构。
* 拼接修改：将当前的树上合适的节点和其他的树上的相同的节点作替换。
* AFL 修改：就直接用 AFL 的暴力修改，使用位反转和算数替换。当然 AFL 中也提供了**字符串的替换**，一旦使用这种方法产生了新的终结子串，那么就可以将这个规则加入到自定义规则中。

### 回到字符串

这一步就是将树结构退还到字符串结构。但是很多的现实的语言可能出现上下文无关文法无法处理的结构。比如 XML，所以需要使用自定义脚本，来弥补缺陷。

### 实现

其实真正实现的时候，作者还对种子在不同的处理阶段，赋予了不同的**状态**。

> init --> det --> detafl --> random

## Evaluation

这一部分先跳过，总的来说作者的实验证明性能很好。

## Discussion

作者实现使用 Rust 语言来实现的，所以我无法对这个工具进行分析，因为不熟悉 Rust 语言，所以就拿这个方案，复原一个工具，那么看来要更加细节分析一下 AFL 这个工具了。





