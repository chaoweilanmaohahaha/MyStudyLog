# MongoDB's JavaScript Fuzzer

其实这篇论文使用的方法和其他相关的介绍 Fuzzer 的论文非常类似，但是由于针对的测试目标非常特殊，所以还是值得记录一下。

## Background

这篇文章中我们要测试的是 MongoDB 数据库，首先要说的一个前提，当然目前对这个数据库也并不是十分熟悉。这个数据库存在一个基于 JS 语言编写的一个应用接口。用户可以在这样的接口中使用 JS 编写的命令来完成对数据库的增删改查，而本文就是建立在应用这样的接口上。

在这类作者讲到了一些背景：Generation-Based Fuzzer 和 Mutation-Based Fuzzer。那么这两个类型的测试工具究竟是啥也不用详细说明了，而我们就直接去讨论这个工具是如何设计的(**无源代码**)。

## Details

作者的想法是要将 Generation 和 Mutation 两者结合起来，使得能够生成合法的命令代码，这个想法也是基于不想让 Fuzzer 陷在验证指令正确性这一部分的代码中，而能够更好地去挖掘深层的代码。

### Generation

这一步一直以来都是为了**跳过代码正确性**，因为使用 Generation 的方法一般都是符合代码语法结构的，它会应用到语法文件。

那么在这里比较特殊，MongoDB 命令行的语言并没有详细的语法，那么作者在这里使用以往使用的一些测试集，使用这些测试集来生成合适的指令。

具体的实现很简单，它也要借助于 ANTLR 这个工具，将测试集解析为抽象语法树，然后对树上的某些节点进行替换，生成新的抽象语法树。(*这里把这个称为生成式的，和其他论文有点区别*)。

```
db.coll.find({x:1}) ---> db.coll.find({x:{$regex:'ab'}})
```

这里的细节在于它会将可能要被修改的这些节点用占位符替换，并且会将某些值或者字符串记录下来用来代替别的节点。(这里的实现还有一个小细节，就是在替换的之前先一步预计哪些类型的节点可能引起漏洞)

### Mutation

Mutation 的使用的目的是为了能够测试到更多的程序功能，**帮助生成多样的和非平凡的种子代码**。这里因为考虑到语义的问题，所以需要预先将一些值和命令存在一个全局列表里，在 Mutation 时这些值会保证修改完的代码有一定的正确性。

一般的一个想法就是使用一个指令模板，比如文中提到的：

```
{a:X, b:Y, c:Z}
```

其中小写字母代表命令，大写字母代表数据。那么简单的想法我们随机修改模板上的命令和数据。但是这样不能保证正确性，很可能都是一些不正确的命令。

### Hybrid

那么一种理想的想法是，将 Generation 和 Mutation 的想法结合。用生成的方式去构造原始的抽象语法树，然后借助 Mutation 的方法，去随机性替换某些数据。

#### Noices

一下的部分可能有一点偏差，先按照目前我的理解来写：
如果按照以上的方法构造代码，会带来一些细节问题：

首先如果在代码中有类似 While 等等循环的语句，在随机地修改之后很容易让执行停顿或者陷入死循环。比如生成了：

```
while(true)
```

其次如果在执行的指令中出现了 assert 命令，则用户层面的命令行将会执行中断，影响真正的使用。

针对这两个问题，作者的解决方案分别是移除所有结构化代码块比如 try/catch、do/while，并使用一些静态的结构。另外对于 assertion 语句在外面包装一层 try/catch 称述语句。

### Bug Detect

现在我们把所有的 assertion 都包装起来了，那么我们要如何获取到其中检测到的 bug 呢？针对这个问题，作者分了两个层面的漏洞。

如果说是检测一些类似于段错误、内存泄露和未定义的行为等等，那么可以使用现成的一些工具比如：address sanitizer 和 undefined behaviour sanitizer。

如果说检测的是逻辑错误就没有现成的工具来帮助检测了，那么目前使用的方法是利用系统内部的一些 assertion 来判断是否出现了逻辑问题，如果数据库因为触发了某个 assertion 而造成的停机(这里我没遇到过，所以不是很清楚这个和之前提到的 assertion 有什么区别)。

### Triage Failure

最后一步，我们要确认触发的漏洞究竟是由什么原因造成的。**这个情况并不是十分好判断因为当前触发漏洞的位置可能涉及前面一连串的状态。**

那么本文中希望能够确认一个最小的范围，这个范围内会触发相应的 Failure，这也方便重现这个 Failure。那么其中只能使用日志 log 的方法去缩小范围。方法和数据库里实现 log 的方法十分类似。

作者让运行分别切割成多个事件区间，每个时间区间内会打印一些 log 信息，方便知道是哪个部分被执行了。当我们收到了一个 Failure 信息，我们就去找最后一次成功的 log 信息。那么下一个时间区间内执行的就是触发 Failure 的场所。

但是光光是这样还是很难找到有上下文依赖的那些命令。所以作者又提出了一种广度优先的二分搜索算法，目的是二分查找所有执行的而命令，来确认 Failure 的场所。

**不过就作者的意思而言，这个 Failure 定位的问题，确实是一个比较难处理的问题。**