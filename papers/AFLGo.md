# Directed Greybox Fuzzing

## Background

这篇文章介绍的是一种称为**指向性灰盒测试**。问题主要针对的是当下的一些灰盒测试工具，这些工具都属于非指向性的，比如 AFL 。它们的特点是对于每一块代码的测试基本上是随机的并且概率是平均的。

但是在日常生活中可能对于模糊测试会有这样的需求：

* 补丁测试：如果只是给某个软件打了一个补丁，就添加了部分功能，但是整体的程序没有太大变动。那么我希望在没有测试数据的情况下测试新添加的功能。
* 崩溃现场重现：崩溃的记录中可能包含了堆栈信息，它记录了调用栈信息，但是它由于隐私问题不能提供输入，所以需要测试出崩溃数据。
* 静态分析报告的验证：可能一个静态分析工具报告了一个危险可能性很高的代码区域，那么就可以使用该工具来验证在该区域是否真的有安全漏洞。
* 信息流的检测：可以通过这个来测试是否有一个敏感源会使得信息泄露。

这些需求都要求这个测试框架要有指向性地测试目标代码。先前的方法(比如工具 KATCH )使用了符号执行的引擎来进行测试的，但是这样做就使得执行效率大大降低，原因是如果引入了符号执行，那么在每一次执行的过程中都需要对执行到的代码块分析，并且更新状态，然后通过内在的 SMT 解析器解析。

作者在这篇文章中所设计的方法，就是希望能不在符号执行的帮助下进行测试。

## Overview

那么作者设计的 AFLGo 工具也要借助一下代码静态分析，但是这样的分析基本只出现在了编译阶段，需要计算作者提出的函数调用之间的距离和代码块之间的距离。而因为已经预先计算好了相关的距离，那么可以计算出这个种子到目标函数的距离，这样就知道反馈生成的种子哪一个离目标函数更近，通过 power schedule 技术，类似可以给这样的种子更多的调度，这样就更加快地接近目标函数。

我们先熟悉一下普通的灰盒测试的流程，首先从种子池中选取一个种子，然后对种子进行修改，如果是一个感兴趣的种子就加回到输入队列中。而 AFLGo 在选取种子后添加了一个给种子分配“调度能量” p，然后让种子能够执行 p 次。

## Details

### 距离计算

这一步可以说是对整个程序的一个预处理。首先可以保证的是目标函数和目标块可以从给定的源程序中识别。

首先要计算的是**函数调用级别的距离**。对于每一个函数调用来说，作者使用调和平均数的算法计算距离，如果当前函数调用无法到达目标函数，则距离是 undefined，否则一个函数调用的到达所有目标函数的距离为到所有目标节点距离调和平均数。

有了上面的距离的基础，就可以计算**代码块级别的距离**。代码块复杂的地方在于一个代码块中可能包含了多个目标调用函数，那么因为最后考虑到使用 AFL 的代码覆盖方法，依旧需要计算代码块级别的距离。当当前代码块无法到达目标代码块的时候，距离为0；如果说当前的调用已经在目标的代码块中了，那么只需要从各个当前代码块中含有的调用中挑选一个离目标代码块最近的路径长度；如果是最普通的情况，那么使用相当于使用迪杰斯特拉算法计算路径长度。

最后我们需要定义一个种子到达目标代码块的路径长度了，它相当于是一个平均值，即**种子路过的代码块代表的长度的累加和除以路过代码块的个数。**作者当然在最后还对这个距离进行了正则化的计算。

### 模拟退火调度

这里必须先介绍什么是模拟退火：

> 模拟退火是一种通用概率算法，用来在一个大的搜寻空间内找寻命题的最优解。
>
> 为什么叫模拟退火算法的出发点基于物理中的退火现象和一般组合问题优化之间的相似性。模拟退火算法从某一较高初温出发，伴随温度参数的不断下降，再结合概率突跳性质在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋向于全局最优解。
>
> 模拟退火的过程基本上如下：
>
> 1. 初始化温度、当前的解和当前答案；
> 2. 如果温度小于最终的温度跳转到第七步，否则进入第三步；
> 3. 重复执行 4 - 5 步 L 次
> 4. 由当前的解生成一个临时的新解和新的答案
> 5. 判断是否接收当前这个临时解，如果接收就更新解和答案，否则退回到上一个解
> 6. 降温，然后跳转到第二步；
> 7. 结束

作者的思路对于一个种子来说，它所持有的能量对于它来说是局部的，但是温度这个变量对于所有的种子应该是全局的。如果温度降低到比较接近于 0 了，那么整个算法就和梯度下降类似了。而温度的下降是通过等式 T = T0 * a^k。作者假设温度下降到小于 0.05 停止，则得出了在第 t 次的温度计算为： T = 20 ^(-t/tx)。根据这个，需要计算出分配给每个种子的能量。这个表达式保证了 p 一定在 0 到 1 之间。

但是 AFL 已经实现了它本身的一个种子调度的方法，所以作者希望将他的想法融合到 AFL 中，因此重新计算除了新的每个种子的能量。这个能量保证如果和目标代码块靠的足够近，那么能量就越大；否则能量就越小。

**这里可以再仔细看看，因为这里很难看出它和模拟退火之间的紧密关系。**

## Evaluation

作者的评估实验分成了三个层面来进行的：

### 补丁测试

和目前的 KATCH 这一款专门测试补丁代码的一个工具进行比较，可以发现覆盖到之前未覆盖的代码要比 KATCH 多。但是实验证明，在实验给定的时间内，也并不是所有的之前未覆盖的分支都被覆盖到了。经过分析之后，可以得出：

* 多平台代码或者多架构代码
* 有些代码使用的是寄存器间接跳转
* 破坏了输入的正确性

作者的一个未来工作，还是希望融合一些符号执行的方法来提高一些性能。

漏洞测试方面确实也发现了一些漏洞，比 KATCH 优秀。

### 持续性测试

作者将该工具发布到了 google 的 OSS-Fuzz 平台上进行测试。

### 崩溃重现

作者将这个工具和 AFL 进行了比较，结果发现在一定时间内，该工具重现漏洞的时间比 AFL 快了很多。

相对于符号执行，和一个叫做 BugRedux 进行比较，可以发现能够重现的漏洞也比 BugRedux 发现的多。

