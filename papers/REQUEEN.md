# REDQUEEN: Fuzzing with Input-to-State Correspondence

## Background

这篇文章着眼于符号执行和污点追踪这一块，为什么要只关注这一块呢？理由还是那样。我们为什么要在模糊测试中引入符号执行和污点追踪呢？还是考虑到了黑盒测试的弱点。考虑到许多程序中对输入都会经过一系列的校验和的比较或者和一些magic number的比较等。随机修改参数并不能做到很容易越过这一关，那么就需要符号执行和污点追踪来告诉这个参数到底是个什么样。而这篇文章提出了自己的方法，有点模仿符号执行，但是比符号执行更为简单和高效，能够更容易绕过校验和和魔数的比较。

## Motivation

就像题目所说的，作者提出的是一个所谓Input-to-State Correspondence的方法。程序在很多的情况中输入的一些部分和程序执行的状态是很有关系的，我们只需要使用输入的这些特定的位置，这就是所谓的Input-to-State，具体是怎么判断输入和当前状态的关系的呢，看它的整体的设计。

## Design

在这里作者就分了两种情况，一种是面对魔数的比较应该如何操作，一个是面对校验和应该如何处理。

### magic number

作者的重要的思想是这些所谓的魔数肯定都和输入有关，那么只要在所有比较指令处插入一个钩子，然后再每一次遇到一个对于不同的参数的比较，我们就需要抽取其中的参数然后构造一个修改映射对

```
<pattern ---  repl>
```

#### tracing

首先我们要知道的是具体比较的是输入的哪几位，这样好确定怎么修改输入。比如如果输入比要比较的那个魔数多很多位，我们起码要知道到底哪几位是真正和这个魔数进行比较的。

#### variations

我们要怎么处理大于和小于的比较呢，那么这里作者采用的方法是在原来的输入上进行加减。

#### encodings

在输入的数据真正到达魔数比较的时候，可能对这个输入已经进行了编码，那么为了给出编码后的比较，因此也要对当前的映射进行一次编码（只要对当前已有的映射进行操作就可以了）。那么这样有个问题，我们怎么判断是怎么编码的呢？这里作者通过观察总结了，现在大部分碰到的编码包括了：

* 无符号/符号扩展
* 逆置
* 转换为字符串
* 编码为ascll 等

作者认为在文中给出的这些编码已经是在绝大多数下能碰到的了，那如果还要添加编码的方式，那么让用户自己加上就可以了。

#### application

接下来就可以使用生成的这个映射集合去进行测试了。在其他的实现中，也使用到了这样的集合，但是其他的工具保证在一次测试中只使用一个，而这个工具中在测试的过程中同时考虑所有的选择。

#### colorization

有这样一个问题，在我们想要真的获取比较位置的时候，可能源输入的位数很多，并且可能有许多相同的噪音。比如“ZZZZZZZZZZZ”这种，那么我们就不能一下子确定获取的位置到底在哪，那么这里就需要通过染色的方法去加以确定。思想就是将这个输入的空间中尽可能使用杂乱而又随机的东西先填充，然后再去进行一次抽取，这样就可以确定到底是哪一部分了。

### checksum

那么如何去处理校验和呢？我们思考一下校验和的比较可能会出现一些复杂的情况，可能对于一个输入，会分两步来进行校验和的比对。那么作者的思路是什么呢？其实和其他一些工具一样，它的主要思想也是想办法绕过这个校验和，然后在后期弥补回来。

#### identification

首先我们先要从各个比较指令里面去获取可能是校验和比较的指令。那么作者认为一个疑似校验和比较的指令应该像下面这样：

* 输入的数据应该自始至终使用了相同的编码方式
* 两边的参数都不应该是立即数
* 输入的染色发生了变化

但是这个方法有点过于绝对了，那么就会产生过拟合的现象，所以生成的映射并不一定是对的，需要在后面的验证过程中还要再验证一次。

#### patching

将我们发现的这些疑似校验和比较的那些指令统统改成肯定正确的指令，这样就可以绕过这些指令继续执行。

#### verfication

当我们最终获得了映射对之后，我们就需要让这个输入在没有打过补丁的程序上面跑，如果跑的过程中确实发现了新的分支，则将这个输入最终真的加入到fuzzer的输入队列中。

## Details

首先先说明一下，这一款工具最终实现在了KAFL上。那么在实现的时候有如下的一些细节哦

首先在对比较指令进行hook的时候，需要做的一些事情是编译器遇到一个类似比较的地方就需要进行记录，然后再整整执行的时候就需要从这些记录点就会被打上断点，如果碰到了这样一个记录点，那么参数就会被解析出来并保存在缓冲区中。当然hook的过程中作者并没有只关注cmp指令，同时也关注了一些call和sub指令。

其次在染色上面的具体实现，是通过二分查找的方法去做的，为啥这么是不想破坏afl的按位反转策略。

打补丁的化就是只是将原来比较的指令变成了cmp al, al

最后验证的环节中，我们发现如果说校验和的验证是分了几层的，那么就会有一个比较的顺序在里面。作者在这个里面是使用了拓扑排序的方法去处理这个问题的。

## Evaluation

作者在这个评估中需要考虑如下三个问题：

* 作者提出的这个技术具有普遍性吗？也就是说真的可以适应一系列的目标程序和环境吗？
* 这项技术和以前的符号执行和污点追踪相比结果怎样呢？
* 在对现实的程序进行fuzz的时候是否有什么改进呢？

那么作者在Lava-M上做实验发现比其他的fuzzer发现bug的时间更快，而且发现了更多的bug

在另一个数据集上也更强，在现实的软件上也很强总之，233333



