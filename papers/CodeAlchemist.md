# CodeAlchemist: Semantics-Aware Code Generation to Find Vulnerabilities in JavaScript Engines

###### background

现在在网页上会用到许多JS的元素，因为JS的便捷性。但是这也让JS引擎变成攻击的目标，所以关于JS引擎的漏洞也越来越被关注，这种攻击很有可能会攻破防火墙后的客户机。那么当下的所有的对于JS引擎测试的软件都是关注如何构造在句法正确的测试用例，这个是基于一定的语法或者是一个已经训练出来的语言模型。但是问题就在于，句法正确不代表测试用例是有效的。**也就是说句法正确的句子在语义上并不一定是对的。**JS这个语言还有一个麻烦的地方在于，JS代码是在运行时被构造并且变量类型是动态的。**这里缺少的一个问题是对于攻击者而言到底怎么攻击JS引擎**

那么目前市场上比较好的一些fuzz工具分别是LangFuzz，它需要一份样本JS文件，然后通过分片组合技术构造测试用例。另一个是jsfunfuzz，它是随机构成语义正确的JS语句。但是这两个fuzz工具组成的测试用例都存在语义错误的问题。**主要的问题就是目前的方法语义上很难正确，受困于JS灵活的类型变化。**本文提出的系统沿用了LangFuzz从JS样本文件中提取语句块的特性，然后更加关注了JS测试用例的语义上的正确性，也就是在拼凑的过程中增加了语句块之间的限制。

下面是一些和JS有关的基本知识：

* JS的类型是动态变化的，它可以在代码运行时进行改变。你可以将定义的一个String类型的变为整型。JS是一个面向原型化的语言，也就是你可以在代码运行的时候给一个对象分配一个原型。
* 对于JS来说有五种运行时错误：SyntaxError表达式错误、RangeError范围错误、referenceError引用错误、TypeError类型错误，URIErrorURI解析错误。

这篇文章的动机就在于，如今使用的一些fuzz工具比如jsfunfuzz生成的测试用例都会在运行时产生运行时错误，这就需要研究是否可以组成一个在句法和语义上都正确的测试用例工具。

###### Overview

为了组成一个语法和语义上都正确的测试用例，文中使用的技术是语义敏感的汇编。这个思想就是将JS文件种子切割为一系列可组合的代码块。一个代码块代表了一个合法的JS虚拟表达式树（AST）。一个代码块还会被一些限制所标识，这些限制会在连接代码块时使用。这个限制被分为前置限制和后置限制。前置限制说明代码块需要哪些变量，后置限制表明拥有以上变量的均可接在这个代码块的后面。

这里需要解决一系列的问题：

* 怎么切分代码块
* 切分完后需要保持一个被简化的代码块
* 需要重新定义代码块中的符号
* 确定代码块之间的数据依赖
* 为了提高准确性，要确定类型
* 使用一个构造代码段的好方法

CodeAlchemist 整体结构，首先有一个JS seed被输入，只要经过三个组件：种子解析器，限制分析器，fuzz引擎。这三个组件的功能就如同它们的名字那样。种子解析器的作用就是将输入的种子切割为一个个AST，限制分析器会分析每一个代码块，然后返回一个加上限制的代码池。fuzz引擎会根据之前代码池中的代码块生成测试用例，然后用它来测试引擎。

###### Detailed Design

* 种子分片：种子分片的前提是我们认为一个代码块就是一个合法的AST，AST就是一系列陈述式和表达式，陈述式可以包含其他的陈述式和表达式。切割AST的方法有两种，一种是使用LangFuzz的方法，将AST划分为多个子树，一种方法是就是切割为一个个JS表达式，本系统采用的是后者。seedparser会循环遍历AST，然后返回一系列代码块。这里考虑循环，循环体可以认为是一个陈述块，那么一个陈述块本身是一个代码块，切割开也可以是代码块。**如果是循环，还会多考虑一下有无循环语句的问题。**
* 建立代码池：首先第一步会出现一种句法上不同但是语义上相同的语句，本系统就需要过滤掉这种情况。在本系统中认为如果两个代码块是一样的是因为它们有着同样的AST；还有一种情况就是需要去除一些无用的语句。包括不能使用eval这样的内建函数。
* 重命名变量名：首先保证一点，内建的一些对象名字是不能改变的。这些需要单独列出，让本系统能够识别出来。然后在标识的过程中，两个代码块用到同一个变量改为同一个变量名。在这个里面使用的是类似与s1，s2这样的命名。
* 数据流分析：在进行标识的过程中需要使用数据流分析来确定那些已经用过的和里面定义了的变量。这里使用的方法是使用控制流图的方法来查找那些在里面定义的变量，而辨别已经使用的变量是那些没有定义的变量就是使用的。**但是本文的方法在判断if的过程中有问题。**
* 类型分析：如果只是使用JS中的七种类型会出现过拟合的情况。因为在JS中只要是一个对象就是认为它是一个Object类型。这会引起运行时错误的问题。所以此时要重建基础类型，要能区分各个Object。
* 构造测试用例：这里有四个用户需要设置的变量：imax --- fuzz循环次数；pblk --- 构造时使用重构陈述块的概率；iblk --- 构造陈述块要循环的次数；dmax --- 陈述块嵌套层数。构造输入需要一个代码池和一个空的代码块，而每次循环中完成的就是往当前构造的代码块里填入代码块。

###### Evaluation

这篇文章对于系统的评估主要有以下几个问题：

* 首先这个系统是不是能够真的构造正确的测试用例？
* 是否imax和pblk两个参数会影响系统？
* 和当前的fuzz工具相比如何？
* 在真正的测试中是否有用？
* 找到的漏洞具体长什么样？

###### Discussion

1. 种子的挑选直接影响生成样例的质量。
2. 代码块选择算法在这篇文章中是随机的，应该有一种更加只能的方法；
3. 使用这种思路去fuzz其他的翻译器或者编译器。