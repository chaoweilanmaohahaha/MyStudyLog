# MemLock： Memory Usage Guided Fuzzing 

## Background

这篇文章有意思的是，它是站在了另外一个角度去研究模糊测试。我们知道以前所谓的使用代码覆盖率作为标准去考察种子好坏的灰盒测试是一种对各种漏洞都通用的一种测试方法。但是这篇文章想要探寻的是针对**内存使用上的一些漏洞**。

首先我们知道这篇论文针对的是哪些内存上的漏洞，这里作者把它们统称为**内存消耗漏洞**：

* 非受控的递归漏洞：也就是涉及递归的程序，通过输入的构造，使得程序不断递归而耗尽了栈空间。

* 非受控的内存分配漏洞：程序中涉及开辟内存的函数涉及了非法的大小数据，并且未进行检验。

* 内存泄露：未跟踪释放内存的函数，导致内存泄露。

  > 内存泄露会导致 DOS 攻击。内存泄露是因为没有释放内存，所以空余内存变少，DOS 攻击后导致内存不够。

那么为什么之前的灰盒模糊测试不能做的很好？因为单纯的代码覆盖率为基础的方法只注重发掘新的代码，但是并不详细纠结单个代码的正确性。就比如发现了一个 malloc 函数，如果下一次没有发现新的分支，那么这个种子就会被抛弃，而不会深究这个 malloc 函数。

而还有一些其他的方法需要的是人为已经指定的规则。并且目前在挖掘漏洞的研究中，只有研究时间复杂度相关的，还没有和内存空间有关的。

## Overview

本工具依旧是基于 AFL 上的一个扩展，这个工具总的分为**静态分析部分**和 **fuzz 部分**。其中静态分析部分会对源代码进行分析，其中需要获取 **CFG，调用过程和一些有关内存调用的函数的操作**。然后在后两者进行 Hook 后，进行编译。

Fuzz 部分和 AFL 的功能是一样的，不同的是在挑选感兴趣的种子的时候，除了考虑到产生了新的代码覆盖情况，还要考虑到内存消耗的情况，如果**产生了新的内存消耗而并没有生成新的分支，也视为感兴趣的种子**。

## Details

接下来讨论一下具体怎么实现这个工具。

### 静态分析

在这里需要看到底怎么 Hook 代码。首先我们需要拿到 CFG，它的方法是和 AFL 是一样的，也难怪因为它是就 AFL 扩展的嘛。似乎我在这里没看到更大的改动，沿用了 AFL 中的分支标识方法以及 bitmap。

#### 调用序列

记录调用序列的目的是为了检测递归调用的问题。在静态分析中会在每个函数的入口和出口注入相应的指令。每次我们会记录调用栈的长度 ft，而执行完会和当前最大值进行比较 fm。

这里注意的一点是，这里并不区分不同的函数，而是用的所有函数统一的调用栈长度，因为确实这样一般也足够用来分析递归调用了。

#### 内存分配函数

一般程序中会包含一些使用内存的操作，比如 malloc 或者 free 等。那么该工具需要获取每个函数的申请的长度。

这里依旧按照总的分配的大小 ot 来计算，并且执行完后会和当前的最大值 om 进行比较。

### 测试循环

这个测试循环的主方法和 AFL 是一致的。在这里是使用了 power schedule 的，也就是说每一个种子都会获得一个**能量值**，而这个能量值指示了这个当前这个种子能够变异出多少新的输入来。

主要我们来看一下在这里提出的新的引导策略和种子更新策略。

#### 引导策略

在 MEMlock 中使用的是代码覆盖率和内存消耗同时对 Fuzz 进行了引导。其中代码覆盖率和 AFL 是一样的，而对于内存损耗来说，路径 k 对于一系列的输入来说，记录下 i 个输入中最大的调用个数 fmi(k 是路径 hash 后的 ID)。同理我们也要更新路径 k 的分配空间最大值。

所以只有在代码覆盖率有变化，并且路径的 fm 或者 om 有更新时，才认为这个种子是感兴趣的。

#### 动态更新种子策略

确实在上面也提到了，那么在更新的过程中，我们需要注意，只有触发了**新分支或者有了更大的内存损耗**的情况下，才将这个种子更新到队列中。文中提到这种策略还可以避免局部最优。

并且作者也强调了一点，对于一个输入，如果这个输入触发了新的分支，或者说这个输入导致了新的内存损耗，就有更高的概率被调用。

## Evaluation

作者将这个工具和六个工具：AFL、ALFfast、PerfFuzz、FairFuzz、Angora 和 QSYM 进行比较。并且综合分析了需要测试的这些程序，决定使用 14 个真实的应用程序来测试。

首先作者认为，如果程序中出现了更多的 crash，则说明可能会出现更多的漏洞，果然 MEMlock 产生了更多的 crash，并且在所有的程序中都发现了 crash，并且**保证了 MEMlock 有持续发现 crash 的能力**。

那么在这些现实软件中，确实 MEMlock 也发现了更多的漏洞，并且还发现了一些以前没有发现的漏洞(15 CVE)。

接着作者提到，查看这个工具检测内存泄露的可靠性，作者在这里检测的是工具能够识别的内存泄露的字节数。没错这个工具发挥最好。

最后作者分析了所有生成的种子中，能够触发内存操作问题的种子生成率。其中确实 MEMlock 能够生成更多这样的种子，这是毫无疑问的。

## Discussion

那么这个工具既然增加了功能，也会有相应的牺牲，它牺牲了代码覆盖率的快速覆盖，并且因为要做更多的功能，所以会有更多的开销。

并且因为这个工具是基于 AFL 开发的，所以它有的缺点这个工具也有。