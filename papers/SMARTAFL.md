# Smart Greybox Fuzzing

## Background

这篇文章的落脚点是强化 CFG，也就是 Converage-based greybox fuzzing。简单的像 AFL 这种 fuzzer 只会随机修改文件的一些位、字节，但是这对于高度结构化的文件是很难去处理的，以前的论文是根据 JS 或者其他语言文件来去测试解释器，而现在这个任务可能要扩展到一些更加普遍的软件，比如处理图片的软件、处理视频的软件等等。

以前就已经讨论过了像 AFL 已经不可能处理这些是因为很多这样的程序都会先去解析目标文件的结构，针对不同应用的文件结构类似 .wav .jpg 都有自身的特定结构。

> 本文中给出的一个动机，就是针对 wav 文件，其实很多文件都是这样的，文件分为多个区块，就像 wav 中分为 riff、data、fmt 等，而这些区块中存放了这个文件的一些属性信息和数据信息。并且这些区块中是存在等级结构的，这里我对于等级结构的理解是：只有有了 riff 区块才会去解析到 fmt 和 data 区块。

传统的灰盒、基于语法的黑盒、污点追踪技术的使用在这篇文章中证实都很难起到很好的效果。

这里预先总结可能考虑的一些灰盒技术：由 converage 驱动、有一种 power schedule 的机制(给小的种子更多 energe)、位级别修改、字典修改(根据目标文件的类型，给出一些可能使用到的关键字)。

## Overview

不按照这篇论文的顺序，在这里先讲一下 AFLSMART 的架构，再来看里面具体的技术。

AFLSMART 是从 AFL 上扩展而来的，它也借鉴了黑盒中实现的细节，所以借鉴了 Peach 的设计。

AFLSMART 有四个主要的模块：

* AFLSMART File Cracker：将输入的文件进行解析，生成区块和属性信息，同时在这里会统计输入的文件可被解析的量，这个值会影响到该文件在被调度时的使用概率。
* AFLSMART Structure Collector：这起到一个桥梁作用，将 Cracker 中解析的文件送给 Fuzzer；另一方面也会从 Fuzzer 那一端将生成的种子文件交给 Cracker 解析。
* AFLSMART Energy Calculator：实现了其中的一个**基于验证的调度算法**。
* Fuzzer：真正的 Fuzz 之前采用了本文提出的**结构化修改策略**，然后配合着 AFL 自身的位修改策略，以及本文提出的另外一些优化策略进行模糊测试。

## Details

### 将基于覆盖率的灰盒和基于指示文件的黑盒结合

就像标题说的，作者把这种技术称为 Smart Greybox Fuzzing。为了针对某一种高度结构化的文件的输入，需要在进入灰盒测试之前对文件进行解析，从而可以执行区块级别的替换，从而构造合法的文件结构。

#### 虚拟文件

这里作者用了一种虚拟区块来代替原本的真实区块，虚拟区块的思想就是将原先的等级结构抽象为类似线段树一样的数据结构。每个数节点代表的是当前的区块，而区块在文件的范围用文件中**开始行系数**和**结尾行系数**表示，叶子节点代表的是文件中的**属性**，中间节点代表区块，每个区块还会有 type 类型标识区块类型，比如它是 data 类型还是 fmt 类型

这里简单说一下，这个结构还是参考了 Peach Pit 结构，这是 Peach 提出的一种结构，可以由它自身的解析器解析得到，作者在这里对它进行了扩展。

#### 修改策略

有了上面的一个树结构，修改过程分为增加区块、删除区块和替换区块。

**删除**时只需要在源文件中将某个区块范围中的内容移除，将后面的部分平移连接到前面部分，然后修改一下虚拟结构中的系数。

**添加**时先要判断添加位置的父区块是否和添加区块属于等级关系，如果可以，就在目标位置腾出一片空间插入区块，后面的部分向后平移然后连接。

**替换**就是从另一个文件中找到和被替换区块类型相同的区块，然后在其中替换后，做好连接。

*总结一下，这些方法很像数据结构中的数组的操作。*

这里提到两个细节，第一一些不能修改的属性在 AFL 的位级别修改中也是不会改动的；第二这个构造过程本身并不一定能够保证结构一定是合法的，这也是 Fuzzer 的需求之一！

#### 优化策略

##### 堆积修改策略

*其实这边我还没怎么悟透，不过按照我的理解暂时是说的通的*。

堆积修改的意思，目测是在以前修改的基础上继续修改。对于这里的结构化修改策略中，如果修改了其中一个区块的信息，在更新系数的过程中必须要保证所有父节点的系数也要修改正确。

实现中作者指示讲了：

> Our implementation AFLSMART makes a copy of the seed’s virtual structure and stacks mutation operators by applying them consistently to both, the virtual structure and the ﬁle itself. 

*其实我觉得这里的意思就是指不会丢弃修改后的文件吧。*

##### 延迟修改

因为 AFL 的设计初衷讲究测试的效率，如果不停地进行解析生成文件会大大降低效率。

作者的延迟修改的策略的本意就是给测试过程增加一个阈值，如果过了这个时间阈值还没有检测出新的分支，则必然要重新生成一次种子；否则这个需求随着时间的推移越来越大就行。

这个方法一箭双雕，因为有时可能是 AFL 自身就检测除了新分支。

### 调度

像 AFL 的设计中存在着种子的调度算法，那么这里当然也要设计一种合理的种子调度算法。

在这里所实现的是基于种子的正确性而给每一个种子赋予一个能量值，具体的计算不会说明了，简单的说，越是正确的种子，越是可能被执行。在设计的时候作者用到了一个**爬山算法**。

> 从当前的节点开始，和周围的邻居节点的值进行比较。 如果当前节点是最大的，那么返回当前节点，作为最大值(既山峰最高点)；反之就用最高的邻居节点来，替换当前节点，从而实现向山峰的高处攀爬的目的。如此循环直到达到最高点。

> The validity-based power schedule implements a hill climbing meta-heuristic where the search follows a gradient descent.

## File Specification

这里就是讲了一下要给 Cracker 的文件指示的编写上需不需要注意一些什么。

* 编写一些区块的接口或者抽象区块，这样每一个区块都可以引用接口来实现具体的自己的区块。
* 我们在编写的时候可以先给一个粗粒度的区块信息。
* 对于区块中的一些属性和参数什么的并不一定要给一个很强的限制，这当然不能违反解析器去解析文件，但是过分的对编写的指示作限制可能影响种子的质量。
* 编写的这一个文件指示文件，可以测试同样使用这种类型文件的软件。

## Evaluation

这里作者正好分为了三层去测试：

* 和灰盒测试 AFL 和 AFLFast 比较
* 和 Peach 这类黑盒测试比较
* 和 Vuzzer 这样使用了污点追踪和目标文件指示的测试工具比较。

在前两类实验中，作者使用的是经过筛选的一些真实的软件；第二个实验使用的是 Vuzzer 论文中使用的那些软件。

最后的结果是，AFLSMART 在绝大多数的软件中都比 AFL 和 AFLFast， peach  要好。

在和 Vuzzer 方面因为涉及了不同的技术，所以虽然结果是 AFLSmart 似乎更好，但是作者认为他们是互补的。

## Discussion

作者在这里提出了一些未来工作，包括：

* input protocol fuzzing，有关一些人机交互的 fuzzing，这方面看过的比较少，但是因为输入也是结构化的。
* 因为文件指示是人为编写的，所以这个工作量很大，并且可扩展性受到限制。看看能不能通过学习能够学到。
* 可以想办法支持其他一些黑盒的 fuzzer 的办法，比如作者给出的 Domato。

其实这篇文章是一个对高度结构化输入的一个笼统的做法，如果思考它是对解释器进行 fuzz 的化，可以发现所谓的抽象语法树和这里的抽象文件是一个概念，并且修改的手段也是一模一样，所以这篇论文的方法可以看作是一个通用的方法。

