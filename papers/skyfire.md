# Skyﬁre: Data-Driven Seed Generation for Fuzzing

## Background

这篇文章的本质和之前读的很多通过 Grammar 来构造种子的方法很类似，不过其中还是有一些不同的。针对的问题还是高度结构化的输入对 fuzz 的影响，不过这里很好地把输入的执行分成了三步：语法解析、语义解析和应用执行。

很多程序会在语法和语义解析处就已经让程序失败了，那么这篇文章的一个点在于，**它不仅考虑了语法上的问题，还考虑了语义上的问题，这也是问题背景的驱使。**比如说 XSLT、JS 这种，是出现在许多论文中的经典的例子。

> 这篇文章中举了一个例子，就是在 XSLT 中会检查是否一个 attribute 节点能够被应用到 element 节点上。

以往的几篇论文中都只是考虑了语法的问题，所以使用的是上下文无关语法来构造种子。但是这篇论文强调需要考虑语义带来的不同，因此从这一点上看作者设计了一种上下文相关的语法(但是其实在编译原理中其实本身就存在这样的语法)，并且为了保证生成种子的多样性，提出了一种有概率的上下文相关的语法。

上下文无关语法在这里就不再介绍了，在之前的论文中有提到过(NAUTILUS)。

## Overview

整个工具如果和 Fuzz 技术结合可以分为三个模块，学习模块(Learning)、种子生成(Seed Generation)、Fuzz。那么 Fuzz 模块是托管给其他的模糊测试工具来做的，该工具主要注重的是前面两个步骤。Learning 步骤是从一些样本代码和语法(初始语法)上学习最终的有概率的上下文相关的语法。Seed Generation 是根据这个有概率的上下文相关语法来生成最终的输入种子。

下面会详细介绍什么是**有概率的上下文相关的语法**。

在这里要最后强调一点，作者的目标如下：

* 工具要生成**正确**的种子；
* 工具要生成**多样**的种子；
* 工具要生成**非平凡**的种子；

## Details

### Learning

下面来看具体需要学习到的有概率的上下文相关的语法是什么样的：

> 上下文无关语法在规则集 R 的每一条规则的左侧非终结符的要求是没有上下文，也就是满足 A --> a，而不是 aAb --> c。那么这里的上下文相关的语法是指 [c]A --> b。而这个 c 是指当前规则 A 的上下文，具体就是 A 的父亲要求、祖父要求等等。(作者目前认为这样设计已经足以表示上下文信息了)
>
> 所谓的概率是指对于每一条不同的上下文相关规则都会有不同的概率，而这个概率的切分是根据左侧非终结符的不同确定的，例如对于非终结符 A 这个规则一共能够推出三条不同，则三条规则就会有不同的概率，但是它们的总的概率和为 1。

有了上面的有概率的上下文相关的语法的概念，我们下面看怎么生成这样的语法：

现在我们拥有的是许多样本输入文件和初始的语法，那么将样本解析为一棵棵 AST，**遍历每一颗 AST 我们能够得到每一个父子节点对应的产生式规则对应的上下文信息，这样可以将该上下文信息添加到这一条产生式规则中形成新的规则**。

在我们已经在种子样本中统计了每一个父子节点遇到的个数之后，我们的产生式规则的概率就如下定义：

```
q([c]a --> b) = count([c]a --> b) / count(a)
```

### Seed Generation

最基本的种子方案在这里选择的是最左推导方案。它首先获得当前规则中最左边的一个非终结符，然后随机从所有与右侧推导规则相同的产生式规则附加上去。但是光光这样会带来一些问题：

* 递归问题
* 复杂问题

所以作者提出了一种启发式的最左推导方案，具体包括了四个启发式规则：

* 优先选择低概率产生式规则
* 优先选择低频产生式规则
* 优先选择低复杂度规则
* 限制总的规则数的使用

在选择种子上面作者考虑预先考察种子能够触发的覆盖率，获得高覆盖的种子优先选择。

种子变异上作者的方案只替换叶子层面的，并且保证被替换的节点的右侧推导结果一定都是终结符号。因为在本文中有一个非常有意思的地方，就是如果生成的种子带有非终结符，就会丢弃这个输入。

## Evaluation

作者是针对 XSML 、XML 和 JS 进行测试，使用的模糊测试工具还是 AFL。而这里作者的测试方法很有趣，使用了四组对比实验，分别是 crawl seed、crawl+AFL、skyfire、skyfire+AFL。从以下四个方面来看：

* skyfire 产生的好种子数
* skyfire 提高代码覆盖率的情况
* 四个启发式方案的效果
* skyfire  的性能

最后的结果发现 skyfire 和 模糊测试工具结合这样粗粒度的修改和细粒度的修改结合效果是最好的。

## Discussion

那么这篇文章在最后提到了有关 JS 的测试，这里的一个问题就在于当我们引入了语义的检测时，像 JS 这种语义特别复杂的语言就特别难去对其语义进行建模。

这也是这个问题未来需要解决的，包括对 JS 和 SQL 的测试。

