# SAVIOR: Towards Bug-Driven Hybrid Testing

混合测试（Hybrid Testing）包含了所谓的fuzz测试和符号测试（concolic testing）。它的本质想法是使用了fuzz测试来测试可到达的代码，然后使用了符号测试来探索是否有其他路径隐藏在了复杂分支背后。**但是fuzz本身的问题在于它很难测试到复杂分支的背后，如果有一些严格的限制，使用fuzz测试是非常难进入分支的；而符号测试很擅长探索分支的执行情况，但是却容易受到循环等因素的影响，性能大打折扣。**

一个常见的混合测试的方法是先让fuzz测试执行，当模糊测试已经无法获得进展，就会让符号测试重新执行fuzz时的种子。而符号测试会根据分支的测试情况调整种子的值。作者对这个架构提出了两个问题：

1. 在混合测试中对于每个fuzz中使用的种子的权重是一样的；大部分的分支可能是没漏洞的，如果重复检测这些分支会有大笔开销；
2. 就算找到了有问题的代码也未必能够找到漏洞；因为对于代码块的测试，混合测试使用的还是随即检测的方案。

针对以上两个问题，提出的这个SAVIOR系统使用了两个技术：

1. bug-driven prioritization：使用可能出现漏洞可能性更大的种子；
2. bug-guided verification：使用符号测试来验证执行路径上的标记漏洞点；如果这种限制在这条路径上是可满足的，就会生成一个测试输入来证明漏洞的存在。

###### Detail Design

**Bug-Driven Priortization**

思路是要收集执行代码中的信息从而生成更有可能触发漏洞的种子，这就需要两个因子：

* 需要一种方法在符号执行后能够进入到可到达的代码中；
* 需要一种能够衡量代码块中存在漏洞数量的指标；

对于第一条而言，在目标程序编译阶段需要静态分析目标程序可到达的代码块；在运行时需要识别未探索到的分支和可到达的分支数。

对于第二条而言，它使用了**UBSan**来标记三种潜在的漏洞。这样在每个代码区域内计算标记数即可。

有了以上两个方法，那么对于每一个种子而言都可以计算一个分数，来区分一个种子的好坏程度。用到的维度包括：所有没有探索到的集合，这些分支上的漏洞标记集合，每个分支上的测试次数集合。

**Bug-Guided Verification**

当我们在上一步中找到了那么多的漏洞标记之后，我们还需要有一种方法来验证这个漏洞时真实存在的。使用Clang sanitizer，对于特定的漏洞，尝试使用特定的触发条件，看是否能够满足这条路径上的执行限制。



###### System Design

整个系统包括了如下组件：一个编译时工具链借助了Clang 和LLVM，一个fuzzer工具比如AFL，一个符号执行工具比如KLEE，和一个混合调度器。

**Compilation Tool-Chain**

这个组件的目的包括了要进行漏洞标记，控制流执行路径的分析等。对于漏洞标记方面，上面也提到了使用了UBSan进行标记，这种标记方案是一个过拟合的标记方法，它将所有可能出现的问题都标记了出来。但是这样就会带来一些误判，那么在这个组件中有一个过滤器帮助过滤到一些错误的标记；控制流执行分析方面，它会在编译过程中生成整个代码的控制流图(解决哪些间接引用使用了Andersen’s point-to analysis)；然后组件计算每个基本块内部的标记数。这个组件还有的一个作用是对于目标程序，它需要将目标程序编译出三份不同的文件喂给AFL，符号执行工具和混合调度器。

**Coordinator**

它的作用很简单，就是fuzzer和符号执行器的桥梁。它需要完成一下操作：

* 更新全局的代码覆盖信息，这就和AFL的操作是一样的，随后对这个种子开始打分。然后所有种子都打过分后挑选出得分最高的种子。
* 它会将符号执行生成的新种子交给fuzzer，同时更新没有被覆盖到的分支的执行次数。

**符号执行**

这个组件的功能除了可以从协调器那获得fuzz的种子然后进行符号执行外，还可以进行所谓Bug-guided Verification的功能。

* 它使用独立的代码覆盖模型；
* 使用了fork server 模式
* 进行验证，一旦到达了一个新的没有被覆盖到的标记处，组件就会生成执行路径上的一系列的限制，如果限制是合法的，那么组件还能生成错误实例。
* 为了防止在某个代码区域上花费太多的事件，在这个组件中还加入了超时机制。