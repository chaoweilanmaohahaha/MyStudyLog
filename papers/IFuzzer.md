# IFuzzer: An Evolutionary Interpreter Fuzzer using Genetic Programming

## Background

这篇文章的大背景是对解释器进行 Fuzz，这个和普通的应用软件的最大不同就是输入的程序是代码，也就是一个高度结构化的输入。

> 为什么高度结构化的输入对 Fuzz 有影响呢？主要是考虑到编程人员对结构化数据的考虑，它们会使用很多判断语句来判断当前是否符合输入的结构，不满足就会直接退出。

所以从作者的看法中，需要保证两点：

* 生成的种子必须是符合语法的，并且最好是符合语义的。
* 生成的种子必须是要足够的特殊，能够触发解释器中的漏洞。

在背景里面似乎还需要解释一下**遗传编程的概念**，这是本文成功的因素之一。

遗传算法是一种解决最优化的搜索算法，属于进化算法的一种，它是借鉴了进化生物学中的一些现象，比如遗传、突变、杂交等等。

那么在算法中，我们也能进行模拟，将一定数量的候选解作为个体，使种群向一个更好的解进化。然后对每一代都评估种群适应度，然后从当前的种群中随机选择多个进行杂交和突变，生成下一代种群。

本文所实现的方法，就是基于所谓遗传算法，来生成更优质的种子。

## Overview

IFuzzer 的整体架构如下：首先整个程序的输入包括测试用例(一般使用开发人员提供的)，语法文件。首先 IFuzzer 需要一个解析器，和一个代码段池，随后使用代码生成器生成用例。生成的代码用例将交给用于被测试的解释器执行，然后将执行的情况反馈给 Fuzzer；最终交给适应性评估器评估种子的情况。

## Details

在这个方法中核心是阐明如何将遗传算法套到这个问题上。

在该问题上，代码文件通过解析可以生成抽象语法树，将每一个语法树看成是种群中的个体，这样我们的对于种群的进化可以看作是对代码的变异。

作者将算法的个体搜索空间，定义在所有可用的解，也就是所有可用的代码文件，而其中还需要考虑个体的膨胀问题，这个后面会解释。

### 准备工作

使用 ANTLR 结合 JS 的语法文件，可以将所有输入的文件解析出来，然后按照所有的非终结符将代码切割成一个个代码段，然后保存在一个代码池中。

作者随机从输入程序中挑选部分作为第一代个体。

### 变异

有两种手段，一种是直接生成一个新的样本，方法就是挑选解析树中的一个非终结符，然后从所有产生式规则中拿出与该非终结符有关的产生式规则，然后用其中的一个产生式规则替换掉当前数上的非终结符，如此循环 num 次。当执行了 num 次扩展后，如果在底层依然出现了可扩展的终结符，则使用相关的代码块填补它。

第二种手段使用代码池中有相同非终结符的代码块作替换。

### 杂交

杂交的过程需要使用一对输入用例，然后它选取该样本中一个相同的非终结符 n，随后进行交换。

作者还保证在上一代中出现的种子中，比较优质的种子将保留在群体中。

### 语义匹配

考虑到这种随机的替换造成语义上的问题，于是作者为了保证替换后不会出现未定义的变量，就将所有为定义的变量重命名为一些已经定义过的变量名。

### 膨胀控制

之前提到了个体的膨胀，这是保证个体的性质：

* 结构性膨胀：使得一个个体过分大，那么这样的个体会使得生成的是无效的代码。
* 功能性膨胀：个体逐渐区域稳定，也就是说慢慢的个体将变得类似。

为了防止以上问题，作者提出了膨胀控制的方法。

在适应性评估中，作者计算了一个ct的函数，用来衡量某个样本的适应性程度；同时还计算了下一代生成代码的公平性作为指标，用来限制生成代码的长度。

### 适应性评估

这个相当于是评估当前的代码段的优良。因为考虑到需要生产出足够不寻常的代码段，所以作者需要对代码的结构进行打分，它使用的是参考代码的圈层复杂度。同时根据代码执行后的反馈情况，也对代码段进行打分。两者结合获得了当前代码的一个健康分数。最后再减去了之前提到的 ct 函数，得到该代码段的一个最终得分。

## Evaluation

作者主要设计了两个实验，一个是和 LangFuzz 进行比较，比它优质的同时，能够发现它不能发现的一些漏洞。

另外作者使用 IFuzzer 测试了 SpiderMonkey，发现了很多漏洞，并且也测试了其他的一些引擎，也算是能够测试出许多漏洞。

## Remarks

1. 这里面对于对于第一代使用的是部分的测试用例，那么如果 IFuzzer 达到局部最优时，可以使用剩下的那些测试用例去测试。
2. 输入越复杂，发现漏洞的可能性更大。
3. 最后必须说明一点就是，其实许多解释器的测试样本都是属于一些寻常的代码段，这样就会漏掉很多漏洞的产生。

