# Parser-Directed Fuzzing

## Background

这个工具的侧重点和其他的 fuzzer 的侧重点不太一样。先说一下这篇论文的背景，这篇论文针对的依然是结构化的输入，而且针对的是对于结构化输入的解析器的 fuzz。这种解析器根据输入的语法格式对输入文件进行解析，所以总会有很多的分支要进行比较。如果使用普通的 fuzz 技术很容易提早失败而无法发现更深的分支。

作者这里的总结针对的是合法种子的生成的分类：

* 普通的 fuzz 是完全的随机的，所以搜索空间非常大。
* 加以限制的 fuzz 通常会使用一些软件分析技术，而这些分析技术则会带来路径爆炸的问题。

那么作者就把问题总结为：
**给定了一个程序，和带有非平凡的一种语言，需要做到的是找到一种测试生成器，能够覆盖这种语言的所有词法和语法特性。**

作者假设：

1. 目标程序是序列地处理输入的。
2. 目标程序会和正确的值进行比较。
3. 目标程序如果接收输入，则说明输入是合法的；反之则为不合法。

## Idea

注意上面提到的那些假设，作者的思想非常简单，就是由程序观察每个比较函数，然后根据比较时的对错。

如果对就接受当前的输入，然后再随机添加一个字符；否则就根据比较的值的范围，修改输入中的字节。

## Detail

那么最主要的方法在 Idea 部分也已经讲完了。综上所述，也就是在当前是不合法输入的情况下，将上一个添加的字符替换为合法的。作者认为为什么搜索空间减小了呢？因为它的搜索空间只受限于分支中的比较范围。所以这么操作理论上更有效。

> 这里举个例子，比如说当前的规则可能检测当前字符是否是一个数字，那么首先可能给个初始输入是一个字母 ‘a'，那么明显不满足，所以根据这个判断给出的范围，修改输入为满足条件的任意一个结果比如 1。那么这是发现通过了判断。那么我需要在后面继续添加随机一个字符，这样以此类推。

那这个问题的难点在哪？主要是输入的开闭问题。也就是说想要开始构造输入很简单，但是想要关闭这个输入很困难，比如说作者举了**封闭括号**这个例子说明，如果纯粹随机地选择范围内地字符并不一定很有效。

这意味着选择修改的方案是有策略的，而简单地使用深搜和广搜都很片面地去寻找修改的字符。所以作者希望可以将两者结合起来，那么作者就提出了一种启发式的搜索方法。

### 启发式搜索

这个算法可以说涵盖了整体的运行过程。首先这个工具有一个优先队列装载着所有未执行过的输入。而为什么是优先队列就是这些种子需要根据**启发式定义**来排序。

这个所谓的启发式定义是一个统计值，这篇文章中具体包含了所谓**它新添的长度和比父亲种子多的分支数。**在这里面，非常长的种子会有低优先级，考虑到递归下降的解析器的栈大小，如果生成栈用栈大小过大的种子也会有低优先级；最后由较少的父亲种子派生出来，并且可以触发同等数量分支的种子占高优先级。

而这个整体的生成种子的过程是由两个大环节组成，第一步是将没有随机扩展的种子进行运行，第二步是将扩展后的种子运行。那么在执行的过程中，如果某一个种子发现了一个新的分支，那么这个种子自然有更高的优先级。

**那么注意的是，在这个工具中专门有一个集合用来存储合法的种子已经走过的那些分支。**

### 闭合

之前也说了，关键在于一个输入的合法性还需要保证它是闭合的。越是复杂的输入到最后越是难以闭合。

为了防止生成的种子无休止的复杂化，则在本工具**每个新分支只会执行一次**，并且也会把栈深度和输入的长度考虑进去。

为了避免后来生成的种子去覆盖先前已经走过的路径，作者还跟踪了程序中的所有分支，然后查看构造的输入执行在相同分支上执行的数量，通过这个对种子进行排序。

## Implementation

这个工具需要借助 LLVM 来编译，并且由于它需要跟踪每个变量输入后行走的分支情况，所以它采用污点追踪的方式。

当然为了完成上述的启发式追踪，这个工具也需要对函数调用的顺序和触发的基础块进行统计。

## Evaluation

这里的评估作者从两方面来比较：代码覆盖率和**生成输入中存在合法关键字的多少**。作者决定和 AFL 和 KLEE 来比较。

结果很奇怪的是在作者选出的五个目标程序上进行测试，代码覆盖率上面 pFuzzer 基本完败，虽然它基本上都比 KLEE 好，但是 AFL 总是优于 pFuzzer，作者把这个问题归因于目标程序所要的输入还是不够非常复杂。

那么无论是上面那个实验，还是后来第二个实验去查看生成的合法关键字的多少，可以看到的是确实 pFuzzer 可以生成不一定更多，但是更复杂的一些关键字，这也达到了作者的目的。

## Limitation

作者在最后提了一些局限性，主要包括一些比较陌生的技术。。。

* 表格式的解析器(属实没听过)
* 分词的问题，这会让污点流消失
* 无法检测到输入的语义
* 对于一些包含循环的程序无法很好地构造。

这个工具讲道理思路十分简单，但是不知道实际效果如何，因为从我的观点来看这个工具只能测试一些不复杂的输入，真正如果输入非常复杂，那么它将很难生成吧。