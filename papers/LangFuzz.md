# Fuzzing with Code Fragments

## Background

这篇文章是发表在 USENIX2012 上的一篇老文章，但是这篇文章有它的意义。之前有一篇文章是有关 CodeAlchemist 工具的一篇文章，可以说是本篇文章的一个升级版本。因为在那篇文章中的比较对象就是 LangFuzz，也就是这篇文章中提出的。

这篇文章比较早的提出了从语法树的层面去研究 fuzz，而这也成为后面反馈式 fuzz 的产生的一大原因。这篇文章提出的是一个较为通用的 fuzz 解释器的一个工具，主要的比较对象还是在 JS 引擎上，当然在最后作者也确实将它使用在了 PHP 上。

有关 Fuzz JS 引擎上，在之前的研究中有一款名叫 jsfunfuzz 的工具专门用来测试 JS 引擎，但是它属于专门的工具，换句话说 jsfunfuzz 就是为检测 JS 引擎中存在的 bug 而生的，并且由于 jsfunfuzz 本身是通过引擎本身的代码特性而生成测试样例，因此有对引擎的依赖性。**作者的想法在于能否有一款方法较为通用的 fuzz 工具专门用来测试类似 JS 引擎的解释器呢？**

## Overview

本文先区分了两个概念：

* Generative：使用一定的方法和规则去构造输入；
* Mutative：从已有的数据上面随机修改，生成新的输入。

在本文之前的研究都是基于 Generative 而提出的，而本文是将 Generative 和 Mutative 结合来构造新的输入，之所以这么做作者是通过实验数据给出的。

LangFuzz 这个工具的整体架构主要由三部分组成，输入部分需要目标语言的语法文件，样本代码以及测试用例(所谓测试用例就是指开发者在测试引擎的时候的测试用例）；随后 LangFuzz 通过这些输入生成并且修改输入样例；最后交与解释器执行。

主要的问题其实在于如何生成，如何修改输入文件而生成输入样例。使用的过程是：

1. 根据输入的三类文件，学习目标语言的一些语句段(Code Fragments)，这些语句段可以组成语句池；
2. 根据语句池中的段，生成输入的测试用例，并用一定的方法尝试修改测试用例；
3. 将(修改)生成的测试用例输入到引擎中测试，看是否出现bug；

## Details

### Parse

工具第一步是要从源文件中学习到语句段，这使用的是 ANTLR 工具，该工具社区中本身就有 JS 的语法文件，同时该工具很容易就能解析出抽象语法树，也就很容易切割出语句块来。

### Generation

一种方法是直接从语法解析的情况来生成测试用例。如果我们有目标语言的语法，则只要在这个语法上完成一次随机遍历，就可以获得一个语句，但是文中指出这存在这一定的问题。因此作者在这里提出了一种宽度优先遍历的方法，即对于语法树上每一个非终结符，使用相关的产生式规则来进行替换。(基本思想就是这样，但是里面还有一些优化细节就略过了，本身也看不太懂啥意思)。

另一种方法直接用输入文件中的样本文件，用语句池中的同类型片段随机随即替换样本文件中的部分代码，来做到代码的变异。

当然在替换代码块之后有一个细节问题，就是要保证替换后的代码块中的变量是先前代码中已经定义过的，否则代码本身就是不合法的，这里的做法是暴力地将后续地变量名修改为之前定义过的变量名。在此之前先处理一下全局的一些变量。

## Evaluation

作者对于该工具的评估重视三个方面：

### 和 jsfunfuzz 相比

因为和 jsfunfuzz 的原理本身不同，所以要直接比较并没有说服力，原因在文中指出，在某种意义上能力可能并没有 jsfunfuzz 好。那么比较的方法主要侧重两个方面：

* 与 jsfunfuzz 的重叠性
* 与 jsfunfuzz 的效率

重叠性是为了看看功能上是否能够取代 jsfunfuzz，而效率单纯想比较一下是否比 jsfunfuzz 更快更多地发现漏洞。实验下来证明了两个工具是互补的，并且 jsfunfuzz 在有效性上还比 Langfuzz 更好，但是通用性上绝对是 Langfuzz要好。

### 两种生成代码方式的比较

那么到底是 Generative 更好还是 Mutative 更好呢？作者也做了实验，实验中发现，在不同的情况下两者都有优势，所以作者得出了结论，需要两者配合使用。

### 真实的案例

最后作者在真实的环境下测试了，并为了证实这种想法的通用性，所以对 PHP 解释器也进行了实验。

---

## Discussion

其实从文中的方法上有几点还是值得思考的，当然在后面的文章中确实是围绕了这几个方面在进行研究：

1. 首先就是随机性，随机地生成代码并不一定对 fuzz 起到帮助，如果能够有一定的引导和帮助是最好的。
2. 其次是正确性，文中强调生成的代码一定是语法正确的，但是对于像 JS 这样的动态语言，很容易出现语义错误，文中确实也指出，有许多其他的问题并不是引擎崩溃造成的。
3. 输入文件的依赖问题，好的测试用例的前提是有大量包含了语法特性的测试样例文件，如果没有这么多的样例文件，那么将很难生成有广泛性的测试用例。
4. 通用性还有待考察，文中最后也对这个思想的通用性提出了一些看法，对这种方法是否能运用到其他解释器上有待考究。

因为这个项目最终并没有开源，因此具体的实现无法看到，只能从文中领会到作者想要表达的意思。在后续的文章中更详细地阐述了其中的思想，但是这篇文章还是有它创新的意义。

