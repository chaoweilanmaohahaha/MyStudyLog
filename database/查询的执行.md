# 查询执行

这一节开始就走向查询的上面一层，首先简要看一下真正执行一个sql查询需要经过哪些步骤。当我们输入了sql语句之后准备做查询的任务，那么首先要对查询进行分析，在这一步会产生语法分析树；随后生成逻辑查询计划；最后根据逻辑查询计划进行优化之后生成物理查询计划，这是最后一步真正和读写存储器有关的操作。

那么这一节着重来看一下在数据库系统中，生成物理查询计划以及生成之后后有哪些操作。

## 背景知识

物理查询中做的最基本的事情就是读关系的内容，如果说这个关系存放在二级存储器中，也就是元组存放在块内，那么我峨嵋你需要一块一块获取数据块，这个称为**表扫描**；如果关系在某一个属性上已经有了索引，那么该索引可能对获取数据块有着指导作用，这称为**索引扫描**。

如果我们在读关系的元组过程中对关系进行了一次排序操作，我们把这个过程称为**排序扫描**。

那么在后面分析生成物理查询计划后所使用的一些算法的时候，通常要计算这种算法的IO代价，这有利于确定众多的查询计划中哪个是最快的。首先我们需要表示算法中使用到的内存大小，那么就用**M**代表一次物理查询所需要用到的内存块数量。同时在访问磁盘的块上，也有几种不同的参量。如果我们关心包含关系的所有元组的所有块数量，则使用**B**；如果我们需要对关系中的元组进行逐个读取，则使用**T**代表代价；最后如果在关心的是关系中属性a上的数目，则使用**V**作为代价。

最后要提到物理查询中用到的迭代器的概念。物理操作中使用的迭代器是一个包含三个方法的集合，这三个方法允许物理操作每次获得一个元组。

* open：启动获得元组的过程，但是不会获得真正的元组；
* getNext：返回结果中的下一个元组；
* close：终止迭代；

## 一趟算法

接下去的所有算法都是以读写磁盘IO的趟数作为它们分类的标准。

### 一趟一个元组

$\sigma$(R)和$\pi$(R)代表了选择和投影操作，这两个操作都需要从关系中抽出指定的记录来。那么很容易想到的是我们从磁盘中一个个读出关系R的数据块到内存中，然后对其中每一个元组进行判断然后送到输出缓冲区。在此基础上我们只要保证缓冲块的数量M大于等于1就可以了(这里假设缓冲块正好就是数据块的大小)。那看看读写的代价，如果数据是聚集的，很显然我们只关心块数量B；那么如果数据不是聚集的我们就真的需要逐个元组分析，也就是T。

### 整个关系上的一元

$\delta$(R)是消除重复的操作，消除重复的操作的不同在于它需要对整个关系上的元素进行扫描，判断是否是重复的记录。很显然这个操作需要在内存中存储一个备份，来记录某个元组第一次出现。那么假设我们使用了M个缓冲块中，其中的一块用来一块一块读取关系的数据块，而剩下M-1个缓冲块用来备份所有非重复的元素。在我们选取M需要好好考虑，一般我们设想是整个非重复元组恰好可以被M-1个缓冲块所装下，那么这样就认为B($\delta$(R)) <=M。但是如果M估计的不好则会造成系统颠簸。

$\gamma$是分组或者聚集属性的意思。如果我们要计算比如Max，Min，Count等等，那么我们还是需要一次一块扫描R中的元组，然后对其数据进行分组，每个族中的项包括了属性以及累计值。这个操作只有在读完R的最后一个关系之后才会创建输出，它需要去查看每一个分组。所需磁盘IO数是B。

### 二元操作

二元操作包括了并、交、差、积和连接。我们接下去假设R和S分别是两个不同的关系。

集合并需要将关系S读到内存中的M-1个缓冲块中，随后将R的每一块都读到第M个缓冲块中，对于R中每一个元组t，去查找是否在S中出现过，如果没有就将t复制到输出。（按照这个意思应当要把S一次性读到内存中，所以S一定是两个关系中较小的那一个）

集合交同样需要将S读到M-1个缓冲块中，随后读取R中每一块，对R中每一块查找S中是否出现，如果出现过就将t复制到输出，否则忽略t。

集合差需要分为两种情况。如果执行的是R-S，则依旧读取的是较小的S进入内存，随后我们需要做的是查找R中每一个元组t是否在S中，如果不再则输出；S-R则需要检查t是否在S中，如果在则在S中删除该元组。

包交和集合交不同，它允许有重复的元素输出，因此我们要将不同的元组与一个计数器联系起来，然后在使用t进行查询时对计数做修改，包差也是一样的道理

积运算需要将S读入内存的M-1个缓冲块中，随后读取R的每一个块，将其中每一个元组t和S中的每一个元组进行一个连接。将每一个连接而成的元组输出。

自然连接中要求读取S的所有元组，并且需要构造一个以Y（公共属性）作为查找键的查找结构，随后将R的每一块读入，并且对t查找所有在属性Y上相符合的元组，然后将它们和t进行连接之后输出。

## 嵌套循环连接

在开启两趟算法之前，要先接触一个称为嵌套循环连接的算法。先从最简单的入手，假设我们要做一个连接，那么对于每一个元组我们做一次循环嵌套连接，那就是对每一个S中的元组，都和R中每一个元组进行一次比对，如果可以生成连接就输出：

```
for s in S:
	for r in R:
		if s can connect to r then:
			output t;
```

我们将这种方法扩展到数据块层面，而与一趟算法不同的是，我们已经无法将R或者S一次性搬到内存中来了，所以嵌套循环的连接就是处理数据量大的情况。我们依旧需要将S读入到M-1个缓冲块中，而此时我们和上面的代码类似，进行连接操作：

```
for m-1 blocks b in S:
	for r(block) in R:
		for t in r:
			find s in S that can connect to t
			output the connection.
```

下面开始我们来解决两趟算法

## 两趟算法

### 基于排序的两趟算法

这种方法要借助多路并归排序的思想，基本做法是它需要对关系进行一个排序，排序的方法就是从R中读取M个块放入缓冲区，然后利用排序算法将这些块中的元组进行一个排序，随后存回外存中，这个过程相当于构造了一个有序的子表。第二次我们将子表的部分读入到M-1个缓冲区中，然后我们在第M块子块上进行一个归并，归并的方法很简单，因为每个子表都是已经排好序的，每次移出M-1个缓冲区上最小的那一个元组进入第M个缓冲块中，如果输出缓冲块满了就存回外存；如果代表子表的块空了，就从外存继续读入子块。

分析一下你可以发现，R的大小被限制在了M*(M-1)中，那么这样就得到了B<=M*(M-1)。我们再分析一下IO会发现不考虑最后输入块的IO则它需要3B的IO代价。

利用排序两趟算法我们能干嘛，对于去重操作我们只要在归并的过程中只复制没有重复过的块进入输出缓冲块中就做到了去重的效果；对于分组和聚类，可以对分组属性进行一个排序，然后再第二阶段扫描每个块然后统计据类信息。

并操作则为R和S总共开辟M个缓冲区，也就是保证在第二阶段将R和S的子表的第一块都读入内存时使用不超过M-1个缓冲块，随后挑选非重复的元组t，去除重复元组t；交也是类似；

对于连接而言，我们直接看一个有效的连接算法，就是以属性Y作为键进行排序为R和S建立子表，随后将每一个子表的第一块调入缓冲区，保证总共不会超过使用M个缓冲区，随后重复查找属性Y上最小的y值，并识别两个关系中有y的所有元组，然后将这些连接后输出。

### 基于散列的两趟算法

基于散列的方法时我们会将关系R使用M个缓冲区将它划分位M-1个桶，使用设定好的散列函数h。第M个缓冲区用来一次次装入R中的块，然后进行散列。如果缓冲区满了，就存回外存，每一个桶当然需要存在一起。

那么这样而言我们处理消除重复，一般而言相同的元组会被分入相同的桶中，那么也就是说去重可以独立在某个桶中进行，如果桶的大小足以一次性装入内存，那么就只需要借助一趟算法。如果我们需要作用在分组和聚类中，则希望同一组别的元组尽可能分配在同一个桶中，因此适当选择hash函数，接下去只要对每一个桶执行分组一趟算法。

并运算使用相同的散列函数对R和S散列，然后只要对每个对应的桶进行合并，也就是跑一趟算法。

连接算法需要必须按照属性Y进行散列，这样使得可以直接使用R和S对应的桶进行一个连接算法即可。

### 基于索引的两趟算法

如果一个关系上在一个属性或者多个属性上已经存在了索引，那么就有一些算法能够帮上大忙。

---
### 聚簇索引

如果一个关系的元组紧缩到能存储这些元组的尽可能少的块中，这个关系是聚簇的。那么聚簇索引就要求这个索引查询关键字的一个固定值的所有元组都出现在能容纳它们的尽可能少的块中。

---

那么如果有了索引怎么能修改查询策略呢？针对选择算法，那么在选择的属性上直接根据索引查找就能取出相应的记录了，如果索引是聚簇的，则IO的代价大约是B(R)/V(R,a)，否则它的代价会是T(R) / V(R,a)。

考虑连接算法，如果此时正好S在公共属性Y上有索引，那么只需要检查R中每一个块，使得其中的元组t去S的索引上查找，如果找到则进行一个连接即可。有一种特殊情况是如果使用了类似B书这样的结构，上面的索引是有一定顺序的，那么假设R和S都有Y的索引，我们可以采取一种叫做zig-zag的连接方式，方法类似于基于排序的连接的最后一步。

## 多趟算法

在绝大多数的情况下用到两趟算法已经足够解决问题了，如果我们将两趟算法再进一步推广，那就有了多趟的算法。包括了基于排序的多趟算法和基于散列的多趟算法，这里不再赘述，以后用到再展开吧。

## 缓冲区管理

在上面的叙述中，我们引入了一个缓冲区的概念。这个缓冲区需要预先保留来使用，并且实际M的数值会根据系统的状态而发生变化。

内存中的缓冲区一般需要通过缓冲区管理器直接来管理，它会在虚拟内存中分配缓冲区，但是它们时刻都要把控缓冲区的数量，使得系统不会出现问题。以上我们仅仅假设有一个固定的缓冲池，那么对这个缓冲池进行管理，当一个新块需要申请一个缓冲区，那么就需要对缓冲块进行调度，通常调度的策略包括：最近最少使用，先进先出，时钟算法等。

事实上在处理查询算法时，缓冲区管理器不一定能够保证必然能得到这么M个缓冲区，那么不同的算法就需要考虑到适应M大小变化时的算法的改变。