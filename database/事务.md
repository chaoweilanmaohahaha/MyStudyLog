# 事务

> 事务简单的说是一系列的sql语句，它保证一点，就是事务中的动作要么全做，要么都不做。
>
> 一个事务一般包括四点：原子性、一致性、隔离性、持久性。

在并发控制和故障对策中考虑到了事务的一些性质，因此对于系统与介质故障，还有事务的并发执行会出现的问题做了介绍。那么在管理事务的过程中还会遇到什么问题呢？

在并发控制和故障对策中，我们主要关注了事务执行的可串行性和可恢复性。

如果说数据被未被提交的事务写入，则数据有可能是脏的。脏数据就可能出现在缓冲区、磁盘等场所。如果事务中出现了脏数据，很显然会对事务的执行造成问题。如果我们发现事务是可以获取脏数据的，那么我们需要对事务进行**级联回滚**。简单地说，我们可以中止T，然后确定哪些事务使用了T写入的数据，然后递归中止这些事务，此时可以借助日志对数据进行必要的恢复。

从故障对策那一章也看到了，经过恢复之后的事务集必须是一致的。如果T1在恢复后处于了提交状态，那么T1用到了T2写入的值，保证T2也必须是提交状态。此时我们能确定：

* 如果调度中的每一个事务都在读取所有事务提交之后再提交，则该调度是可恢复的。
* 日志的提交记录到达磁盘的顺序必须和它们被写入的顺序是一致的。

那么如果在调度中的事务只读取了已经提交了的事务写入的数据，则这种调度叫做ACR调度。这里所谓的已提交就是日志的提交数据已经到达了磁盘。

## 死锁

事务中的一个问题在于死锁，在并发控制中有提到死锁的概念，如果若干个事务中的灭一个都在等待被其他事务占有的资源，因而每个事务都不能取得进展。处理死锁一般有两种手段，要么检测出死锁然后修复，要么避免死锁的发生。

### 死锁检测

当存在死锁的情况，事务就不可能继续执行下去，那么至少有一个事务要重新开始执行。检测死锁的最简单的办法是使用超时机制，如果一个事务的活跃时间已经超过了限制，则说明事务必须做出回滚。回滚之后，事务必须释放它占用的锁和其他资源，那么其他事务等待锁导致的死锁问题，是通过**等待图**来检测死锁情况的。等待图中保证持有锁的和等待所的事务有一个结点，并且如果T正在等待U上的锁，那么就有一根弧，如果等待图中无环，则不会发生死锁。

预防死锁的方法还有许多：

* 如果我们按照数据库元素中任意的但是固定的顺序对其进行排序，则申请锁必须按照一定的顺序。

* 我们可以借助时间戳来检测死锁，这种时间戳和之前提到的并发控制中的时间戳不同，这种时间戳只用来处理死锁问题。时间戳在事务T必须等待事务U持有的锁时使用，具体有两种策略来检测死锁：

  * 等待-死亡：如果T的时间戳比U小，则允许T等待U，否则T将回滚；
  * 伤害-等待：如果T比U时间戳小，则必须伤害U，也就是让U回滚并释放锁；否则T等待U的锁。

  它们都是提倡让较老的事务杀死新事务，但是伤害等待模型中只要老事务请求新的事务持有的锁，则较新的事务就被杀死，所以伤害-等待的回滚比较少见。但是等待死亡策略在经历回滚之后返回到了比较前的阶段，事务做的工作还不多。但是两个策略都要比周期性构造等待图容易。

## 长事务

长事务时需要太长时间因而不允许它们保持其他事务所需要锁的事务，比如传统的DMBS应用、设计系统、工作流系统。我们定义saga是构成长事务的一系列动作，它包括了：

* 一系列的动作
* 一个图，结点包括了动作结点或者是中止结点（Abort结点和Complete结点）
* 动作从哪里开始，这是开始节点。

动作序列是是指从开始节点走向中止结点，如果到达了Abort结点就导致整个事务的回滚，否则到达Complete结点就完成了整个事务。

saga的并发是这么体现的：它的每个动作都是一个短事务，可以在这上面实施封锁；在整个事务通向中止结点的路径上是通过**补偿事务**来管理的。

### 补偿事务

在所谓的saga中每个事务都会有一个补偿事务，它好比是矩阵中的逆矩阵，专门用来回滚已经提交过的事务，所以如果执行了A然后又执行了A补偿，相当于回到了A执行之前。这个有个好处，如果执行路径通向一条Abort结点，则可以通过沿路的补偿动作来进行回滚。