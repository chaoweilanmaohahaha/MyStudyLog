# MySQL 存储引擎

MySQL 是一个可移植的数据库，并且能够保证在各个平台上的物理体系结构的一致性。在数据库中，有数据库和实例这两个概念：

* 数据库：物理操作系统文件或其他形式文件类型的集合。
* 实例：MySQL 数据库由后台线程以及一个共享内存区组成。

MySQL 被设计为一个单进程多线程架构的数据库，**数据库实例在系统上的表现就是一个进程**。当启动实例时，MySQL 数据库会去读取配置文件，根据配置文件的参数来启动数据库实例。而假设 MySQL 数据库中可以没有配置文件，此时会直接按照编译时的默认参数设置启动实例。其中在配置文件中有一个参数 datadir，该参数指定了数据库所在的路径。

MySQL 从上至下的体系结构由以下几个部分组成：

* 连接池组件；
* 管理服务和工具组件；
* SQL 接口组件；
* 查询分析器组件；
* 优化器组件；
* 缓冲组件；
* 插件式存储引擎；
* 物理文件

MySQL 数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎，MySQL 的每个存储引擎都有自己不同的特点，它能够根据具体的应用建立不同存储引擎表，当然用户可以根据 MySQL 预定义的存储引擎接口编写自己的存储引擎。

MySQL 中存在的存储引擎大致有以下几种：

* innoDB
* MyISAM
* NDB
* Memory
* Archive
* Federated
* Maria
* ....

在这里最后谈一下连接 SQL 的方法，这个操作的本质就是一个连接进程和 MySQL 数据库实例进行通信，**所以本质就是进程通信**。在 MySQL 中支持了使用 TCP/IP 套接字的方式，命名管道和共享内存以及 UNIX 域套接字。

## InnoDB 存储引擎

InnoDB 是事务安全的 MySQL 存储引擎，它是 OLTP 应用中核心表的首选存储引擎。从 5.5 版本以后就是默认的表存储引擎，该引擎是第一个完整支持 ACID 事务的 MySQL 存储引擎。从历史发展上来讲，从 5.1 版本时数据库允许开发商以动态方式加载引擎，所以在这个版本中能够包含两个版本的 InnoDB，一个是静态编译一个是动态加载的。

### 体系结构

InnoDB 存储引擎有一个很大的内存池，维护进程或者线程的内部数据结构，缓存磁盘上的数据，日志的缓存等等。许多后台线程就用来负责刷新内存池，保证缓冲池中的内存缓存的是最近的数据。

InnoDB 存储引擎本身是多线程的模型，比如以下几种重要的线程：

1. Master Thread：这是 InnoDB 中非常核心的后台线程，主要负责将缓冲池中的数据异步刷新到磁盘保证数据的一致性。
2. IO Thread：InnoDB 存储引擎中大量使用了 AIO 处理 IO 请求，IO Thread 是负责这些 IO 请求的回调处理。在 InnoDB 中一般有四种 IO 线程，分别是 write、read、insert buffer 和 log  Thread。那么对于读写线程，在 InnoDB 中都可以调整它们的个数；
3. Purge Thread：当所使用的 undolog 不再需要时使用 PurgeThread 来回收已使用并分配的 undo 页。
4. page Cleaner Thread：将之前版本中脏页刷新操作放到了单独的一个线程中来完成。

InnoDB 对于内存设置了一种缓冲池。因为  InnoDB 本身是基于磁盘存储的，这样可以将它视为基于磁盘的数据库系统，而基于数据库系统通常使用缓冲池技术来提高数据库的整体性能。InnoDB 数据库中对于页的操作，是先修改在缓冲池中的页，然后再按一定的频率刷新到磁盘上，并且会使用一种叫做 **CheckPoint 的机制刷新到磁盘**。

缓冲池中缓存的页类型包括了：索引页、数据页、undo 页、插入缓冲等等。目前 InnoDB 支持多个缓冲池实例。

那么在数据库中缓冲池是如何被管理的呢？通常来说数据库中的缓冲池是通过 **LRU 算法**来管理的，在 InnoDB 中也不例外。但是 InnoDB 对 LRU 算法进行了改进，加入了 midpoint 位置。对于新读入的页并不会将它插入到列表首部，这个算法叫做 **midpoint insertion strategy**。因为如果进行索引或数据的扫描，那么很可能会将缓冲池中的页刷新，影响缓冲的效率。最开始所有页都被存放在一个 Free 列表中，需要的时候从这个列表中查找空闲的页并插入 LRU 列表中。在 InnoDB 1.0.x 版本之后开始支持压缩页的功能，即将原本的 16KB 的页压缩为更小的页，这样对于不是 16KB 的页来说，都是通过 unzip_LRU 列表进行管理的(LRU 是包含 unzip_LRU 的，一般使用伙伴算法来实现)。当 LRU 列表中的页被修改后，就变为了脏页，脏页又存在于 LRU 列表中，又存在于 Flush 列表中。数据库会根据 CheckPoint 来将脏页刷新回磁盘。

数据库中还有重做日志(*单独会讲*)的缓存，当数据库将重做日志放入缓冲区后，也会按照一定频率将其刷新到文件中。最后还有一些额外的内存池，InnoDB 中使用了一种**内存堆**的方法管理，对一些数据结构本身的内存分配时，也可能向缓冲池进行申请。

## CheckPoint

当使用了类似 Update 或者 Delete 语句改变了页中的数据，此时页是脏的，那么数据库就需要将页从缓冲区刷新到磁盘。设计中总不可能每有一个页变脏就选择刷新，但是又要避免在同步的时候发生宕机，这样数据就不能回复。那么使用重做日志，以及 Write Ahead Log 策略，就可以避免数据丢失。而设计 CheckPoint 的目的主要是缩短数据库的恢复时间，缓冲池不够用的时候让脏页刷新到磁盘，重做日志不可用刷新脏页。

当进行恢复的时候，CheckPoint 之前的页都已经刷新到了磁盘上，所以只需要对 CheckPoint 后的重做日志进行恢复。根据 LRU 算法会溢出最近最少使用的页，如果此页为脏页的话那么需要强制执行 CheckPoint。而对于重做日志而言，在实际使用中是循环使用的，当旧的重做日志需要被覆盖，此时也要进行在 Checkpoint 处对缓冲池中的页进行刷新。

在 InnoDB 中，它是通过 LSN 来标记版本的。而在 InnoDB 存储引擎的内部，存在着两种 Checkpoint：

* Sharp Checkpoint：发生在数据库关闭时将所有的脏页都刷新会磁盘。
* Fuzzy Checkpoint：只刷新部分脏页，而不是刷新所有的脏页回磁盘。在 InnoDB 中也无外乎几种情况：
  * Master Thread Checkpoint：出现在主线程内，不会阻塞查询线程
  * FLUSH_LRU_LIST Checkpoint：为 LRU 列表腾出空间，将一些脏页刷新到磁盘。
  * Async/Sync Flush Checkpoint：就是在重做日志不可用的时候，刷新一些页回磁盘。这保证了重做日志的循环使用的可用性。
  * Dirty Page too much Checkpoint：这是指 InnoDB 发现脏页实在太多了，而强制引擎进行的一个 Checkpoint。

## Master Thread

上面已经提到了在 InnoDB 的引擎结构中，工作是由一个个后台的线程完成的，最主要的工作是由 Master Thread 线程完成的。Master Thread 拥有最高的线程优先等级，其中包括了许多个循环组成。

Master Thread 中的 Loop 是主循环，基本上绝大部分的操作都是在主循环中完成的，这里面主要还分为两大类事件，一类是每秒需要完成的操作，另一类是每 10 秒要完成的操作。其中每秒需要完成的操作包括：

* 日志缓冲刷新到磁盘
* 合并插入缓存(可能完成，根据当前 IO 次数判断)
* 至少刷新 100 个 InnoDB 的缓冲池中的脏页到磁盘(可能完成，根据当前脏页比率判断)
* 如果此时没有活动，切换到 background loop(可能完成)

每 10 秒需要完成的操作包括：

* 刷新 100 个脏页到磁盘(可能完成，根绝当前数据库 IO 操作的能力判断)
* 合并至少 5 个插入缓冲
* 将日志缓冲刷新到磁盘
* 删除无用的 Undo 页
* 刷新 100 或者 10 个脏页

而当用户没有活动时，主循环会进入 background loop 中，在这个循环中，它会执行如下操作：

* 删除无用的 Undo 页
* 合并 20 个插入缓冲
* 跳回主循环
* 不断刷新大约 100 个页，这会跳转到 flush loop 中完成

如果连 flush loop 都觉得，当前数据库并没有什么事情需要做，就会跳入 suspend loop 中，使主线程进入挂起状态。起码在 1.0.x 版本之前，innoDB 是这么做的，在 1.2.x 版本之前对其的性能进行了一定改进，由于在上面的循环中，很多参数都是硬编码的，所以之后的版本对很多参数都进行了可调化，允许用户来控制它们的变化。而 1.2.x 版本之后对 Master Thread 则是又进行了微调，将每秒的操作和每 10 秒的操作分离，并且加入了 Page Cleaner Thread 独立的线程，提高了系统的并发性。

## InnoDB 其他的关键特性

### 插入缓存

插入缓存可以说是 innoDB 中的一个最重要的功能之一，它和其他数据页类似，是物理页的一部分。首先在 innoDB 中**主键是行唯一的标识符**，因此插入聚集索引一般是顺序的，但在大多数情况下一张表上会有多个非聚集索引。对于插入操作，数据页是按照主键的顺序存放的，但是对于聚集索引而言不再是顺序的了。

innoDB 中存储引擎使用了插入缓存对非聚集索引的插入或者更新进行操作，它不是每一次都直接插入到索引页中，而是先判断插入的非聚集索引页在不在缓冲池中。这就相当于在真正插入到 B+ 树叶子节点之前再加上了一层缓冲。注意一般使用插入缓存的条件如下：

* 索引属于辅助索引
* 索引不是唯一的

在 innoDB 1.0.x 版本开始引入了 Change Buffer，这对存储引擎所有的 DML 操作进行缓存，分别是 Insert Buffer、Delete Buffer、Purge Buffer。

Insert Buffer 也是通过 B+ 树的结构实现的，并且目前这棵树是全局的，存放在共享表空间 ibdata1 中。Insert Buffer 也是由叶节点和非叶节点组成，而非叶节点存放了查询键值，键值组成如下：

* space：待插入的表空间 id
* marker：兼容
* offset：所在页偏移

如果数据库发现一个辅助索引要插入到某个页(space，offset)时，则在这棵树中就会构造出这样的一个键值对，随后构造叶子节点插入到 B+ 树中，其中叶子节点也包含上面的三个属性，除此之外还包括了一个 metadata 和真正的数据。

在这个机制中为了保证每次插入的成功，引擎还使用了 Insert Buffer Bitmap 来跟踪辅助索引页。

Insert Buffer 的数据何时真正更新到数据库的辅助索引中呢？一共有下面几种情况：

* 辅助索引页被读取到缓存中
* Insert Buffer Bitmap 追踪的辅助索引页已经无可用空间
* Master Thread

Insert Buffer Bitmap 其实就是一个将缓存和实际索引页挂钩的一个位图。不如如果在读取真正的缓冲索引页的时候，需要先查看该索引页在 Insert Buffer Bitmap 中是否存在缓存中。假设当前这个位图中已经追踪了太多的缓存页，则需要腾出空间。

### doublewrite

当发生数据库宕机时可能会遇到这种情况，引擎正在将内存中的页写入表中，但是此时这个页只写了一部分，这种情况叫做部分写失效。如果使用重做日志来恢复，而该页本身已经被破坏，则将无法恢复。所以如果想要恢复，必须重新对该页制作一个副本，然后恢复时使用该副本来恢复此页，这就是 doublewrite。

doublewrite 需要内存和物理磁盘的配合，在对脏页刷新时先写入 doublewrite buffer，然后再分两次将缓存写入物理磁盘的共享表空间内，调用 fsync 同步磁盘。当完成上述步骤后，再将 buffer 中的页写到表空间中。

### 自适应哈希索引

对索引再建立一个 hash 索引以提高擦护照速度，这就是自适应哈希索引。这个索引是根据 B+ 树索引建立的，它根据访问的频率和模式自动为某些热点页建立哈希索引。但是自适应哈希有一个要求，就是每一个页的连续访问模式必须是一样的，也就是查询的模式必须是一致的，并且只有搜索等值的查询可以使用哈希索引，其他查找类型是不能使用的。

### 异步 IO

大哥前的数据库系统都是通过异步 IO 的方式来处理磁盘操作的。它不像同步 IO 必须等操作结束才能继续后续操作。并且对于异步 IO 来说，它还可以将一些 IO 操作合并完成。从 1.1.x 版本开始，innoDB 提供了内核级别的支持，称为 Native AIO(Mac OSX 未支持)。

像数据库中的 read ahead 操作，包括脏页刷新磁盘写入也是由异步 IO 完成的。

### 刷新邻接页

当刷新一个页时，innoDB 存储引擎检测该页的所在区的所有页，如果也是脏页则一起刷新。这可以配合 AIO 来合并操作。

## 启动、关闭与恢复

在 MySQL 中，有一个在关闭时用到的参数 innodb_fast_shutdown，这个参数有三个值：

* 0：关闭时要完成所有的 full purge 和 merge insert buffer，并刷新所有的脏页。
* 1：不进行 full purge 和 merge insert buffer 但是要刷新一些脏页；
* 2：只写日志文件，下次启动时会执行恢复。

像 MySQL 中还有 innodb_force_recovery 参数会影响引擎恢复的情况，默认为 0 代表当发生需要恢复时进行所有恢复操作。其实它一共有 6 个非零值选项。

