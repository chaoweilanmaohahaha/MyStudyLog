# 索引

InnoDB 存储引擎支持索引，并且支持如下几种常见的索引：B+ 树索引、全文索引、哈希索引。哈希索引在 InnoDB 中是自适应的，它会根据表的情况自动生成哈希索引，并不能人为干预。

B+ 树索引就是传统意义上的索引，在 InnoDB 中使用 B+ 树索引是只能找到被查找数据行的页，具体的数据行还是要在页内通过二分查找来搜索。

## B+ 树索引

B+ 树是一个数据结构，这里就跳过 B+ 树和他的可能的操作。那么 B+ 树索引的本质就是 B+ 树在数据库中的实现。  在实际的数据库中 B+ 数索引分为聚集索引和辅助索引两种，它们的本质区别是叶子节点是否存放的是一整行的信息。

聚集索引是按照每张表的主键构造一棵 B+ 树，对于它而言叶子节点存放的是行记录数据即数据页。由于实际的数据页只能按照一颗 B+ 树来排序，**所以一张表只能拥有一个聚集索引**。所以这就使得数据库能够在叶子节点上直接找到数据，并且本身聚集索引能够更快访问范围值查询，所以适合对于主键的排序和范围查找。要说明一点的是官方会这么描述：聚集索引回按照顺序物理地存储数据，**但是实际上聚集索引地存储并不是物理上连续的们还是逻辑连续的**。

辅助索引而言，叶子节点就不再是行记录数据了，叶子节点会包含一个 bookmark，告诉你应该去哪寻找相应的行数据，更简单的说辅助索引的 bookmark 就是相应行数据的聚集索引键。每张表中可以建立多个辅助索引，当数据库使用辅助索引查找数据时，会通过获取叶子节点上的指针，获取指向主键索引的主键，再通过主键索引找到行记录。

这里提一嘴 B+ 树索引的分裂，对于数据库的插入如果是顺序的，那么在叶子节点中间插入显然不是一个很好的选择，因为这样会导致被分裂的一个叶子将再也没有记录会被插入。所以 InnoDB 需要决定到底是向左分裂还是向右分裂

在 InnoDB 中如果想要创建或者删除索引，要么使用 ALTER TABLE，要么使用 CREATE/DROP INDEX 命令，使用SHOW INDEX 可以查看索引信息。这里后面提到了一些技术的使用这里简单介绍一下，如果详细了解的话可以想i下看一下：

* Fast Index Creation
* Online Schema Change
* Online DDL

### Cardinality

如果使用 SHOW INDEX，可能会观察到有这么一个值：Cardinality。不是说所有查询条件中的列都会需要添加索引，在访问表中很少的一部分时使用 B+ 树才是有意义的。一般而言如果一个字段的取值范围非常的广，而且几乎是没有重复的，称为高选择性，像这种数据使用 B+ 树是最为合适的。

Cardinality 值就是用来观察索引的高选择性的。它表示索引中不重复记录数量的一个预估值，注意不是准确值。如果 Cardinality/rows 趋近 1，说明索引就是高选择性的。那么简单看一下到底 Cardinality 值是怎么统计的，它是通过采样完成的，更新 Cardinality 值的操作只在两个操作 INSERT 和 UPDATE 中完成，但是又不可能为了降低效率每一次都更新，所以只会在一些条件下实现采样。InnoDB 默认对 8 个叶子节点进行采样，随机抽取这些叶子节点，并统计每个页中的不同记录个数，随后计算均值乘以总叶子节点数就是粗略的记录数了。**因为是随机采样，所以前后两次的 Cardinality 值很有可能是不同的**。

### B+ 树索引的使用

**联合索引**是指对表上的多个列进行索引，不像前面提到的索引都是对于单列的。本质而言联合索引也是一颗 B+ 树，但是联合索引的键值的数量是大于等于 2 的，并且在 B+ 树上键也是按照顺序排列的。并且这个联合索引的好处在于，确定了第一个键后，它的第二个键也是排好序的了，这样能够避免多一次的排序操作。

**索引覆盖**是指从辅助索引中可以查到的记录，不去查询聚集索引。

当然在一定的条件下，查询优化器会选择直接进行全表扫描来找到数据，这种一般发生在范围查询或者 JOIN 链接操作下。

**索引提示**用来显示告诉优化器使用哪个索引，比如人为发现了使用某个索引之后运行速度很慢，或者索引非常多使得优化器选择开销增大。

**Multi-Range Read(优化范围查询)** 和 **Index Condition Pushdown(取出索引同时进行 where 过滤)**

## 哈希

InnoDB 中使用了哈希算法优化了页的查找，冲突机制采用了链表方式，哈希函数使用除法散列。缓冲池中的页会有一个chain 指针指向和它具有相同哈希值的页，在内存中又会分配一个合适大小的槽用来存放缓冲池中的页。自适应哈希索引就是使用哈希表的实现方式，它对于字典类型的查找非常快速但是对于范围查找无能为力。

通过 space_id 和偏移量可以定义每一个页，所以这两个值用来定义一个页的哈希键。

## 全文索引

如果查询中有这样的需求，在某篇文章的内容中存在某个单词，则单纯使用 B+ 树索引并不能解决问题。**全文索引**就是将存储于数据库中的整本书或者整篇文章中的任意内容信息查找出来的技术。从 InnoDB 1.2.x 版本开始支持全文索引。

全文索引使用倒排索引来实现，它使用辅助表存储单词和单词自身在一个或者多个文档中所在位置之间的映射，所以一般就有两种形式：

* inverted file index：形式为 {单词，单词所在文档的 ID}
* full inverted index：形式为 {单词，(单词所在文档的 ID，在具体文档的位置)}

在 InnoDB 中使用的是 full inverted index 的方式。而倒排索引需要一张辅助表，这张辅助表是一张持久的表，存放在磁盘上，同时在 InnoDB 中还是用了一个叫 FTS Index Cache 的缓存结构来提高全文索引的性能。它是一个红黑树结构，按照数据来排序。而为了支持全文索引，InnoDB 中还引入了一个 FTS Document ID 的概念，它和 word 自动产生映射(具体细节在使用中了解)。

文档中分词的插入操作是在事务提交时完成的，然而删除操作在事务提交时并不会删除辅助表中的记录，而是删除缓存中的记录，那么对于辅助表中被删除的记录，则会保存到一个 DELETED 辅助表中。而在存储引擎中允许用户手工将已经删除的记录从索引中彻底删除。

最后在存储引擎中有一个 stopword 列表的概念，说明其中的 word 不参与分词操作。

在 MySQL 中通过 MATCH()...AGAINST() 语法来进行全文索引查询，MATCH 指定了需要的列， AGAINST 指定了使用何种方式来查询。默认采用的是 Natural Language 模式，表示查询带有指定 word 的文档。要注意查询返回的结果是按照**相关性**降序排列的。计算相关性和下面四个条件有关：

* 是否在文档中出现
* 文档中出现的次数
* 在索引列中的数量
* 多少个文档包含

还有一种模式是 BOOLEAN 模式，会使用一些符号来指出查询时需要满足的条件。最后 MySQL 还支持全文索引的扩展查询，这种查询通常是在查询的关键词太短，用户需要隐含知识时进行的。

