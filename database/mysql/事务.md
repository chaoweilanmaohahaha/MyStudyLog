# 事务

事务是数据库区别于文件系统的另一个重要特性之一，事务它把数据库从一个一致的状态转换为另一个一致的状态，在数据库提交工作时要么确保所有的修改都已经保存了，要么所有的修改都没有保存。

事务可以由一条非常简单的语句组成，也可以由一组复杂的语句组成。理论上事务应当具有严格的定义，既满足通常意义的 ACID 特性，但是数据库厂商并没有严格去满足，而对于 InnoDB 而言默认事务的隔离级别时 READ REPEATABLE，完全满足 ACID 特性，其中包括：

* A：原子性，事务中任何一个 SQL 语句执行失败，都会导致执行成功的 SQL 语句撤销，只有所有操作执行成功才算成功；
* C：一致性，事务将数据库从一种状态转变为下一种一致的状态，完整性约束没有被破坏；
* I：隔离性，要求每个读写事务的对象对其他事务的操作对象能相互分离，即操作对其他事务都不可见；
* D： 持久性，事务一旦提交，其结果是永久的。就算发生宕机，数据库也是能恢复的。

事务能够被分为多种不同类型，比如：

* 扁平事务：这个是事务中最简单的一种，所有的操作都在一个层面上，从 BEGIN WORK 开始，到  COMMIT 或者 ROLLBACK 结束。**它的缺点就是不能提交或者回滚事务的一部分。**
* 带保存点的扁平事务：这种事务是保证在执行过程中出现的错误不会导致所有的操作都无效。因此通过一个**保存点**的概念以便在之后发生错误时能够回到保存点当时的状态。
* 链事务：可以说是保存点模式的变种，这是因为保存点是易失的，所以系统崩溃的时候保存点也会消失。链事务的思想就是在提交一个事务时释放不需要的数据对象，然后将上下文传递给下一个事务，这是一个原子操作。链事务中的回滚仅限当前事务。
* 嵌套事务：这是一个层次结构框架，由一个顶层的事务控制着各个层次的事务。嵌套的事务称为子事务。如果把它想象成一棵树，则叶子节点才为扁平事务，子事务的提交并不能马上生效，只有顶层事务提交后才算正式提交。树中任何一个事务的回滚都会导致子事务回滚。(InnoDB 不支持原生)
* 分布式事务：是一个在分布式环境下运行的扁平事务，需要根据数据所在的位置访问不同的网络节点。

## 实现

事务的原子性、一致性和持久性通过数据库的 redo log 和 undo log 来完成。注意的是 redo 通常是物理日志，记录页的物理修改；undo 是逻辑日志，根据每行记录进行记录。

### redo

重做日志来实现事务的持久性，由重做日志缓冲和重做日志文件来实现。InnoDB 通过 Force Log at Commit 机制实现，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化。每次写入重做日志文件后，InnoDB 都会调用 fsync 操作。**区别一下二进制日志，二进制日志更像是逻辑日志记录 SQL 操作，而重做日志绝对是物理日志，记录的是每个页的修改。**

重做日志是以 512 个字节进行存储的，所以重做日志缓冲、重做日志文件都是以块的方式保存的。由此重做日志是不用 doublewrite 的。重做日志除了本身外，还有一个日志头和一个日志尾，这个大小包括在 512 个字节内。其中是有一个 log group 的概念，代表多个重做日志，并且每个组中文件大小相同。

不同的数据库有不同的重做日志格式，InnoDB 中日志格式是基于页的，其中包括了：

* redo_log_type：日志类型
* space：表空间 ID
* page_no：页偏移
* redo_log_body：部分根据不同类型，有不同的存储内容。

在 InnoDB 中使用了 LSN 的概念，代表日志序列号，它代表了重做日志写入的总量，并且代表了 checkpoint 的位置。

**最后 InnoDB 无论上次运行是否正常关闭，都会尝试进行恢复操作**，并且有了 checkpoint 的帮助，所以只需要恢复 checkpoint 开始的日志部分。

### undo

事务的回滚操作需要 undo 日志来实现，所以在对数据库进行修改的时候除了会产生大量的 redo 日志，还会产生一定量的 undo 日志。undo 内容存放在数据库内部的一个特殊段—— undo 段中，它位于共享表空间。

**undo 是逻辑日志，它只是将数据库逻辑恢复到原来的样子，但是数据结构和页本身可能和原来不太一样。**

使用 undo 除了回滚，还有一个作用是实现 MVCC，即非锁定读取。undo log 也会产生 redo log，这是因为 undo log 也要持久保护。

undo log 也是采用段来管理，InnoDB 中存在有回滚段，而一个回滚段就记录了 1024 个 undo log 段，那么数据库会在 undo log 段中进行页申请。当事务提交之后并不能马上删除掉 undo log 和所在的页，因为可能还有其他的事务需要使用，最终删除需要 purge 线程来判断。InnoDB 中的一个 undo log 页还可以被重用，这是为了防止空间的浪费。

undo log 在 InnoDB 中一共有两种：insert undo log 和 update undo  log。insert 操作只对事务本身可见，所以用完就能直接删除；update undo log 是对 delete 和 update 操作产生的日志，因为此信息用来给出 MVCC，所以不能立刻删除，需要暂时存放。在 InnoDB 中查看着个日志的信息并不方便，最多在 information_schema 中添加了 INNODB_TRX_ROLLBACK_SEGMENT 和 INNODB_TRX_UNDO 两张表。

上面提到过对于 update undo log 而言，真正的删除要等到 purge 操作时。只有当当前的 undo log 不再被任何的事务引用时才会被真正删除。但是由于 undo log 的重用，一个 undo 页中可能有多个不同事务的 undo log。InnoDB 是按照历史列表的顺序来清理的(按照事务提交顺序组织 undo log)，这样相当于从最老的事务开始清理。

最后要提到当前的数据库提供了 group commit 的功能，就是说经过一次 fsync 就能确保多个事务日志被写入文件(细节略过)。

## 事务语句

在 MySQL 命令行默认设置下，事务都是自动提交的，也就是说执行完 SQL 语句后马上执行 COMMIT。那么一般而言有以下这些控制事务的语句：

* START TRANSACTION|BEGIN：显示开始一个事务，在存储过程中只能使用前者
* COMMIT：提交事务
* ROLLBACK [TO id]：回滚事务，回滚保存点不会真的结束事务，而需要显示回滚。
* SAVEPOINT id：创建一个保存点
* RELEASE SAVEPOINT id：删除一个保存带你
* SET TRANSACTION：设置事务隔离级别

除此之外，在 MySQL 中也存在很多隐式提交的语句，不如 DDL 语句、修改 MySQL 架构的语句、一些管理语句等。为什么要知道隐式提交的问题，因为如果你想要知道处理事务的能力 TPS，那么在 InnoDB 中计算它时要注意所有事务要是显示提交的，隐式提交的理论上不会记录到 commit 数据中。

## 隔离级别

实际上很多数据库都没有提供真正的隔离，许多实现最终在性能和正确性上做了妥协。SQL 标准定义的隔离级别如下：

* READ UNCOMMITTED：浏览访问
* READ COMMITTED：游标稳定
* REPEATABLE READ：可重复读，没有幻读
* SERIALIZABLE：序列化

隔离级别越低，事务请求的锁越少或者保持锁的时间就越短，那么 InnoDB 默认支持的隔离级别是 REPEATABLE READ。在 SERIALIZABLE 隔离级别下，InnoDB 会对每个 SELECT 语句后自动加上 LOCK IN SHARE MODE。但是其实在 RR 下已经可以做到很好地隔离了，所以 SERIALIZABLE 一般用于分布式事务中。

## 分布式事务

InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务实现了分布式事务。并且 XA 事务允许不同数据库的分布式事务。分布式事务是指允许多个独立的事务资源参与到一个全局事务中，并且对于这个全局事务而言所有参与的事务要么全提交，要么全回滚。

XA 事务由一个或者多个资源管理器，一个事务管理器和一个应用程序组成。

分布式事务通常使用两阶段提交，第一阶段需要参与全局事务的节点准备，告诉事务管理器准备好提交了；第二阶段由事务管理器觉点要提交还是回滚。通常而言是通过使用编程语言来实现分布式事务的操作的，比如 JTA。

除此之外数据库还使用内部 XA 事务，比如说 binlog 和 InnoDB 之间就会使用。

## 长事务

顾名思义指时间较长的事务，因此需要很长时间才能完成。一般而言对于长事务，需要转化为小批量的事务来处理。这样当某个小事务发生错误时，只需要回滚一部分数据。

---

## 事务中不好的习惯

* 在循环中提交
* 使用自动提交
* 使用自动回滚：可能丢失错误信息

