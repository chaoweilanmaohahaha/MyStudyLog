# 表

InnoDB 中，表就是关于特定实体的数据集合，这也是关系数据库的核心。在 InnoDB 中表是根据主键顺序组织的存放的，这种存储方式的表称为**索引组织表**(https://www.cnblogs.com/youngerger/p/8446399.html , https://blog.csdn.net/flighting_sky/article/details/8868387)。每张表中都有一个主键，如果没有定义主键存储引擎也会按照一定的方式创建主键。如果表中有多个非空唯一索引时，选择建表时第一个定义的非空位置索引作为主键。

## InnoDB 逻辑存储结构

从 InnoDB 的逻辑存储来看，所有数据都被放在一个空间中，这个空间称为**表空间**。表空间又由段、区、页组成。

表空间是 InnoDB 存储引擎逻辑结构的最高层，所有数据都存放在其中。比如说对于共享表空间 ibdata1，那么所有的数据都会放在这个表空间中，假设设置了独立表空间，则每张表的内的数据就存放在独立的表空间中。

每个表空间都有多个段组成，包括数据段、索引段、回滚段等。由于 InnoDB 存储引擎的表是索引组织的，所以数据和索引就成为了一个东西，数据段是 B+ 树的叶子节点，索引段是 B+ 树的非索引节点。

每个段中包含多个区，其中区的概念就是指连续多个页组成的空间，在任何的情况下每个区大小都为 1MB。为了保证其中页的连续性，就需要存储引擎一次性申请 4-5 个区，一般一个区中有 64 个页(*在使用 innodb_file_per_table 后，创建的表都是 96K，这是特殊情况*)。

页，或者说称为块，是 InnoDB 中磁盘管理的最小单位。在 InnoDB 存储引擎中默认一个页是 16KB，在 1.2.x 版本之后可以调整为 4K，8K 等。

InnoDB 存储引擎面向行，也就是说数据按行存放，每个页存放的行记录有硬性规定。下面看看 InnoDB 的行记录格式。

### 行记录格式

InnoDB 中存放的是表中的一行行数据，在该存储引擎中提供了 Compact 和 Redundant 两种格式。

Compact 是 5.0 版本之后引入的，目的是为了高效存储数据，如果一个页中存放数据越多性能就越高。其中包括：

* 变长字段长度列表：按照列的顺序逆置，如果列长度小于 255 字节用一个字节表示否则用两个字节。
* NULL 标志位：指出哪些列存在 NULL 值
* 记录头：包括了删除信息，拥有记录数等属性
* 列数据：除了用户定义的列数据外，还有两个隐藏列事务 ID 和回滚指针列。

Redundant 行记录是老版的行记录存储方式，5.0 以后为了兼容页提供了这种存储方式，具体如下：

* 字段偏移列表：注意这个记录的是字段的偏移位置
* 记录头：也是记录了一些信息，比较不同的就是 n_fields 记录了记录中列的数量。
* 列数据：后面存放了各列的数据了。

存储引擎可能将一条记录中的某些数据存储在真正的数据页面之外，这个概念不一定说大的 BLOB 就一定会存储在页面之外，或者小的类型一定不会。只要当发生行溢出时，数据存放在页类型未 Uncompress BLOB 页中，当发生溢出时，页内会有数据指向当前的行溢出页。

在 1.0.x 版本之后 InnoDB 引入了新的文件格式，以前支持的 Compact 和 Redundant 称为 Antelope 格式，而新的文件格式称为 Barracuda，这个文件格式下有两种新的行记录格式 Compressed 和 Dynamic。这两种格式中对存放 BLOB 中的数据采用了完全的行溢出格式，而 Compressed 行记录在存储行数据时还会使用 zlib 算法进行压缩。

### 数据页结构

InnoDB 中存储引擎最小的磁盘单位是页，如果页类型为 B-tree Node 的页存放的就是表中行的实际数据。在引擎中一个数据页有如下 7 个部分组成：

* File Header：记录头信息，这些信息是有关该页在环境中的一些信息
* Page Header：记录该数据页的状态信息
* Infimum 和 Supremum Records：每一个数据页中有两个虚拟的行记录，这两个行记录是用来限定记录的边界。Infimum 代表比该页中任何主键值都要小的值，而 Supremum 代表比该页中任何主键值都要大的值。
* User Records：实际存储的行记录内容
* Free Space：空闲空间
* Page Directory：页目录，存放了记录的相对的位置，而这是一个稀疏目录，这个是方便快速查询。B+ 树索引本身是无法找到具体的记录的，只能找到该记录所在的页。找到了该页之后要使用 Page Directory 进行二分查找。
* File Trailer：这是为了检测该页是否已经完整写入磁盘，这里面只有一个校验和和一个 File header 中一样的 FIL_PAGE_LSN 字段，这用来和 File Header 中的值进行比较。

### Named File Formats 机制

可以发现上面也提到了，由于为了适应新的功能，所以会开发新的类型的数据页结构。那么 InnoDB 存储引擎通过 Named File Formats 机制来解决不同版本下的页兼容性问题。新的文件格式总是包含之前的版本的页格式。比如 旧版本呢的 Antelope 页格式被包含在了 Barracuda 页格式中。

## 约束

关系数据库本身能够保证数据的完整性，几乎所有的关系型数据库都提供了约束机制，数据完整性一共有三种形式：

* 实体完整性保证表中有一个主键
* 域完整性保证数据每列的值都满足特定的条件
* 参照完整性保证了两张表之间的关系

在 InnoDB 中一共提供了 Primary Key、Unique Key、Foreign Key、Default 和 NOT NULL。创建某个约束主要通过两种方式，**一种是在表建立的时候就进行约束的定义，还有一种就是使用 ALTER TABLE 命令来进行创建约束**。对于主键约束而言默认约束名为 PRIMARY，而对于 Unique Key 约束而言默认约束名和列名一样。

> 理论上用户创建了一个唯一的索引就创建了一个唯一的约束，但是其实约束就是一个保证数据完整性的逻辑概念，而索引是一个数据结构，它在数据库中也代表着物理的存储方式。

在默认情况下，MySQL 数据库允许非法的或者不正确的数据插入和更新，并且可能在数据库内部转换成一个合法的值，数据库最多会报一个 warning 信息，如果要严格审查数据则需要设置 sql_mode 为 STRICT_TRANS_TABLES。

MySQL 数据库不支持传统的 CHECK 约束，所以只能通过 ENUM 和 SET 进行限制。

完整性约束通常也可以使用**触发器**来实现，它的作用就是在执行 INSERT、DELETE 和 UPDATE 命令之前或之后自动调用 SQL 命令或存储过程。使用 CREATE TRIGGER 可以用来创建一个触发器。

**外键**用来保证参照完整性，在用户执行 CREATE TABLE 时就添加外键，也可以在表创建后通过 ALTER TABLE 命令来添加。在定义外键时选择 ON DELETE 和 ON UPDATE 表示在对父表进行 DELETE 和 UPDATE 操作时，对子表所做的操作，其中包括：

* CASCADE：同样的操作
* SET NULL：更新为 NULL
* NO ACTION：抛出错误
* RESTRICT：抛出错误

## 视图

视图时一个命名的虚表，它由一个 SQL 查询来定义，而它是没有实际的物理存储的。视图的主要用途就是被看作是一个抽象，视图允许程序不关心基表结构，实际可以做到一个安全层的作用。

虽然视图是一个虚拟表，但是用户对某些视图进行更新操作的时候，本质就是通过视图的定义来更新基本表，我们把可以进行更新操作的视图称为可更新视图。

在 Oracle 数据库中支持物化视图，这就是根据基表实际存在的实表。而查询重写操作是当对物化视图的基表进行查询的时候，数据库能够自动判断能否通过查询物化视图来直接得到最终的结果。而物化视图的刷新则是当基表发生了 DML 操作后，物化视图采用某种方式和基表进行同步。

MySQL 不支持物化视图，所以如果有需要的话，用户需要通过一些机制实现物化视图的功能。

## 分区表

分区的过程就是将一个表或者索引分解成更小可管理的部分。如果我们从逻辑上来看只有一个表或者索引，但是在物理上这个表或索引可能由数是个物理分区组成。MySQL 支持水平分区，并且 MySQL 分区是局部分区索引，一个分区中既存放了数据也存放了索引。在 MySQL 中支持一下几种类型的分区：

* RANGE 分区：行数据基于属于一个给定连续区间的列值被放入分区；
* LIST 分区：和 RANGE 分区一样，但是 LIST 分区面向的离散的值；
* HASH 分区：根据用户自定义的表达式的返回值来进行分区；
* KEY 分区：根据 MySQL 数据库提供的哈希函数来进行分区；

*注意表中如果存在主键或者唯一索引时，分区列必须是唯一索引的一个部分，否则就可以是任意列*。

启用分区之后表不再由一个 ibd 文件组成了。

**子分区**是在分区的基础上再进行分区，像 MySQL 数据库允许在 RANGE 和 LIST 的分区上再进行 HASH 或者 KEY 的子分区。建立子分区的时候要注意每个子分区的数量必须相同；要在所有的分区中都是用 SUBPARTITION 明确定义任何子分区；每个 SUBPARTITION 子句必须包括子分区的一个名字；子分区的名字必须唯一。

MySQL 数据库允许对 NULL 值做分区，但是根据不同的分区类型，处理 NULL 值的方法不尽相同，这点需要注意。

最后从 5.6 版本开始，允许分区或者子分区中的数据和另一个非分区的表中的数据进行交换，也就是可能将分区中的数据直接导入到非分区的表中。但是这个操作有许多限制：

* 两张表应该有相同的表结构
* 非分区表的数据要在交换的分区内
* 被交换的表不能有外键或其他表对其有外键引用
* 用户需要 DROP 的权限
* 使用这个功能不会触发两张表上的触发器
* AUTO_INCREMENT 列会被重置