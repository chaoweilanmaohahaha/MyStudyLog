# 并发控制

在故障对策中也稍微有那么点带到，事务的执行是可以并发的，并且事务之间可能会因为相互的影响而造成数据库状态的不一致，所以我们需要通过一些手段控制每个事务执行的正确性。不同的事务通过某种顺序执行，这是通过调度器来完成的，这个保持一致性的整个过程称为**并发控制**。

我们通常碰到的事务都需要读写请求传递给调度器，如果数据库元素并不在缓冲区，就需要借助缓冲区管理器。

## 串行调度

上面讲的**调度**是指一个或者多个事务的重要动作的一个序列。注意这里并不是说是指重要的动作，而不是事务。那么如果我们研究事务之间的并发控制，就认为这些动作都发生在主存中。

所谓的**串行调度**，我们形式化地认为，如果调度后的过程类似于一个事务一个事务这样执行的，则该调度是串行的。但是事实上我们也知道，这种串行调度是基本不存在的，所以一般我们提到的是一种叫做**可串行化调度**。如果说我们让某个调度在一定程度下和串行调度是等效的，则说明该调度是可串行化的。

如果我们能够确定一个调度是否可以串行化调度是最好的，这和事务的细节有关，那么如果我们简单地认为事务执行只有读R和写W需要考虑，那么我们将事务T可以写成一串具有读和写的序列。

## 冲突可串行化

冲突可串行化比单独的可串行化条件还要进一步。我们允许思考事务中的动作可以交换顺序。

### 冲突

不冲突的动作是可以交换的，因为交换它们的顺序对事务执行本身不会有影响，这种包括：

* 在不同事务中对元素的读
* 如果某个事务读X元素，某个事务写Y事务；
* 某个事务写X元素，某个事务写Y事务；

那么就存在一些情况是无法进行交换的，比如：

* 同一个事务的读写
* 不同事务对同一元素的写
* 不同事务对同一个元素的读和写

如果我们可以通过一系列非冲突的交换将一个调度序列转换成另一个，称这两个调度是**冲突等价**的。那么很显然，如果它和某个串行调度等价，则说明这个调度序列是冲突可串行化的。

我们怎么判断调度序列是否可以冲突可串行化呢？借助优先图我们可以判断。我们假设调度S中涉及了两个事务T1和T2，如果T1优先于T2，则满足：

* 动作A1在A2之前
* A1和A2操作同一个数据库元素
* A1和A2有一个操作是写

以上的2和3对应了冲突中的条件，这也是为什么这两个动作无法交换的原因。根据这个原则，我们可以根据给定的调度序列画出一个有关事务的执行优先图，其中结点代表了事务，箭头代表事务执行顺序。如果在这个优先图中不存在环，则说明这个调度是冲突可串行化的。

## 锁

这是调度器中最常用的结构，事务需要获得访问元素上存在的锁，来防止其他事务在同一时间点获取这些元素。在数据库中，实现锁的方法是事务在读写数据库元素的同时需要申请锁和释放锁，这可以保证事务的一致性和事务的合法性，我们假设申请和释放锁的动作分别为L和U。

调度器所要做的，就额外需要判断调度的请求是否被同意，如果请求没有被同意，那么事务就要被延迟，直到某个时刻调度器同意了该请求。

### 两阶段封锁

单纯的封锁只要保证在读和写某个元素之前需要申请锁，在使用完之后释放锁。两阶段封锁对这些动作加上了时间点上的限制，它要求必须保证封锁的请求优先于所有解锁的请求。为什么需要提出这样一个要求，是因为如果把S的调度序列写出来会惊奇的发现，它是冲突可串行化的。

### 排他锁和共享锁

我们已经知道为什么要实施封锁了，那么就要考虑锁的有效性。对于事务读X元素时加锁是不能回避的，因为我们必须保证当X不能被写入一个新的值；同理写操作就不用说了。我们能够发现对于写操作所加的锁更加的苛刻，因为它禁止读又禁止写。所以这里为了区分读和写的不同，设置了共享锁和排他锁，定义为SL和XL。共享锁是可以有任意数目的，但是排他锁就只能有一个。

所以我们要包含这些规则：

* 读动作前包含SL或者XL锁，并且中间没有U。
* 写动作之前必须包含XL锁，并且中间没有U。
* 在任意的SL或者XL前都不能有其他U操作。
* 如果出现XL(X)时，不能出现其他XL(X)或者SL(X)的操作。
* 任意SL(X)操作后面不能出现任意的XL(X)，除非中间出现U。

那么现在我们已经有了封锁的策略，但是电脑也需要直到何时能够对单个元素进行封锁，这就有了相容性矩阵，它是描述锁-管理策略的一个简单方法。行属性代表申请的锁，纵属性代表持有的锁，如果能够对该元素授予该锁就为真，否则为假。

### 锁升级

当一个事务在之前的阶段对X授予了共享锁，也就是在该阶段允许其他事务访问X，但是当它准备好后，就需要对X进行修改。一个友好的方法是在适当的时候将共享锁升级为排他锁。但是前提是该元素上已经没有其他共享锁或者排他锁了，这可能带来死锁的可能，如果两个事务同时对一个元素升级为排他锁。

### 更新锁

这种锁赋予了事务读属性的权力，没有赋予写元素的权力。但是也只有这种锁能够在适当的时间点升级为写锁，在这种情况下，普通的写锁就不能升级了。这里的规则就需要修改一下，如果X上有了读锁，那么它依旧可以被授予更新锁；但是如果已经有了更新锁，则任何其他的锁的无法被授予。

### 增量锁

很多的事务只是通过增加或者减少存储的值，而这种增量操作一般都是可交换的，如果有两个事务同时给一个元素增加或者减少某个值，那么无论顺序是怎样的，结果都是一样的。我们定义一种增量操作为INC。

我们需要一种名为增量锁IL，它的使用规则为：事务只有在持有X上的增量锁时才能对X进行增量操作，但是增量锁不能被赋予写和读的能力；事务之间可以对X施加多个增量锁，但是一旦这样，其他事务将无法授予X其他的锁。

## 封锁调度

那么既然已经有了这么多锁结构，调度器是如何使用这些锁的呢？在事务中插入锁，不是事务自身所包含的动作，包括释放锁这一个动作。调度器会为事务做这些事。调度器因此会被分为两个部分：

1. 首先当事务产生请求时，它会自动在事务所有读写地方加入锁动作，然后将该事务传递到第二部分；
2. 第二部分执行第一部分传递的动作，并且由它来决定到底时推迟还是执行。如果被推迟，则需要将该动作加入事务T的额外动作列表中。如果没有推迟，则如果是访问数据库的动作则执行，否则如果是申请锁的动作，则需要查看锁表。
3. 事务T无论提交或者中止，需要通知第一部分，由它来释放锁，然后再通知第二部分；
4. 由第二部分通知X上的锁可以被获得，此时如果有事务正在等待该锁，则可以继续执行。

### 锁表

锁表记录了数据库中元素和它的封锁信息的一个关系表。锁表中键是元素名，值包括：

* 组模式：是元素X上申请锁面临的最苛刻的要求，也就是优先级最高的一种锁。
* 等待：说明至少有一个事务正在等待A上的锁。
* 列表：描述了所有再A上持有锁的或者等待A的事务。

在上面已经描述了，那么当我们经过调度器的第一阶段时需要访问锁表来判断是否可以申请某个锁，如果在这个锁表中没有该项，就直接上锁然后加入新表项就可以了；如果存在锁了就要访问该元素的组模式，看一下它的相容性矩阵然后判断是否可以授予锁。

当我们要给事务T解锁，则T中关于属性X的锁项就要被删除，那么如果持有的锁和组模式并不一样，就不需要改变组模式；如果相同，则要查看列表中的事务申请的情况，找到一个何时的项更新新的组模式。如果我们发现对于这个元素有等待的事务，则需要给它们授予该锁，方法有：先来先服务，共享锁优先和升级优先。

### 锁层次

上面提到的上锁，都是对于数据库中的元素上锁，现在我们思考一下如何对大的元素，比如整个关系进行上锁，但是其中也应当允许对小的元素上锁。

解决管理不同粒度的锁结构叫做**警示锁**，这样的锁在数据库元素形成了嵌套或者层次结构时很有用。它一共有三种不同的级别：关系是最大的封锁元素；一个关系可以由多个块或者页组成；一个块可以包含多个元组。

警示锁的协议规则如下：

* 如果我们要在一个元素上加上共享锁或者排他锁，则需要从层次结构的根开始；
* 如果我们已经到达要加锁的元素了，那么直接加上就行了；
* 如果说我们还没到达需要加锁的元素，但是路径上遇到了警示锁，那么我们要根据警示锁的相容性矩阵来判断是否可以继续向下被授予锁。

#### 幻象

以上的封锁方法可能会出现问题，比如当我们封锁了已经在的项之后，之后插入的数据库元素怎么办呢？ 比如我在某个关系上添加了警示锁，并在所有元组上添加了S锁，如果此时再新插入一个元素，因为这会导致该元组在写时出现不可能串行化的行为。

> 数据库中出现的几种事务问题：
> 1、脏读（dirty read)：A事务读取B事务尚未提交的更改数据，并在这个数据的基础上操作。如果恰巧B事务回滚，那么A事务读到的数据根本是不被承认的。
>
> 2、不可重复读（unrepeatable read）：A事务读取了B事务已经提交的更改数据。
>
> 3、幻象读（phantom read):A事务读取B事务提交的新增数据，这时A事务将出现幻想读的问题。
>
> 4、第一类丢失更新：A事务撤销时，把已经提交的B事务的更新数据覆盖了。
>
> 5、第二类丢失更新：A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失。

克服幻想的方法就只能保证将元组插入或者删除的时候是看作整个关系上的写操作。

### 树级协议

最后看一下基于树模式的数据是如何加锁的。就考虑之前提到的B-树索引，如果在这里把单个结点看作是封锁的数据库元素，并且实施两阶段封锁，显然是不太可能的，因为对于索引的事务需要从B树的树根开始封锁，但是这样树根的锁就无法被解除。因此在这里就提出了一种树协议。

* 事务的第一个锁可以在树的任何结点上。
* 只有事务当前的父节点持有锁的时候，后续结点才能获得锁。
* 结点可以在任何的情况下解锁。
* 事务不能够对它已经解锁的结点重新在上锁。

## 时间戳

现在来看一下另外一种除封锁外的方案来保证系统的事务可以串行，时间戳就是其中的方案之一，如果我们能够记录之前读和写每个数据元素的时间戳，我们就可以确保串行的调度等价于实际的调度。

这样调度器需要给每个事务一个唯一时间戳T，我们可以使用系统时间作为时间戳，也可以维护一个计数器。并且给出几个附加位：

* RT：读X的事务中最高时间戳
* WT：写X事务中最高时间戳
* C：X的提交位，当前仅当最近写X的事务被提交，防止脏读。

### 不可实现行为

**过晚的读：**事务T尝试读数据库元素X，但是X的写时间表明X的值是在T执行以后写入的，即TS(T) < WT(X)。

**过晚的写：**事务T尝试写数据库元素X，但是X的读时间表明存在某个事务读到了T写入的值，但是却读到了另外的某个值，即WT(X) < TS(T) <RT(X)。

为什么会发生这些不可实现的行为，是因为对于调度器而言，它们假设事务的时间戳顺序必须是它们看起来执行的串行顺序。

### 脏数据

提交位的使用就是为了杜绝脏读。如果说在T事务读取U事务写入的值后，U中止了就发生了脏读，但是使用提交位C，当U还没提交时，显然是出现了脏读的问题。还有一个问题是Thomas写法则，也就是更晚的写操作可以直接跳过理论上应当已经发生的写操作。但是这也存在着问题，如果T比U先开始，但是T比U晚写了，那么T的操作应当被跳过，此时如果U在T提交之后中止，则T的写操作将无法被复原。

### 规则

作为调度器而言，它可以选择同意请求，也可以选择中止事务T或者推迟事务T。

1. 如果收到的是读请求，则
   1. 假设TS >= WT，那么如果C位为真，则同意请求，然后修改其他标志位；否则T将推迟到C位为真时读。
   2. 如果TS < WT，则这是过晚的读，应当中止T，然后回滚。
2. 如果时收到了写请求，则
   1. 如果TS >=RT 并且 TS >= WT，则可以为X写入新值，然后设置一下标志位
   2. 如果TS >=RT 并且 TS < WT，则X中已经有一个更晚的值了没那么如果前一个X的写已经提交则可以忽略写，否则我们需要考虑推迟T。
   3. 如果TS < RT 则发生了过晚的写，则需要回滚T。
3. 如果收到的时提交T的请求，则修改各个元素的C位。
4. 如果收到的时中止T的请求，则回滚T。

现在尝试着修改一下时间戳的功能，也就是除了维护自身的版本外，也要维护数据库元素的旧的版本，使得T被中止的操作能够继续执行。

## 有效性确认

这是最后一种可以保证事务一致性的一个手段，它也是和时间戳类似的一种乐观的控制方法。它和时间戳的不同在于，它维护的是当前的活跃事务正在做什么的记录，而不是保存读时间和写时间。

使用有效性确认，事务要分三个阶段来执行：

* 读：事务从数据库中读它的读集合中的元素
* 有效性确认：调度器比较该事务于其他事务的读写集合来确认该事务的有效性
* 写：事务往数据库中写入写集合中元素的值。

所以为了完成以上三个阶段，调度器要维护三个集合：START是已经开始但是尚未完成有效性确认的事务；VAL是已经确认但是尚未完成写的集合；FIN是都完成了的集合。

### 规则

如果事务碰到一下的情况则可能出现错误：

1. U已经经过确认，但是U在T开始前没有完成，T要读U写的数据；
2. U已经经过确认，U在T进入确认阶段前没有完成，T写U写的数据。

所以规则需要满足两点：对于所有经过确认且T开始前没有完成的U使得T的读集合与U的写集合交集为空；如果经过确认但是T确认前没有完成的U，则它们的写集合交集为空集。

----

## 三种方法的比较

### 存储

* 封锁：和上锁元素的个数成正比；
* 时间戳：每个元素都需要读和写时间；
* 有效性确认：记录当前活跃事务的一些读集合和写集合；

### 性能

* 封锁：推迟事务，避免回滚
* 其他两个：基本不推迟事务，选择回滚事务，但是都不会导致太多回滚，性能上还是比封锁开销小；如果单独比较，时间戳会更早捕获问题。