# 故障对策

这一章主要包括了数据的可恢复性这一个技术来谈，支持可恢复的基础技术是日志，在这里讨论三种不同类型的日志。

## 系统故障的模型

首先简要地看一下，在系统中可能会出现怎样的故障：

* 错误的输入：就是指输入的数据有错误，当时并没有被检查出来可能。那么这样的错误是可以通过编写数据库约束和触发器来找出的；
* 介质的故障：这是磁盘的局部故障，比如磁盘中有几位出现故障，但是这通常可以根据扇区之间的奇偶性校验检测到。如果规模较大的介质故障，则可以使用之前提到的RAID技术，恢复丢失的磁盘数据。或者使用备份磁盘来恢复。
* 灾难性故障：这种破坏说明磁盘介质被完全地破坏了，那么RAID技术就无法派上用场，只能借助预先的备份来恢复数据。
* 系统故障：系统故障是导致事务状态丢失的问题，比如掉电或者软件的错误。因为主存不是永久性的，所以事务步骤中的数据也因此消失了，并且这种故障麻烦在解决的方法并不是简单的重新运行事务，因为之前运行的事务的部分可能已经影响到了磁盘上的数据。(这里先跳过所有有关事务的内容)

## 日志

日志是一种结构化的文件，在数据库中日志记录记载了某个事务已经做过的事的情况，那么如果日志记录本身被保存在了非易失的存储器中，那么就可以在系统崩溃后将数据库恢复出来。回顾一下，系统故障的难点其实在于不仅要恢复当前运算到的数据，还要保证恢复出来的状态能够保证一致性。

日志管理器会负责日志中记录每个重要的事件，日志块最初是在主存中创建的，但是它会被写到磁盘上。日志的记录通常可以归纳为以下几种：

* <START T>：事务的开始；
* <COMMENT T>：事务T已经完成了，数据库中的元素不会被修改了，修改的数据应该会反映到磁盘上，但是我们不能保证什么时候完成写盘。
* <ABORT T>：事件T不饿能被成功的完成。

### undo日志

undo日志中记录的日志类型是更新的记录，它通常由一个三元组<T, X, v>表示，T代表事务，X代表元素，二v是X原来的值。因为数据库更新数据的时机发生在主存中，所以日志记录是在内存写时做出的。

undo日志必须根据以下的规则：如果事务T改变了数据库元素X，那么就必须有一个日志记录在X新值写到磁盘之前写入日志；如果事务提交了，则COMMIT记录必须在事务改变所有数据库元素并且写到磁盘后再写入日志。

为了强制将日志记录写到磁盘上，需要添加一条冲刷记录FLUSH LOG，这告诉缓冲区管理器要将之前修改的日志记录拷贝到磁盘上。

#### 恢复！！

现在假设已经发生了系统的故障，那么怎么使用undo日志来恢复数据库呢？

假设我们保证无论日志多么长，恢复管理器都可以查看整个日志，那么恢复管理器的第一个需要做的是划分已经提交的事务和未提交的事务。如果在扫描日志文件的时候发现了<START T>却没有发现<COMMIT T>，则说明崩溃前T对数据库的某些修改可能已经写到了磁盘上了。在这种情况下我们认为T是一个未完成的事务，应该被撤销。真正的恢复的过程如下：

* 从尾部开始扫描日志，如果T的COMMIT记录已经被扫描到，那么T提交的不会被撤销；
* 如果T是一个未完成或者中止的事务，那么恢复管理器必须将数据库中X的值改为v，防止在崩溃前X被修改了。做完这些后必须给未中止且未完成的每个事务T写入ABORT记录，然后刷新日志。

#### 检查点技术

如果每次恢复都要扫描整个日志文件未免有点烦，其实在一个事务完成了COMMIT后，日志的记录也可以随之删除，但是由于许多事务在同时执行，所以如此粗暴的执行。

我们使用检查点技术来弥补一些问题。执行检查点时我们需要：

* 停止接收新事务
* 等到所有活跃的事务提交了或者中止了，那么在日志插入COMMIT或者ABORT记录。
* 将日志刷新到磁盘
* 写入日志记录CKPT，刷新磁盘
* 重新开始接收事务

很明显，如果我们从尾部进行扫描，当我们看到了CKPT时，我们就知道了已经看过了所有未完成的事务了，因为CKPT之前的事务保证了它们的成功完成。

#### 非静止检查点

在上面提到的检查点技术中有一点提到，在执行检查点时需要停止接收所有的新事务，这样系统就像是完全暂停下来，那么非静止检查点虽然复杂，但是常常更受欢迎。它的步骤是：

* 写入日志记录<START CKPT(T1, T2, ... , Tn)>，并且刷新日志，其中T1，Tk都是活跃的事务。
* 在这个过程中允许其他事务的开始
* 当以上记录的活跃事务都已经完成，则写入<END CKPT>并且刷新日志。

如果使用这个机制，那么恢复时依旧从尾部开始扫描日志，当我们先遇到了END时，则我们知道在上一个START记录之前的所有记录都已经没用了，因此可以删除。如果我们先遇到了START，那么崩溃发生在了检查点中，那么只需要继续向后扫描检查记录中活跃的事务，如果找到了最早的那个事务就可以停止扫描了。

### redo日志

undo日志有一个问题，就是在事务改变的所有数据写到磁盘之前是不能提交这个事务的，这样数据就只能出现在主存中。redo日志机制是忽略未完成的事务并重复已提交事务所作的改变，这样保证COMMIT记录在任何修改后的值到达磁盘上之前就要出现在磁盘上，并且在日志中保存的三元组中v代表X元素的新值。

由此我们导出redo日志的规则：在修改磁盘上的任何数据库元素X之前，要保证和X的这一修改有关的所有日记记录都必须出现在磁盘上。其中包括与X有关的三元组和COMMIT记录。

#### 恢复

根据redo日志的性质可以发现，如果日志中没有COMMIT，就说明事务T的更新必然没有写到磁盘上，那么那些未完成的事务就可以被忽略。redo只关注已经提交的事务，因为无法判断这个数据是否已经被写到磁盘上了，因此根据redo中的新值来恢复数据。

* 确定已经提交的事务
* 从首部开始扫描日志，如果T是一个未提交的事务，则忽略；如果是一个已经提交的，则用数据库元素X写入值v。对于每一个未完成的T，日志中要为它写一个ABORT记录并刷新日志。

#### 检查点

已经提交的事务所做的修改需要一段时间才能将修改的数据拷贝到磁盘上，而这段时间又是不能确定的，因此在这里考虑的事情就更多了。我们必须要缓冲区管理器告诉哪些缓冲区是脏的，也就是说它们已经被修改了，但是还没有写到磁盘上。

* 我们依旧使用<START CKPT T1,T2, ... Tn>，其中这些标记的事务都是活跃的事务，并且刷新日志。
* 在做第一步时，如果由已提交事务已经写到缓冲区还没写到磁盘的数据写到磁盘；
* 然后写入END，刷新日志。

那么此时如果依靠检查点来恢复时，我们在崩溃前最后一条检查点记录时END，则我们首先知道的是在标记的这些活跃事务所作的这些修改已经被写入磁盘，所以没必要担心这些事务。但是在对应的START后开始的事务就可能并没有将数据移到磁盘上，所以我们只要关心最后一个提到的事务Ti后出现的事务就可以了。那么如果我们最后碰到的是START呢？这样我们就不能确定这些活跃的事务是否在磁盘上了，所以就需要搜索到上一个START，重做这些在该START后已经提交的事务。

### undo/redo日志

以上两种日志其实都有其缺陷，undo需要更多的磁盘IO，而redo日志则可能会增加需要使用的缓冲区数。那么有一种折中的做法，虽然需要维护更多的信息，但是就有更大的灵活性。

在这种日志中，它需要维护一个四元组，<T, X, v, w>，v是修改前值而w是修改后的值。它需要遵循的规则是：在由于某个事务T所做改变而修改磁盘上的数据库元素X前该记录需要出现在磁盘上，而COMMIT记录可以在磁盘上任何元素修改之或者之后出现。

#### 恢复

因为我们拥有了更多的数据，所以这允许我们通过恢复事务T所改变数据库元素的旧值来撤销事务T，也允许我们通过重复T所作的改变来重做T。所以它的策略就是从前往后扫描，重做所有已提交事务；从后往前扫描，撤销所有未提交事务。

#### 检查点

我们需要做如下步骤：

* 我们依旧使用<START CKPT T1,T2, ... Tn>，其中这些标记的事务都是活跃的事务，并且刷新日志。
* 将所有的脏缓冲区写入磁盘，而且我们需要刷新所有的脏缓冲区。
* 写入END，并刷新日志。

## 保护介质故障

### 备份

为了针对介质故障提供一种保护，一种比较有效的方法就是备份。如果有机会短暂的关闭数据库，我们就可以在某种存储介质上创建一个备份拷贝。如果我们要获取一个较近的状态，我们也可以使用日志。我们可以分两个不同的级别进行备份：

* 完全转储：拷贝整个数据库；
* 增量转储：只需要拷贝上一次备份后改变的那些数据库元素。

但是，如果不允许我们关闭较长时间来进行备份怎么办？我们可以使用**非静止转储**。非静止转储按照某种固定的顺序拷贝数据库中的元素，那么可能这些元素正在被改变，那么出现在备份中的值可能不一定是正确的，而这种差异可以使用日志来纠正：

* 写入日志记录START DUMP
* 根据采用的日志方式执行一个适当的检查点。
* 根据需要执行备份，确定数据已经到达安全的结点。
* 确保第二步中检查点以前的包括检查点日志都在数据库介质故障后仍能存在。
* 写入END

那么我们来考虑以下恢复，如果发生了介质的故障，那么我们：

* 根据备份恢复数据库，我们可以找到最近的完全转储，如果有后续的增量转储，则根据增量修改数据库
* 使用保留的日志修改数据库。

