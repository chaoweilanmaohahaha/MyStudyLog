# 查询编译

在查询的执行那一部分说的是sql语句已经到达了最后落实到从磁盘上找数据了，数据库是怎么应对的，而这里的查询编译部分讲解的是从我们输入sql语句开始到真正落实物理查询的中间这一部分，数据库系统中到底是怎么实现的。

## 语法处理和预处理

当我们真正输入了sql语句，想要将它转换成计算机懂得的一些语句需要做一定的转换。就像普通的编程语言一样，从编写到最后的执行中间还要经过许多层次。首先当我们输入了sql查询语句之后，先要经过的是语法分析器和语句预处理器。语法分析器的功能是将sql语句转换成语法分析树，预处理器则需要包括许多功能。

### 语法分析

语法分析树上的树结点包括两类，一类是原子级别结点，树结点上包括关键字、属性名称、常数、符号等等；而另一类结点可能包括了语法族的名称，比如<Query>类语法族。这里对于语法族简单的说明一下：

```
查询：
<Query> ::= SELECT <SelList> FROM <FromList> WHERE <Condition>
选择列表：
<SelList> ::= <Attribute>, <SelList>
<SelList> ::= <Attribute>
from列表：
<FromList> ::= <Relation>, <FromList>
<FromList> ::= <Relation>
条件
<Condition> ::= <Condition> AND <Condition>
<Condition> ::= <Attribute> IN (<Query>)
<Condition> ::= <Attribute> = <Attribute>
<Condition> ::= <Attribute> LIKE <Pattern>
```

其中的<Attribute>、<Relation>、<Pattern>是基本语法类，它们不是通过语法规则定义的，在语法分析树中它们都能用任意的字符串来替代，所以一颗语法分析树类似于如下的结构：

![database](..\img\database.png)

### 预处理

预处理器其实本身有许多功能，其中一个功能是视图的替换，如果在语句中出现的是一个虚拟视图，那么预处理器就会将该视图用sql语句替换掉。同样它还负责做一些语义的分析和检查，包括sql语句中关系的使用是否正确，属性的使用是否正确，类型的使用是否正确。

上面提到了虚拟视图的替换，这里讲一下，比如说我们在查询的语句的语法分析树的叶节点中出现了虚视图，那么此时这个虚视图其实本身也是一个查询语句的表示，我们对虚视图建立一个分析树，然后替换原来的叶节点，我们可以知道这颗语法分析书肯定和原来的是等价的。

## 关系代数

在讨论从语法分析树转向逻辑查询之前，先要简单浏览一下可能用到的关系代数，因为将语法分析树转换成逻辑查询所要做的，就是要将分析树转化为一个关系表达式，而如果能够使用一些定律去适当修改表达式使得查询更加高效是更好的。

交换律和结合律是最基本的，也就是说对于积，连接，交，并都满足交换率和结合率。

考虑选择运算$\delta$。如果我们对R上两个属性C1和C2同时进行选择等价于先对其中一个进行选择然后接下去一个进行选择；同理如果是选择C1或者C2中的属性，那么分别在R上对两个属性分开选择后使用集合并就可以完成等价的操作。对差运算，如果在R-S上对C进行选择，相当于在R上先做一次选择后与S再做差，这样的运算和积，连接、交运算时一样的。因为有了选择运算这些定理的保证，在转换的过程中就会出现一种叫做**下推选择**的操作。

关于投影的运算包括，投影是什么时候都可以引入的，因为只要剩下那些属性是不会用到的就可以。因此考虑在连接时R和S对L的投影，只需要获取R的连接属性的投影与S的连接属性的投影连接后再对L取投影即可，对积运算也是相同。

对积和连接而言，R和S关于属性C做连接，就相当于R和S做积运算后对C做选择。

对消除运算而言，下顺消除重复运算也是有用的，消除运算对积、连接、选择都可以进行下移。比如对R和S的积进行消除重复的元素，相当于先对R和S分别消除重复。

分组和聚集运算有的根据情况所定，毕竟聚集中存在着多种不同的运算符。比如如果在R中对L进行聚集可以先在R中加入投影去掉不必要的成分。

## 转换为逻辑查询

现在我们手中已经有了一棵语法分析树了，下一步要做的是将语法分析树转换为关系表达式，也就更贴近计算机所能理解的语句了。

其实对于不同的语句而言，都有一套初始的规则去改造的。比如最简单的SELECT语句族，如果我们形容它是如何转化为关系表达式的，就有以下的法则：

* <FromList> 用积运算可以代替
* 选择列表中可以对指定的属性进行选择运算
* 做一次对L的投影运算，其中L是选择列表中的属性。

但是里面也会存在复杂的情况，如果where后面的条件语句中包含了子查询怎么办？关于包含子查询的语法树需要引入一种叫做**两参数选择**的运算符。它使用一个选择符表示两参数，左结点时需要对其做选择的关系R，右结点时作用到R傻瓜的条件表达式。例如下图：

![database2](..\img\database2.png)

对这个中间结果我们还要进一步转换，如果其中包含了一个两参数选择，那么可以按照以下方法消除这个两参数选择：

* 如果我们认为Condition时T in S 的形式，则用S的表达式树替换Condition，如果S有重复，就需要在树根处加入一个去重运算。
* 用一个单参的选择运算代替两参选择，其中对应的参数时T和S之中的等值条件。
* 给单参选择运算一个参数，为两个关系即R和S的积。

因此上面的树会被转换成下面的形式：

![database3](..\img\database3.png)

接下去要对我们生成的一套粗糙的逻辑查询计划进行一个改进，改进的措施就是要借助关系代数运算的定律。选择运算应当尽可能向下推到表达式树中，如果其中有AND，那么就可以在每个条件中都下推，保证到上层运算的数据越少越好。并且可以适当将投影运算也下推，或者添加一些必要的投影运算，使得运算数据得到简化。选择和积有时是可以转换为等值连接的，而消除重复的运算有时是可以去除的。

最后满足一些结合律和交换律的一些操作是可以考虑进行结合和再分组的，这样相当于多个组别的数据是可以一起进行运算的。

## 代价估计

我们现在已经确定拿到了一个合适的逻辑查询表达式了，接下去就需要将这个表达式落到实处，转换成最终的物理查询。但是在转换成物理查询时要知道，一个逻辑表达式可以转换成多个物理查询表达式，所以选择最优的那一个就是这一步要做的事情。我们将这一步称为**基于代价的枚举**。要注意的是这是一种不准确的估计方法，但是能够帮助我们选择一种较好的物理查询。

### 投影运算估计

通常投影时元素的个数会缩小，因为某些成分会被消除，而扩展投影允许产生新的成分，我们每次大约可以估算出缩减的大小。

### 选择运算估计

对选择进行估计时，一般而言都是减少元组的数目的。那么假设我们分析的S是对R进行选择，A=c其中A是R中的属性，c是属性A的一个候选值。则我们有如下估计：

* T(S) = T(R) / V(R, A)

上面的估计是在等值选择下的估计，但是如果是不等值估计则十分困难，那么在数据库中我们假设不等值比较将大约返回三分之一的元组，所以如果对于一个A<c的选择，用一下估计：

* T(S) = T(R) / 3

那么当我们遇到AND选择时，就使用级联方法计算；如果遇到OR的情况，就相对比较复杂，则计算的方法是假设它们独立的话，S的元组是n(1-(1-m1/n)(1-m2/n))，其中假设n个元组中有m1个满足第一个条件，m2满足第二个条件。

### 连接运算的估计

对于一般的连接而言，我们考虑：等值连接的结果的元组数在考虑到变量名的变化之后按照自然连接计算；其他连接可以看成积运算之后进行一次选择。

那么下面看以下自然连接，省略以下中间的分析结果，我们就只看最终的结果了：

T(R con S) = T(R)T(S) / max(V(R, Y), V(S, Y)) Y是公共属性。

如果Y是多个属性，则对于每个Y中的值y，则需要每一个都除于一次max(V(R, y), V(S, y))。

如果是多个自然连接的情况，那么需要满足一条规则：就是从每个关系中元组数的积出发，对于至少出现了两次的属性A，除以除了V(R, A)中最小的那一个。

### 其他运算估计

#### 并

对于包的并则大小为两者之和，集合的并采用两者和取中间值。

#### 交

选取较小值的一半。

#### 差

选择T(R) - T(S) / 2。

#### 消除重复

取T(R) / 2和所有V(R, ai)之积中较小的一个。

#### 分组和聚集

和消除重复相同。

## 计划选择

上面已经知道了如何估计各个运算的代价了，那么对于查询优化器而言总是在构造查询计划的过程中计算表达式的代价。那么从这里开始就要思考通过已经大致计算出的各种可能的代价中，挑选出一种合适的物理查询方法来执行。

观察发现，其实在上面提到各个统计量的时候都需要明确给出才能进行计算的，那么这些统计量是哪里来的呢？现在的DBMS中允许用户或者管理员显示做统计信息的统计，并且根据命令更新数据。另外DBMS也会给出一些机制比如直方图等等方法来给出属性的各个值。

对于有关查询和子查询代价的一个估计是有利于应用查询的启发式变换的，一些相关的启发式变换势必会改变到查询计划的代价，而此时根据转换之前和转换之后的代价进行比较，我们能够判断是否需要执行这样的变换。在这个过程中涉及的只是逻辑层面的一个代价估计，因此只需要使用上面提到的一些统计量粗略估计一下就行。

那现在真的碰到从逻辑查询转向实际的物理查询了，如何去选择合适的物理查询呢？一般而言我们有两种搜索所有物理计划的方法：自顶向下和自底向上。而谈及具体使用的方法有哪些主要包括：

* 启发式选择：使用怎样选择逻辑查询就怎样选择物理查询；
* 分支界定计划：这个方法最常用到，使用启发式的方法给整个逻辑查询计划找一个好的物理计划，代价为C。那么当考虑其他子查询的时候，如果某个子查询的代价大于C则去除该子查询。
* 爬山法：从一个选定的物理计划开始，给它适当微调寻找到一个比较临近的计划，随后我们保证小修改并不能将代价降低；
* 动态规划：对于每一个子表达式，只保留最小的代价的计划。

### 选择连接顺序

代价优化中有一个很烦的课题，就是处理三个或者三个以上关系的连接顺序问题。连接方法大多数是不对称的，两个参数能够代表的意义往往是不同的。比如说我们希望使用一趟算法来处理连接，那么就要使用较小的关系来放入主存进行连接，这种关系称为**构造用关系**；而另一个一块一块读入进行比对的关系称为**探查用关系**。

#### 连接树

对于连接而言，我们一般把估计值较小的那一个参数作为左参数，这样我们可以构造出一个左深连接树。如果一棵树种，所有的右子树上的结点都是叶节点，那么它就是一颗左深树。使用左深树后，对于一个给定树叶的可能的左深树的数目比普通树的数目少，便于查询，并且这种结构方便和通用的一些连接算法进行交互。

那么如果使用左深连接树考虑对实际连接的物理查询计划生成有什么帮助，如果就一趟连接而言，并且保证构造用关系在左边，那么所需要的内存比其他情况都会少；如果是嵌套循环连接，外层循环的关系在左边，则可以避免多余一次地构造中间关系。

当我们已经有这样地结构来存放了，我们就用如下的几种方法来选择连接的顺序和分组：

**动态规划算法：**个人的理解和之前学习的动态规划的算法比较类似，需要建立一个全局的表来存放中间关系，然后从这个表中进行归纳。

**贪心算法：**虽然这个方法没有动态规划那样智能化，但是它是使用的较为普遍的方法，因为它通常比上述的动态规划搜索量要小很多，那么贪心的方法很简单，就是找到估计连接种最小的那一个开始来进行连接。

## 落实物理查询计划

要将一个逻辑查询计划变成完整的物理查询计划还要经过几个步骤：

* 对查询计划的算法选择
* 关于何时将中间结果物化，何时它们将会被流水操作的决定；
* 物理查询计划运算符的注释

其实对于查询计划的算法选择在之前计算代价的时候多多少少已经知道怎么做了。执行连接的原则也可以通过一些估计值来进行选择，这里就不详细展开了。

主要看看最后一个重要的话题，那就是流水和物化。如果我们执行一次查询计划是对运算进行适当的排序，并且将每个运算的结果存储在磁盘上直到它被另一个运算所需要，这个称为**物化**。但是执行一个查询计划更巧妙的办法是一次同时交错进行几个运算，由运算产生的元组可以直接传递给它的其他运算，而不需要物化到磁盘上，这个过程称为

### 一元的流水

一元运算针对选择和投影，我们可以通过迭代器，每次需要一个元组时就给消费者调用GetNext。如果对于投影而言，可能只需要调用一次，但是对于选择而言可能要调用多次。

### 二元的流水

二元的使用一个缓冲区将结果传递给消费者，一次传递一个块。

一般来说逻辑计划的每个运算符称为物理计划的一个或者多个运算符，逻辑计划的叶子称为物理计划的适用于关系的一次扫描运算符。另外当物化结果被访问，则物化会被一个存储Store运算符指示为应用及那个要被物化的中间过程，然后跟随一个合适的扫描运算符。那么根据不同功能的运算符我们分成多种物理查询的运算符，这些运算符时在DBMS中的：

#### 叶子运算符

* TableScan：顺序读入存放R关系的元组的块；
* SortScan：读入元组并按照某列属性排序；
* IndexScan：根据某个条件进行检索，或者根据某个属性检索；

#### 选择运算符

* Filter：在关系上选择某个属性

剩余的运算符就不一一列出了。