# 集群

redis 集群式 redis 提供的分布式数据库方案。它通过分片来进行数据的共享，复制和故障转移。

## 节点

redis 集群由许多个节点组成，在开始阶段需要把所有独立的节点连接起来形成一个包含多个节点的集群。连接多个节点使用 CLUSTER MEET 命令来完成。这个命令相当于使得某两个节点进行握手，从而建立连接。

```
CLUSTER MEET IP PORT
```

节点说白了就是 redis 运行在集群模式下的一个服务器，它通过 cluster-enabled 配置来看是否启动了集群模式。集群中的服务器依然会使用在单机模式下使用的服务器组件，并且依旧使用 redisServer 来保存服务器的状态，使用 redisClient 来保存客户端的状态。

### 集群有关的数据结构

每一个节点都会使用一个 clusterNode 结构来记录自己的状态，这个数据结构是集群模式下独有的：

```
struct clusterNode {
	mstime_t ctime;
	char name[REDIS_CLUSTER_NAMELEN];
	int flags;
	uint64_t configEpoch;
	char ip[REDIS_IP_STR_LEN];
	int port;
	clusterLink *Link;
	
	unsigned char slots[16384/8];
	int numslots;
}
```

这个结构中有着一个节点在集群中的必要的信息，同时还有一个 clusterLink 结构，这个结构保存了连接节点的所有有关信息：

```
struct clusterLink {
	mstime_t ctime;
	int fd;
	sds sndbuf;
	sds rcvbuf;
	struct clusterNode *node;
}
```

在这个结构中 fd 代表了节点之间连接的套接字描述符， sndbuf 和 rcvbuf 分别代表节点通信时使用的输入缓冲区和输出缓冲区。还有一个 clusterState 结构，这个结构记录了从当前节点的视角下，这个集群目前处于的状态：

```
struct clusterState {
	clusterNode *myself;
	uint64_t currentEpoch;
	int state;
	int size;
	dict *nodes;
	
	clusterNode *slots[16384];
}
```

其中 state 代表当前这个集群式处于在线还是下线状态；size 指处理槽的数量。其中有一个 nodes 字典字段，key 为节点的名字(clusterNode 中的 name)，value 是一个 clusterNode 结构，而 myself 指针指向代表自己的 clusterNode 结构。

在使用 CLUSTER MEET 建立连接的过程中，发送节点首先会为被发送节点创建一个 clusterNode 结构并添加到 nodes 结构中，被发送的节点通过握手后会将发送节点添加到自己的 clusterState 的 nodes 字段中。随后发送节点通过 Gossip 协议将信息传播给集群中其他节点，让其他节点和被发送节点握手。

## 指派槽

最开始讲过，redis 使用的是分片的方式来保存数据库中的键值对，在一个集群中，整个数据库被分为 16384 个槽，数据库中每个键属于这 16384 个槽中的一个，在每个节点上可以处理多个槽。

当数据库的 16384 个槽全部被处理时，集群才会处于上线的状态。

在 clusterNode 中 slots 结构是一个二进制数组，这个数组的二进制位用来判断节点是否处理某个槽。numslots 用来记录处理槽数量。每个节点还需要将自己的 slots 数组通过消息发送给集群中的其他节点，来告知其他节点自己目前负责的槽，目的是让接收者在 clusterState 的 node 字段中更新状态。

在 clusterState 中还有一个有意思的结构 slots，这个记录的是某个槽是由那个节点负责。**为什么要设置这个结构，假设我们想知道目前某个槽是由哪个节点所操作的，就无需遍历所有节点了**。而每个节点中所保存的 node 字典又方便将所负责的槽结构传播出去。

指派槽的功能由 CLUSTER ADDSLOTS 实现。

## 命令的执行

当集群上线之后，客户端可以向执行发送数据命令。假设客户端向某个节点发送和数据库键有关的命令时，节点要分析要处理的键属于哪个槽。如果自己负责该槽则直接处理，如果不是自己负责的则返回一个 MOVED 错误，然后指引客户端转向正确的节点。

在 redis 中使用了 CRC16 语句来生成某个 key 的槽号，当计算的槽号在 clusterState 的 slots 中指向的是自己则说明该节点由自己负责，否则节点获取真正要处理的节点的 ip 和 port 向客户端返回 MOVED 错误。

MOVED 错误的格式如下：

```
MOVED <slot> <ip>:<port>
```

客户端根据该错误中的 ip 和 port 确定处理该命令的槽，随后向该节点发送要执行的命令(实际是换一个套接字来操作)。在集群中每个节点默认只能使用 0 号数据库，并且在 clusterState 结构中还会使用跳跃表来保存槽与键之间的关系。

## 重分片

有的时候需要将已经指派出去的槽改为指派给另一个节点，并且相关的键也会从源节点移动到目标节点。重新分片在 redis 中可以在线操作，使用 CLUSTER SETSLOT IMPORT 命令可以向目标节点导入某些槽的键值对；CLUSTER SETSLOT MIGRATING 可以向目标节点迁移槽；CLUSTER GETKEYSINSLOT 命令告知最多获得多少个槽的键名。

对于一个槽的迁移就是使用上面的命令，多个槽的话重复这些命令就可以了。只需要目标节点准备好导入槽的键值对，源节点准备好迁移槽相关的键值对。随后将槽指派给目标节点。

## ASK 错误

在重分片时会出现一个问题，就是可能会有部分键值对留在源节点里，有部分已经在目标节点里了。那么此时如果客户端向源节点请求的键值对正好是正在被迁移的怎么办？

此时如果源节点能够查找到相应的键值对，那么直接返回就可以了；如果查找不到的话，这个键值大概率是被迁移到目标节点里了，那么源节点会恢复一个 ASK 错误。

当我们使用 CLUSTER SETSLOT IMPORT 命令时，clusterState 中会记录当前节点正在导入的槽，其中 import_slots_from 结构表示了每一个槽从哪一个节点处导入。而当我们使用 CLUSTER SETSLOT MIGRATING 命令时会又有一个 migrating_slots_to 的结构记录某个槽正在被迁移至哪一个节点。

如果此时源服务器收到了请求并且并没有找到这个 key，那么节点会检查 migrating_slots_to 数组查看这个 key 是否在被迁移。如果是的话，则需要返回一个 ASK 错误来引导用户去目标节点上查找。(注意当客户端被引导向目标节点查询键的时候，需要先发送一个 ASKING 命令，如果不发送会直接被目标节点拒绝)

## 复制和故障转移

在一个集群中同样包含了主服务器和从服务器，从服务器所作的工作依旧是复制主服务器的状态。

在集群中可以使用 CLUSTER REPLICATE 命令将某个节点设置为指定节点的从节点(clusterNode 中也有 slaveof 指针)，当设置了一些标志位后，开始执行复制功能，这个过程有点相当于 SLAVEOF 命令。这个信息会广播到集群中其他节点中，其他节点同样你能够知道这个节点正在复制。这样其他节点也会主节点的 clusterNode 中记录从节点的名单。

集群中的每个节点都会定期向集群中的其他节点发送 PING 消息，那么在规定时间内如果没有回复，该节点需要标记为**疑似下线**。每个节点之间也会交换信息来得知这些节点的状态，假设某个节点感知到了其他节点疑似下线了，那么需要更新自己的 fail_reports 结构。假设半数以上负责处理槽的主节点都认为某个主节点疑似下线了，则这个节点就会被标记为**已下线**。

当一个从节点发现正在复制的主节点已经下线时，从节点就开始对这个主节点进行故障转移，简单的说就是从从节点中选择一个，然后使它成为主节点，随后新的主节点撤销下线节点的指派槽，并广播告诉集群里的其他节点。如果下线的节点再次上线就成为目前新主节点的从节点。

## 消息

集群中的每个节点通过发送和接收消息来通信，这里不展开讲每种消息的内容了，节点发送的消息主要有以下五种：

* MEET：请求接收者加入集群；
* PING：随机向列表中的五个节点发送，检测是否在线；
* PONG：回复 MEET 或者 PING 消息；
* FAIL：收到这个消息的节点立刻讲某个节点标记为下线；
* PUBLISH：节点执行该命令，并继续广播该命令。