# C/S

在接触 redis 服务器之前，先要了解到它实际是一个事件驱动程序，它一共处理两种类型的事件：文件事件和时间事件。

## 文件事件

文件事件是服务器对套接字操作的一个抽象，redis 开发了自己的网络事件处理器，这个文件事件处理器使用 **IO 多路复用程序**来同时监听多个套接字；而文件事件处理器在某个套接字准备好进行操作时调用某个事件处理器来处理对应事件。

所以对于处理文件事件的模块，可以将文件事件处理器分成四个部分：套接字、IO 多路复用程序、文件事件分派器、事件处理器。

一个服务器可以连接多个套接字，这样可能会有多个文件事件同时发生。但是 IO 多路复用程序总是把所有的事件发如一个队列中，然后有序地传送给文件事件分派器，最后根据套接字产生的事件的类型，调用相应的事件处理器。

对于 IO 多路复用程序来说，在 redis 中包装了常见的 select、epoll、evport 和 kqueue。程序在编译时会挑选系统中性能最高的 IO 多路复用函数库；套接字的事件一共两种类型：读和写(*优先读*)。根据这些事件的不同的类型，在 redis 中包含了多个事件处理器：

* 连接应答处理器；
* 命令请求处理器；
* 命令回复处理器；

## 时间事件

在 redis 中时间事件一共有两类：

* 定时事件：在指定时间之后执行一次；
* 周期事件：每隔指定事件执行一次；

在 redis 中所有的时间事件都会放在一个无序链表中，在真正执行时需要遍历整个链表，找到到达的时间事件然后调用事件处理器。注意的是这个链表并不按照时间排序，所以在执行时必须遍历整个链表。但是因为 redis 中存在的时间事件非常少，所以不会影响性能。

### 调度

因为同时存在文件事件和时间事件，服务器需要使用一定的方法调度这些事件。服务器的主函数分为三个部分：

```
init server:
event_loop:
clean_server:
```

事件循环就通过 aeProcessEvent 来处理事件，调度规则如下：

* 由 aeApiPoll 函数最大阻塞时间，这是由到达时间最接近当前时间的时间事件决定的；
* 文件事件随机出现，如果处理完一次文件事件后没有时间事件到达，则继续等待并处理文件事件，如果到达最大阻塞时间，则处理时间事件。
* 事件的处理是同步、有序和原子的，不会出现抢占的行为。这样时间事件往往会比设定的到达事件稍晚一点。

## 客户端

redis 的一个服务器可以和多个客户端建立网络连接，在 redisServer 结构中专门有一个 clients 列表保存所有客户端，而 redis 中真正封装客户端状态的是 redisClient 结构。

```
typedef struct redisClient {
	...
	int fd;
	robj *name;
	int flags;
	
	sds querybuf;
	
	robj **argv;
	int argc;
	
	struct redisCommand *cmd;
	
	char buf[REDIS_REPLY_CHUNK_BYTES];
	int bufpos;
	list *reply;
	
	int authenticated;
	
	time_t ctime;
	time_t lastinteraction;
	time_t obuf_soft_limit_reached_time;
	...
}
```

上面列举了客户端中的一些属性：

* fd 标识了客户端正在使用的套接字描述符，如果这个值为 -1 则说明是一个伪客户端，比如 AOF 伪客户端和 Lua 伪客户端；
* name 是用户可以对 client 设置一个名字，这个 name 同样也是由字符串对象组成的。
* flags 存放了客户端的状态信息，这是由一个个标志组合而成的。其中有一个标志 REDIS_FORCE_AOF 专门为那些不是写但是修改了客户端或者服务器状态的一些命令写入 AOF 文件。
* querybuf 是输入缓冲区，用于保存客户端发送的命令请求，保存的就是命令的 SDS 值。
* 下面是命令和参数，服务器获取了 querybuf 后，对命令内容进行解析，随后获取命令参数和个数保存下来。
* cmd：获得参数后，服务器根据 argv[0] 中的值从命令表中查找对应的命令，这个命令表中存放的是一个个方法处理键值对，其中键是方法名(比如 SET)，值为一个 redisCommand 结构，这个结构保存了具体命令的实现函数，以及有关这个函数状态的一些信息。服务器在后面就会将 redisClient 中的 cmd 指向这个 redisCommand 结构。
* 输出缓冲区：执行完命令之后所得的恢复会保存在输出缓冲区中，在 redis 中有两个缓冲区，一个是大小固定的缓冲区，还有一个是大小可变的缓冲区。buf 是长度固定的缓冲区，一般用来记录长度比较小的回复；reply 是一个链表，存放字符串对象。
* 身份认证：如果打开了身份认证，则只有当 authenticated 的值为 1 时才说明客户端通过了身份验证，如果没有通过身份验证则除了 AUTH 命令之外其他命令都会被服务器拒绝。
* 上面列举的属性中包括了记录创建客户端时间，客户端和服务器最后一次进行互动的时间，以及输出缓冲区第一次到达软性限制的时间。

为了避免客户端的回复过大，会占用过多的服务器资源，所以服务器时刻检查客户端输出缓冲区的大小。服务器使用了两种模式来限制客户端输出缓冲区的大小。其中硬性限制表明只要超过硬性限制大小就会关闭客户端；软性限制说明如果大小超过软性限制但是没有超过硬性限制，则客户端会记下第一次到达软性限制的起始时间，如果超过了一定时长，也会关闭服务器。

## 服务器

一个命令从请求到执行的过程究竟是怎样的，这需要服务器端的具体操作。当我们发送了一个请求之后，服务器接收并需要处理这个命令，然后对数据库进行设置，随后产生命令回复 OK，将这个命令回复给客户端。

当客户端需要发送一个命令之前，需要将命令转换为协议的格式。服务器从套接字中读取了相应的命令后，就保存到客户端的**输入缓冲区**中，接下去对其命令进行解析提取 argv 和 argc，接着调用命令执行器执行命令。如上面所说，这个过程是先读取 argv[0] 去命令表中查找相应的 redisCommand 结构：

```
struct redisCommand {
	char *name;
	redisCommandProc *proc;
	int  arity;
	char *sflags;
	int flags;
	long long calls;
	long long milliseconds;
}
```

其中 proc 就是相应命令的实现函数，客户端状态中的 cmd 会指向这个结构。现在其实已经收集了实现函数 proc、参数 argv、参数个数 argc，经过一定的合法性验证之后，就可以调用命令的实现函数了：

```
client->cmd->proc(client)
```

当执行完成后，函数将产生一个回复，这个回复被保存在了输出缓冲区中。在最后需要对慢查询日志，指令计数，AOF 和复制进行后续的处理。随后就可以将命令写会客户端，由客户端展示给用户。

### serverCon

这个函数是 redis 中为数不多的时间事件，这个函数每 100 ms 执行一次，函数负责管理服务器的资源，这个函数一共完成如下的操作：

* 更新服务器的时间缓存：更新系统当前的时间戳，不过这个时间戳是粗略的时间戳；
* 更新 LRU 时钟：用来计算键的空转时间的属性；
* 更新服务器每秒执行命令次数：这个是以抽样的方式计算的，估计了最近一秒服务器处理的命令数；
* 更新服务器内存的峰值记录；
* 处理 SIGTERM 信号：打开服务器状态的 shutdown_asap，随后决定是否关闭服务器。为什么要拦截这个信号是因为服务器在关闭之前需要进行 RDB 持久化。
* 管理数据库：包括删除过期键，字典收缩等；
* 执行延迟 BGREWRITEAOF：如果在 BGSAVE 执行期间，想要执行 BGREWRITEAOF 会被推迟。
* 检查持久化的运行状态：服务器状态中会记录持久化子进程的 ID，这两个用来检查持久化命令在不在进行。
* 将 AOF 缓冲区内容写入 AOF 文件
* 关闭不符合条件的客户端
* 增加执行 servercron 的计数；

### 初始化

最后看一下 redis 服务器初始化的过程，首先初始化服务器实例是交给 initServerConfig 函数完成的，在这个函数中会执行一些默认参数的设置：运行 ID，运行频率，配置文件路径，运行架构，默认端口号，默认持久化条件，LRU 时钟，命令表。

其后在启动服务器时用户可以通过给定配置参数或者指定配置文件来修改服务器的默认配置，服务器在初始化默认参数后载入用户自定义的配置参数与文件。

再完全确认参数的载入后，开始初始化服务器的数据结构，包括客户端链表、数据库、订阅链表、Lua 环境、慢查询日志，调用 initServer 函数，执行最终的初始化。

完成初始化后还需要做的就是载入 RDB 文件或者 AOF 文件还原之前的数据库状态，随后就能执行事件循环了。