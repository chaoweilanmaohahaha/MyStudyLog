# RDB 和 AOF 持久化

redis 从某种意义上讲是一个内存数据库，它将所有数据都存在内存中，方便从中提取，所以在实际应用中通常用作缓存这一级。但是如果服务器进程一旦退出，就意味着数据和状态可能消失不见。redis 提供了持久化的手段，能够将内存中的数据保存到磁盘中，避免丢失。

## RDB

RDB 持久化可以手动执行，也能定期执行，它所生成的 RDB 文件是一个**压缩二进制文件**。RDB 文件存在的意义就是用它来还原数据库。

redis 中有两个生成 RDB 文件的命令：SAVE 和 BGSAVE。从名字可以判断，一个是前台会阻塞当前进程的命令，一个是后台进程执行。RDB 文件的载入是在服务器启动时自动执行的，*但是一般服务器都优先使用 AOF 持久化，因为 AOF 的效率高*。(使用的时候要注意 SAVE、BGSAVE 和 BGREWRITEAOF 命令的关系)

对于 BGSAVE 而言，服务器是允许用户设置配置，来执行每隔一段时间自动执行一次命令的操作的。这个保存在 服务器的 saveparam 参数中：

```
struct saveparam {
	time_t seconds;
	int changes;
}
```

seconds 是间隔时间，changes 是修改次数。意思是如果在 seconds 内，被修改了 changes 次，则进行一次 BGSAVE。当然要想准确计算这些值，在服务器结构中保存了另外两个参数 dirty 和 lastsave 分别记录了服务器数据库被修改次数和上一次保存的时间戳。

### 文件结构

RDB 文件有自己的一套文件结构，其中一共有五个主要部分：

* 魔数：标识这是一个 RDB 文件，是一个 REDIS 字符串。
* db_version：文件版本号
* databases：数据库数据
* EOF
* check_sum：校验和

其中最主要的是 databases 这一部分，其中可以保存任意多个非空数据库。每一个非空数据库需要有如下结构：

* SELECTDB：遇到这个字节说明，接下去是对应的数据库号；
* db_number：数据库号码
* key_value_pairs：键值对数据；

键值对数据包含了一个或以上数量的键值对，如果键值对带有过期时间，就会将时间也保存在其中。根据存不存在过期时间会分成两种不同的结构：
不带过期时间：

* TYPE：类型
* key
* value

带过期时间：

* EXPIRETIME_MS：告知程序，接下去表示的是过期时间；
* ms：时间戳
* TYPE
* key
* value

每一种不同的类型都会有不同的格式，这里就不展开了。

## AOF

RDB 可以看作是将当前数据库的数据状态完全保存了下来，那么 AOF 持久化所做的事就是通过保存 Redis 执行的写命令来记录数据库的状态了。所有被写入的 AOF 文件的命令都是以 redis 的命令请求格式保存的。

AOF 持久化一共有三个步骤：

* 命令追加：redis 服务器有以恶搞 aof_buf 缓冲区，目的是在执行完一个命令后将命令追加到这个缓冲区中。
* 命令写入：在每一次 redis 的事件循环中，需要判断将 aof_buf 中的数据保存到 AOF 文件中。
* 命令同步：一共有三个选项可以控制持久化的不同行为；如果采用 always 选项，则缓冲区中的所有数据都会写入并同步到 AOF 文件中；如果采用 everysec 则每隔一秒进行同步；no 则不对 AOF 文件进行同步。

AOF 因为保存的是具体的命令，所以载入 AOF 文件和 RDB 也是不同的。载入 AOF 文件需要创建一个伪客户端，由它来读取并执行每一条命令。

但是随着不停地追加，AOF 文件的体积会越来越大，这里为了解决 AOF 文件体积膨胀问题，又提出了 **AOF 重写**策略，这是将一些操作合并，从而生成一个新的 AOF 文件替代原先的 AOF 文件。AOF 重写的实现原理是：首先从数据库中读取当前的值，随后用一条命令去记录这些键值对从而替代原先的多条命令。

但是 AOF 重写本身又是一个阻塞型操作，大量的输入会阻塞进程的执行，因此可以选择在后台进行重写，但是这样会带来数据不一致的问题。为此 redis 又设置了一个 AOF 重写缓冲区。这个缓冲区从后台进程启动开始，接收后续所有的命令，当后台进程重写完，再有前台进程将重写缓冲区内的数据写入文件中，这样就保证了 AOF 文件的一致性，以上就是 BGREWRITEAOF 的实现。

---

## 过期键的影响

生成 RDB 文件时，不会存储已过期的键；载入 RDB 时，主服务器会判断过期键并不会载入，从服务器则都会载入。

写入 AOF 文件时，如果键处于过期状态也不会有任何影响；反之会追加一条 DEL 命令。

