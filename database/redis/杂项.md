# 独立功能

## 发布与订阅

redis 有发布消息和订阅的功能，通过 SUBSCRIBE 命令，客户端可以订阅一个或者多个频道，如果有人向这个频道中发送了消息，那么所有订阅者都能够收到，大体上可以把它看作是消息传递的一种途径(因为每一个客户端连接一个服务器，所以由服务器保存着订阅信息，并且这个也方便传送一些独立的信息)。除了 SUBSCRIBE 命令，也可以通过 PSUBSCRIBE 命令订阅一个或多个模式，所谓模式也就是一个字符串，用来描述频道名字的一些特征。使用之前提到的 PUBLISH 就可以向某个客户端发送命令。

当我们使用 SUBSCRIBE 命令时，频道和客户端需要建立一种订阅关系。服务器状态中有一个 pubsub_channels 字段保存了所有频道的订阅关系。这个字典结构的 key 是频道名，值是订阅这个频道的客户端。当然如果一个客户端不想要订阅一个频道了，使用 UNSUBSCRIBE 就能够从 pubsub_channels 中删除订阅关系。

像模式的订阅则放在另一个 pubsub_patterns 的链表结构中，这个和 channels 的结构不同，每个 pattern 有一个自己的结构：

```
typedef struct pubsubPattern {
	redisClient *client;
	robj *pattern;
}
```

显然 pattern 是保存的模式字符串，当使用 PSUBSCRIBE 命令时就会更新这个链表。那如果退订的话，只需要从中删除对应的 pattern 的节点。

订阅的目的就是消息的发送和接收。使用 PUBLISH 命令可以向某个频道发送消息：

```
PUBLISH <channel> <message>
```

当遇到这个命令的时候，因为 pubsub_channels 里面记录了所有频道的订阅关系，所以只需要在 pubsub_channels 中找到对应频道的所有订阅者，然后将消息发送给这些客户端。但是除此之外还有订阅模式的客户端，服务器需要从 pubsub_patterns 中所有订阅关系中找到相匹配的那些订阅者，然后发送给这些客户端。

在 redis 2.8 版本之后增加了 PUBSUB 命令，客户端可以用这个命令来查看频道和模式的信息，PUBSUB 一共由三个子命令：PUBSUB CHANNELS(*查看服务器当前被订阅的频道*)，PUBSUB NUMSUB(*返回某个频道的订阅人数*)，PUBSUB NUMPAT(*返回当前被订阅模式的数量*)。

## 事务

redis 同样支持事务的功能，事务在这里提供了一种将多个命令请求打包，然后一次性、按顺序执行多个命令的机制，并且事务在执行过程中，服务器不会打断事务的执行。

redis 使用 MULTI 作为事务的开始，EXEC 表示事务的提交。

一个 redis 事务一共有三个阶段：事务开始、命令入队、事务执行；使用 MULTI 命令相当于**让客户端从非事务状态转换到了事务状态**。当进入此状态之后，每一次输入的命令服务器都不会立刻执行这个命令，它们会被放入服务器队列中，然后返回一个 QUEUED 回复。

在 redisClient 结构中包含了一个 multiState 类型的结构：

```
typedef struct multiState {
	multiCmd *commands;
	int count;
}

typedef struct multiCmd {
	robj **argv;
	int argc;
	struct redisCommand *cmd;
}
```

很显然这个 multiCmd 结构和当时客户端中的命令解析和 cmd 格式很像，队列就是用这种方式存放了每一个在事务中入队的命令。

当服务器此时收到了 EXEC 命令时，服务器会遍历客户端的事务队列，然后执行所有的命令，并将结果返回。

在事务中有一个 WATCH 命令可以监视数据库中的键。它是一个乐观锁，可以在 EXEC 执行之前进行监视。假设被监视的键有一个被修改，则服务器拒绝执行这个事务。在 redisDb 结构中存放了一个 watched_keys 的字典结构，key 是一个个数据库键，值是监视它的客户端。**注意在每个需要对数据库元素进行修改的操作中都会做一个检测键是否被修改的操作，如果被监视的某个键被修改了，则该键对应的客户端会打开安全性被破坏的标志。**

那么当执行 EXEC 是，服务器就需要判断是否有这样一个标志，如果有就拒绝事务的执行，否则正常执行事务。

最后谈一下在 redis 中的事务的 ACID 性质是如何保证的。redis 中的事务的机制保证了它一定有原子性，因为它的设计就是要么不执行，要么一次性都执行，没有人能够打断，**并且 redis 是不支持回滚的**，中间如果有某个命令有错，则也会继续执行。对于一致性而言，比如出现入队错误时是会拒绝执行事务的，但是假设出现了停机的问题，则会通过持久化的手段回复一致性。对于隔离性而言，redis 的事务是串行的。对于耐久性而言，这是由持久化模式决定的，只有在启动 AOF always 选项时才会有耐久性，其他都是没有的(除非在每一个事务的 EXEC 前加上 SAVE 命令)。

