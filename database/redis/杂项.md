# 独立功能

## 发布与订阅

redis 有发布消息和订阅的功能，通过 SUBSCRIBE 命令，客户端可以订阅一个或者多个频道，如果有人向这个频道中发送了消息，那么所有订阅者都能够收到，大体上可以把它看作是消息传递的一种途径(因为每一个客户端连接一个服务器，所以由服务器保存着订阅信息，并且这个也方便传送一些独立的信息)。除了 SUBSCRIBE 命令，也可以通过 PSUBSCRIBE 命令订阅一个或多个模式，所谓模式也就是一个字符串，用来描述频道名字的一些特征。使用之前提到的 PUBLISH 就可以向某个客户端发送命令。

当我们使用 SUBSCRIBE 命令时，频道和客户端需要建立一种订阅关系。服务器状态中有一个 pubsub_channels 字段保存了所有频道的订阅关系。这个字典结构的 key 是频道名，值是订阅这个频道的客户端。当然如果一个客户端不想要订阅一个频道了，使用 UNSUBSCRIBE 就能够从 pubsub_channels 中删除订阅关系。

像模式的订阅则放在另一个 pubsub_patterns 的链表结构中，这个和 channels 的结构不同，每个 pattern 有一个自己的结构：

```
typedef struct pubsubPattern {
	redisClient *client;
	robj *pattern;
}
```

显然 pattern 是保存的模式字符串，当使用 PSUBSCRIBE 命令时就会更新这个链表。那如果退订的话，只需要从中删除对应的 pattern 的节点。

订阅的目的就是消息的发送和接收。使用 PUBLISH 命令可以向某个频道发送消息：

```
PUBLISH <channel> <message>
```

当遇到这个命令的时候，因为 pubsub_channels 里面记录了所有频道的订阅关系，所以只需要在 pubsub_channels 中找到对应频道的所有订阅者，然后将消息发送给这些客户端。但是除此之外还有订阅模式的客户端，服务器需要从 pubsub_patterns 中所有订阅关系中找到相匹配的那些订阅者，然后发送给这些客户端。

在 redis 2.8 版本之后增加了 PUBSUB 命令，客户端可以用这个命令来查看频道和模式的信息，PUBSUB 一共由三个子命令：PUBSUB CHANNELS(*查看服务器当前被订阅的频道*)，PUBSUB NUMSUB(*返回某个频道的订阅人数*)，PUBSUB NUMPAT(*返回当前被订阅模式的数量*)。

## 事务

redis 同样支持事务的功能，事务在这里提供了一种将多个命令请求打包，然后一次性、按顺序执行多个命令的机制，并且事务在执行过程中，服务器不会打断事务的执行。

redis 使用 MULTI 作为事务的开始，EXEC 表示事务的提交。

一个 redis 事务一共有三个阶段：事务开始、命令入队、事务执行；使用 MULTI 命令相当于**让客户端从非事务状态转换到了事务状态**。当进入此状态之后，每一次输入的命令服务器都不会立刻执行这个命令，它们会被放入服务器队列中，然后返回一个 QUEUED 回复。

在 redisClient 结构中包含了一个 multiState 类型的结构：

```
typedef struct multiState {
	multiCmd *commands;
	int count;
}

typedef struct multiCmd {
	robj **argv;
	int argc;
	struct redisCommand *cmd;
}
```

很显然这个 multiCmd 结构和当时客户端中的命令解析和 cmd 格式很像，队列就是用这种方式存放了每一个在事务中入队的命令。

当服务器此时收到了 EXEC 命令时，服务器会遍历客户端的事务队列，然后执行所有的命令，并将结果返回。

在事务中有一个 WATCH 命令可以监视数据库中的键。它是一个乐观锁，可以在 EXEC 执行之前进行监视。假设被监视的键有一个被修改，则服务器拒绝执行这个事务。在 redisDb 结构中存放了一个 watched_keys 的字典结构，key 是一个个数据库键，值是监视它的客户端。**注意在每个需要对数据库元素进行修改的操作中都会做一个检测键是否被修改的操作，如果被监视的某个键被修改了，则该键对应的客户端会打开安全性被破坏的标志。**

那么当执行 EXEC 是，服务器就需要判断是否有这样一个标志，如果有就拒绝事务的执行，否则正常执行事务。

最后谈一下在 redis 中的事务的 ACID 性质是如何保证的。redis 中的事务的机制保证了它一定有原子性，因为它的设计就是要么不执行，要么一次性都执行，没有人能够打断，**并且 redis 是不支持回滚的**，中间如果有某个命令有错，则也会继续执行。对于一致性而言，比如出现入队错误时是会拒绝执行事务的，但是假设出现了停机的问题，则会通过持久化的手段回复一致性。对于隔离性而言，redis 的事务是串行的。对于耐久性而言，这是由持久化模式决定的，只有在启动 AOF always 选项时才会有耐久性，其他都是没有的(除非在每一个事务的 EXEC 前加上 SAVE 命令)。

## Lua 脚本

从 2.6 版本以后，redis 开始支持 Lua 脚本，服务器中直接嵌入 Lua 环境，使得 Lua 脚本可以直接在服务器中执行。通过 EVAL 命令可以直接执行输入的脚本，而通过 EVALSHA 命令可以根据脚本的 SHA1 校验和来对脚本进行求值。下面简单讲一下 redis 是如何创建 Lua 环境的。

redis 内嵌一个 Lua 执行环境，但是需要做出相应的修改。首先通过 lua_open 创建一个新的 Lua 脚本环境，然后载入了需要用到的公有库。此时服务器会在 Lua 环境中创建一个 redis 全局表格，这个表格中会存放用于执行 redis 命令的函数以及其他和 redis 处理相关的函数。

因为 redis 的一致性要求所有不同的机器应该产生相同的结果，所以这里需要修改 Lua 中的随机生成函数，并且创建排序辅助函数，让集合中的顺序是确定的。在执行 Lua 脚本时，服务器需要对全局的环境进行保护，保证服务器的脚本不会因为没有加 local 关键字而影响到全局变量，最后将最终的 Lua 环境保存到服务器中，注意每个时刻，**最多只能运行一个脚本**。

要执行 redis 命令必须有客户端，redis 专门为 Lua 环境创建了一个伪客户端，并由这个伪客户端负责处理 Lua 脚本中的所有 redis 命令，而伪客户端会将这个命令传给命令执行器，直到执行完后返回给 Lua 环境。另外为了保存 Lua 脚本的信息，在 server 结构中还有一个 lua_scripts 的字典结构，key 是校验和，value 是脚本。所有被执行或者加载的脚本都会保存到这个结构中。

### 执行

所以执行一个脚本就分为三个步骤。首先当发送 EVAL 命令时，服务器会对这个脚本定义一个 Lua 函数，函数名就是 f_ 前缀加了脚本的 SHA1 校验和。这就是为什么知道校验和后能够直接执行函数的原因。

接着将这个脚本保存到上述的 lua_scripts 结构中。

在真正执行这个脚本前，还需要将获取参数，给脚本注册超时钩子函数。当执行完后就会移除这个钩子函数，回收垃圾。

对于 EVALSHA 命令就不用多说了，执行的过程和上面比较类似。

和脚本有关的命令不止这两个还有如下四个也是相关的：

* SCRIPT FLUSH：清除服务器中所有和 Lua 服务器有关的信息；
* SCRIPT FLUSH：根据输入的 SHA1，检查对应脚本是否存在；
* SCRIPT LOAD：完成 EVAL 命令的前两步；
* SCRIPT KILL：如果脚本运行期间超过了限制，则客户端执行这个命令停止执行。

### 复制

和其他命令一致，具有写性质的命令会被复制到从服务器上，通过命令传播的方法给所有的从服务器。但是复制 EVALSHA 命令是比较复杂的，因为脚本可能会出现未找到的错误。所以传播这个命令之前需要确保从服务器已经载入过这个脚本了，此时需要使用 server 中的 repl_scriptcache_dict 字典结构，key 是脚本校验和，value 都是 NULL，如果校验和出现在这个字典中，说明该脚本已经全部被传播到所有从服务器上了。如果不在呢？每当一个主服务器添加了一个新的从服务器，都需要清空 repl_scriptcache_dict。随后服务器将 EVALSHA 转换成 EVAL 命令传播(相关的脚本就在 lua_scripts 中)，随后将命令添加到字典中。

---

## 排序

redis 的 SORT 命令用来对列表键、集合键或者有序集合键中的值进行排序。简单说一下 SORT 命令：

```
SORT <key> ALPHA DESC BY <pattern> LIMIT <offset> <count> GET <pattern> store <key>
```

对于 SORT 命令的内部实现， redis 构造了一个 redisSortObject 结构，专门存放每个对象和排序依赖的分值，随后根据该分值来进行排序。

```
typedef struct redisSortObject {
	robj *obj;
	union {
		double score;
		robj *cmpobj;
	} u;
}
```

其中各个命令参数如下：

* ALPHA：可以对包含字符串值的键排序；
* ASC or DESC：升序或者降序；
* BY：按照某个排序键作为排序的权重；
* LIMIT：限制返回元素个数；
* GET：根据指定模式返回某些键的值
* STORE：将排序结果保存在键中。

注意使用这些参数的顺序，只需要保证 GET 选项的顺序，其他选项的先后顺序是无所谓的。

## 二进制位数组

redis 中实现了一个位数组的数据结构，通常用来查看某个结构中是否存在某个元素。redis 使用字符串对象存储位数组，并且位数组的存储和我们书面的表示正好相反。对于位数组来说一共有四个操作：

* GETBIT：返回某个偏移量上的值；
* SETBIT：设置某个偏移量上的值，如果超出当前数组大小则会扩展 SDS 中的 buf；
* BITCOUNT：统计数组中 1 的个数，在 redis 中的设计中使用了查表法和 variable-precision SWAR 算法的结合。
* BITOP：实现 AND、OR、XOR、NOT 四个操作。

---

## 慢查询日志

慢查询日志这个功能记录了执行时间超过给定时长的命令请求，用户是可以通过这个功能产生的日志来监视和优化查询速度的。

服务器需要配置两个和慢查询日志相关的选项：

* slowlog-log-slower-than 指定执行时间的阈值；
* slowlog-max-len 指定最多保存多少条日志记录；

如果被记录的日志已经慢了，则最旧的日志会被删除，然后写入最新的日志。在 redis 的内在实现中，使用一个 slowlog 链表来保存了所有的慢查询日志，链表的节点是一个 slowlogEntry：

```
typedef struct slowlogEntry {
	long long id;
	time_t time;
	logn long duration;
	robj **argv;
	int argc;
}
```

## 监视器

通过执行 MONITOR 命令，客户端可以将自己变为一个监视器，并且实时接收并打印服务器当前正在处理的命令请求的信息。这样当一个客户端给一台服务器发送一个命令请求时，服务器会把这个命令请求发送给所有的监视器。执行 MONITOR 命令后会将客户端的标志记为监视器类型。