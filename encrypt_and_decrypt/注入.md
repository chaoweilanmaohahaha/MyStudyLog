# 注入技术

DLL 是 Windows 平台提供的一种共享和重用机制，它不能独立执，但可以被加载到其他的进程中执行。

当然因为每个进程的内存空间都是相互独立的，那么在 Windows 中不能跨进程执行自己的代码，使用 DLL 注入技术后就可以方便地进行 Hook 或者补丁的操作。

## DLL 注入方法

在通常的情况下，程序加载 DLL 的时机主要有以下三种，一种是在创建进程的阶段加载输入表中的 DLL；第二种就是调用 LoadLibrary 主动加载；第三种是由于系统机制，必须加载一些系统预设的基础服务模块。

### 干涉输入表

在之前提到的处理输入表 DLL 模块，当一个进程被创建后并不会直接到 EXE 本身的入口处，而是需要执行 ntdll.dll 中的初始化进程的一些操作，其中有一块就是加载输入表中的模块，然后填充应用程序的 IAT。

那么因此，只要在输入表处理之前干预，给输入表增加一个项目，让它指向要加载的目标 DLL。主要的方法和流程可以总结成以下几条：

#### 静态修改 PE 输入表法

在之前提到过 IID 结构存放了输入表的内容。那现在的目的是需要在这个 IID 结构中新增加一项。所以需要开辟一个新的空间存放新项目。一般而言都是在段于段之间的空隙中插入，但是很有可能本身不存在空隙，那么针对这个问题，需要对原来文件中保存的结构进行扩展。

在这个过程中，我们一定要及时记下文件偏移信息和内存偏移信息。

1. 备份原 IID 结构
2. 可以在原 IID 区域构造新的 IID
3. 在新的扩展区域(一般是文件尾部)填充新的输入表 IID 结构。
4. 修改 PE 文件头的信息，特别是指向输入表位置以及指明输入表大小的信息。

当然以上这些步骤可以使用一般专用的 PE 编辑工具来完成这些工作，但是有的情况下，EXE 本身可能带有校验机制，所以我们插入的也要经过校验，如果存在这些校验就不能直接修改原文件了。

#### 进程创建期修改 PE 输入表

这个和静态修改 PE 输入表完全相同，但是这种方法可以在 R3/R0 的阶段进行干预，这个方法因为在内存中，因此在段与段之间的空隙也会相对的大一些。

1. 首先以挂起方式创建目标进程
2. 通过一些手段获取目标进程中的 PE 结构的信息，然后想办法拿到 EXE 的实际加载基址。
3. 通过 EXE 加载的机制，找到原 IID 的大小和位置，然后在合适的空间中增加一项。
4. 在新开辟的 IID 空间中写入新的 OriginalFirstThunk、Name 和 FirstThunk 结构。
5. 修改对应的 PE 头部，然后更新目标进程的内存。
6. 恢复，继续运行主线程。

#### DLL 劫持

初始化输入表的时候会选择递归方式加载指定的 DLL。但是一般 ntdll 在进程尚未创建完成时就已经加载了，而其他的 dll 则不一定。

那么在 Windows 内部存在着一种寻找 DLL 的默认顺序，一般而言系统注册表中存在一项 KnownDLLs，这里存放了一些系统默认的 dll。如果没有系统就会按照如下顺序查找 DLL：

1. 正在加载 DLL 的进程的可执行文件目录
2. 系统目录
3. 正在加载 DLL 进程的当前目录
4. PATH 环境变量中列出的目录

所以进行 DLL 劫持的意思就是，如果要劫持的 TargetDLL 在系统目录下，就只需要把劫持的 hackDLL 放到 EXE 目录下；如果已经在 EXE 目录下了，那只需要进行一次改名的操作。**但务必清楚，劫持的 hackdll 要导出原 DLL 的所有输出函数。**

## 改变程序流程

在这一小节中，主要思考的时通过改变程序的流程。那么可以使用的手段主要时修改线程的 EIP， 创建新的线程，修改目标进程中的代码等等。

### CreateRemoteThread

这是最经典的也是使用范围最广的方法，最基本的思路就是在目标进程中申请一块内存并向其中写入 DLL 路径，然后调用 CreateRemoteThread 在目标进程中创建一个线程。在这个线程中，线程函数就是 LoadLibraryA，参数时 DLL 路径的内存指针。

### RtlCreateUserThread

这个方法和 CreateRemoteThread 类似，只不过最终需要自己手动结束自己创建的线程。

### QueueUserApc 注入

APC 是异步过程调用的缩写，这是一种软中断的机制。具体是当一个进程从等待状态苏醒时需要检测有没有 APC 交给自己，如果有就会在唤醒时调用该线程。

那么这个方法正是使用了这个机制，向每个进程的 APC 队列中插入 APC。

### SetThreadContext

在这个方法中，可以将正在执行的线程暂停(SuspendThread)，随后系统会将此时的线程上下文保存下来，这里包括了继续执行时的 EIP。那么我们需要将该线程的 EIP 指向自己编写的代码的地址，随后再在自己的代码的最后修正 EIP，执行原本的代码。

### notify 

通过内核层对操作进行干预

### KeUserModeCallback

在 Windows 方法中在加载全局钩子 DLL 时，是调用 KeUserModeCallback 回调 user32.dll 中的函数并最终调用 LoadLibraryExW 实现的，使用同样的方法，也可以为运行中的进程注入自己的 DLL。

### WriteProcessMemory

这种方法和 SetThreadContext很像，但是这里的方法是在程序执行的地方设置**陷阱**代码，如果调入陷阱，则转而加载 DLL，最后从陷阱中恢复。

插入陷阱的时机非常有趣：

* ntdll!KiUserApcDispatcher
* ntdll!ZwTestAlert
* 进程入口点
* 运行时常用的 API

## 运用系统机制

对于操作系统本身来说一些系统机制就是依赖于一些服务模块，而只有进程触发了这些机制，才会去加载对应的模块，如果我们把一些 DLL，注册为系统服务模块，自然就能进入目标进程了。下面介绍几个可能使用到的方法：

### SetWindowHookEx

这个是一个消息钩子，也就是提供消息过滤和预处理。使用 SetWindowHookEx 安装一个过滤特定消息的钩子函数，这个函数第一个参数指定了类型。

这个方法的关键在于上面函数的制定安装线程的参数。如果该参数为 0，则安装了一个全局消息钩子。那么当系统检测目标 DLL 未加载，他会使用 KeUserModeCallback 方法进行回调，那么此时就可以将 DLL 注入到其他进程中。

**这种方法原本使用范围最广，精髓在于安装一个全局的钩子函数，比如木马监听键盘**

### AppInit_DLL 注册表注入

加载 user32.dll 时会调用 LoadAppDLLs 函数，此时会读取对应的注册表下的内容，如果再该注册表下等级 DLL，就可以主动加载它。

### 输入法注入

这种方法很有意思，是借助了输入法软件。输入法软件本身也有外挂式和接口式两种。

外挂式通常也是一个 EXE，只要它启动了，那么所有进程中都可以使用输入法，但是如果使用这种去实现注入，实现起来并不容易。

接口式实际上是一个符合输入法接口的 DLL，如果目标进程切换到了这个输入法，那么系统会加载这个 IME 模块，那么此时就需要编写一个相应的 IME 模块来安装。

### SPI 网络过滤器 (先跳过)

### ShimEngine 注入

这是 Windows 系统中的兼容性引擎。对于一个 EXE 文件，总有它运行的兼容性的问题。那么再Windows 中为了让文件运行在完美的系统版本下，Windows 尝试模拟。

> 主要的矛盾点其实就是调用 API 的版本问题。

那么为了对此行为进行修复，Windows 专门使用兼容性引擎来做中间转换工作，其中默认使用的就是 ShimEng.dll。那么我们可以通过编写自己的引擎，来替代它。

### Explorer Shell扩展

使用 Windows 上的 Explorer 注入是一种比较常见的注入。该扩展只有弹出右键才能触发，那么其中的一个方法就是控制 ShellIconOverlayIdentifiers 来进行注入，只要对话框显示出来，注册的模块就能被加载。

## DLL 注入有什么用？

1. 实现精确的、复杂的内存补丁
2. 实现增强的 PEDIY
3. 和 Hook 技术结合

## 防范注入

最后谈谈一些防范措施，如果是静态注入，只要对文件进行校验就可以避免，但是如果是动态的就相对复杂。

### 驱动层

* 针对 KeUserModeCallback 方法，安装 IAT Hook，对加载模块进行判断。
* 对 ntdll!NtMapViewOfSection 模块进行验证
* 拦截进程读写，创建远线程、发送 APC 的操作。
* 对用户调用栈检测，看是否有非法模块

### 应用层

* Hook 一些加载 DLL 的函数来防范全局钩子、输入法注入等问题。
* 在 DLLMain 中进行防御
* 枚举并查找当前进程中的非法模块和可以内存
* Hook ntdll 中的底层函数进行栈调用的检测

