# 补丁技术

在原有的程序中，添加或者减少一些功能代码，都可以称为给原文件打补丁。而这种补丁要么出现在文件打补丁，要么就是在内存中打补丁。

## 文件补丁

文件补丁就是修改原文件来达到修改功能模块的需求。文件补丁非常简单，一般只需要基本的十六进制数操作就可以完成了。

打补丁前先比较程序修改前和修改后的不同，然后使用 CreateFileA 和 WriteFile 将修改数据写入文件。

## 内存补丁

文件补丁适用于非常简单的程序，但是如果原来的程序被加过壳，或者有压缩和校验都无法直接进行文件补丁。

内存补丁就是等到程序已经进入了内存，然后再某个时刻修改进程地址空间的数据。

### 跨进程内存存取

两个进程理论上应该是完全隔离的，但是在一定条件下，两个进程也可以实现互访机制。而 Windows 中实现的进程间互访就是 ReadProcessMemory 和 WriteProcessMemory。所以通过对目标进程的一定控制，可以使用 WriteProcessMemory 函数将补丁代码写入合适位置。而 ReadProcessMemory 是用来对目标进程特定的位置进行校验。

### 调试 API

通过调试 API 帮助进程实现消息通知的机制。而这样有两种方法：

* 将目标进程设置为单步调试，这样没执行一条指令，都会和调试进程有通信。
* 将目标地址修改为 INT 3，这样会在目标地址处发送调试信息。

要使进程处于单步调试下，基本办法就是修改标志寄存器中的 SF 位。这样没执行一条指令都会发送一次 EXCEPTION_DEBUG_EVENT 信息。

### 利用调试寄存器

为了进行更隐蔽地补丁功能，绕过一些高级的校验，可以使用 intel CPU 内建的 DRx 调试寄存器来打补丁，这是最为隐蔽和通用的。

详细的使用过程要看一下这些寄存器的功能，在其中设置好地址后，CPU 会向调试器发送异常信息。

### 利用 DLL 注入

### 利用 Hook 技术

### 利用 VT 技术

## SMC

### 单层补丁技术

思路是，当外壳代码完成将程序在内存中解压这一步骤后，让它先跳到补丁代码处执行补丁，再回到原指令处继续正常工作。

我们检查外壳代码，并检测何时代码的数据已经还原，哪里就可以作为 SMC 的起点。在目标程序中找到一个空间存放补丁代码。这个空间一定不会被覆盖。

### 多层补丁技术

这种方法是应对多层嵌套加密压缩，也就是第一层加密第二层，第二层加密第三层。

---

下面就是一些现成的补丁工具的推荐：

* CodeFusion（文件补丁）
* dUP（各种补丁）