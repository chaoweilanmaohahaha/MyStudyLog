# PE

在所有的 Win32 平台上，可执行文件的格式是 PE，全称可移植执行体，它算是目前的 Windows 平台上最流行的执行文件格式。

为什么说它是可移植的，这种移植性是针对所有 Windows 平台和各种类型 CPU。

在 Windows 系统中，EXE 文件和 DLL 文件的区别在于语义上，而格式都是相同的 PE 格式，唯一的区别就是需要一个字段标识出这个文件是 EXE 还是 DLL。在未来可能还会碰到很多有关 DLL 的扩展，但是它们其实都是 DLL 文件。

在 PE 文件中数据结构都会有 32 位和 64 位之分，但是它们的结构几乎是一样的。

以书上的一张图来概括 PE 文件结构：
![PE](..\img\PE.png)

## 基本概念

可以看到，PE 文件代码和数据都合并在一起，在文件内容部分分成多个 Section，每个块按页边界对齐，每个块也有自己的一套属性。

Windows 加载器遍历 PE 文件并决定文件的哪一个部分被映射，如果磁盘上的文件被载入内存，那么磁盘上的数据结构布局和内存中的是一致的。

### 基地址

PE 文件载入内存后，内存的版本叫做模块。而映射文件的起始地址叫做模块句柄，也可以叫做**基地址**。装载对应的模块就是把 PE 各个部分映射到连续的内存块中，所以对于编程人员只需要知道基地址。

注意基地址的值是由 PE 文件本身设定的，可以在创建应用程序的过程中修改这个值。

### 虚拟地址

注意，当 PE 文件被映射到内存中后，每个程序都会有自己的虚拟空间，那么在这里使用的内存地址是虚拟地址 VA。

### 相对地址

在可执行文件中，很多地方都需要用到内存中的地址，但是这个地址不能依赖于当前载入点地址，因为这个地址总是会变化。

显然文件中的地址需要使用**相对虚拟地址**。这个地址其实就是相对于载入点的一个偏移地址。它需要将**目标地址**减去**载入的地址**。所以我们能得到下面的等式：

> 虚拟地址 = 基地址 + 相对虚拟地址

### 文件偏移地址

这个数据是针对磁盘中的保存情况，是代表每个数据相对于文件头的偏移量。

## MS-DOS 头部

PE 文件都是以一个 DOS 程序开始的，只有有它，程序在 DOS 下执行才能被识别是一个有效的执行体。

当我们在 linux 中运行 EXE 可能会看到一串错误提示，这个藏在 DOS 块中。

在这个头部中最重要的，就是 e_magic，它的去只要设置为 5A4Dh；还有一个字段是 e_lfanew 存储了真正的 PE 文件头的相对偏移。

## PE 文件头

这里面存放了 PE 装载器需要用到的重要字段。

### Signature

意思应该就是签名，这一部分默认值为 ‘PE00’

### IMAGE_FILE_HEADER

这个结构包含了 PE 文件的一些基本信息，包括了 CPU 类型，时间戳等等。

### IMAGE_OPTIONAL_HEADER

这个结构是一个可选的字段，它是为了扩充 PE 文件头的属性。

## 区块

从 PE 文件的图片看出，在文件头到区块过程中，还会经历一个区块表。

### 区块表

区块表的每一个元素都是一个 IMAGE_SECTION_HEADER 结构，该结构包含了对应区块的位置、长度、属性等。

---

PE文件至少有两个区块，一个是代码块，一个数据块，而且区块在映像中是根据其实地址排列的。可能出现的区块名包括：

* .text：代码块
* .data：数据块
* .rdata：只读数据块
* .idata：输入表
* .edata：输出表

> 链接器的作用是合并所有 OBJ 和库中需要的块，然后成为一个合适的区块。

区块的大小是要对齐的，在 PE 文件头里定义了磁盘区块的对齐值，不足的地方一般以 00h 填充，这就是**间隙**。而 PE 文件头中也定义了内存中的对齐值，内存中至少要从一个页边界开始。

那么当两种对齐值是不一样的，那么同一个数据在磁盘和在内存中的相对位置就是不一样的，因此这里要进行转换。

## 输入表

在当前的这个可执行文件中，如果它使用到了外部的 DLL 的代码货哦这数据时，这个称为**输入**。那么如果该程序需要执行，加载器的工作之一需要定位那些函数和数据，并且让这个程序能够使用到这些地址。

在调用函数中，这些外部函数只保留了其对应的函数名、DLL 文件名，这些外部调用只有在该执行文件载入内存后才能将这些符号链接起来。

输入表保存了这样一组函数指针，这样在代码中调用函数多少次，都只需要调用这个函数指针。

### 结构

输入表是一个 IID 数组，每一个被隐式链接的 DLL 都有一个 IID，这个数组的最后一个元素肯定是 NULL。

在该结构中有一个字段，指向 INT(输入名称表) 。INT 表中的元素对应每一个执行文件的输入的函数，INT 表中的元素指向 IMAGE_INPORT_BY_NAME 其中的一个元素。

在 IID 数组结构中，其实还有一个字段指向了一个称为 IAT(输入地址表) 的结构，起初这个结构应该和 INT 是一样的。但是随着加载入内存后，这个表格中的值会被替换为函数**真正的地址**，以后就只需要使用 IAT 中的数据就可以了。

---

但是以上的过程有一些麻烦，因为相当于每一次都需要先将相关的 DLL 映射到进程空间，然后遍历 IAT 去找输入函数的真实地址。那么在 Windows 中出现了一种新的技术，叫做**绑定输入**。其实本质就是想办法固定基地址。

在数据目录表中，存在专门存储绑定输入的成员。

## 输出表

这个和输入表相对，它是在创建 DLL 时，创建了一组能让其他 EXE 或者 DLL 调用的函数，这些信息要保存到输出表中，一般 EXE 中不存在输出表。

在可执行文件中，输出表指向 IED 结构，其中包含了输出函数的各种信息。这个输出表的设计是为了方便 PE 装载器的工作。

首先相关的输出函数地址都保存在了 IED 的 AddressOfFunctions 中，而其中的 NumberOfFunctions 中的值就是函数的数量。当然其中也有一个数组是保存了函数的名字。这样需要另外一个数组保存由名字到地址的一个索引。

## 基址重定位

先前说过，在 PE 文件中会指明加载到的默认的基地址，但是如果说 PE 在执行时被加载到了另一个地址处，则此时需要使用重定向来调整。

因为 EXE 文件是使用自己的虚拟地址空间，所以 EXE 不需要重定位信息，但是 DLL 是依靠宿主的文件地址空间，所以 DLL 必须有重定位信息。

**重定位表中，存放了所以可能修改的地址**。

重定位表中主要存放了需要重定位数据的一个开始地址，和一个偏移数组。

## 资源

在 Windows 程序中各种界面称为资源，包括什么光标，图标，菜单等等。

资源用类似目录结构保存，第一层是根目录，第二层是每一个类型的资源，第三层目录就是对应资源。

最上层在可执行文件中属于**资源目录**，随后根据每一个不同的资源指向对应的**资源目录入口**，由每一个入口指向资源数据。

**注意资源数据一般不能由源代码定义的变量直接访问，Windows 提供了加载他们到内存的函数。**

---

除了以上的这些，一个 PE 文件中还可能有：

* TLS 表：将数据和执行的特定线程联系起来
* 调试目录：存放调试信息
* 延迟载入数据
* 异常数据
* .NET 头部

