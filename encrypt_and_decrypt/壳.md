# 壳

壳的概念对应的是软件加密技术，所以一些软件可以采取加壳的方法来进行保护。

什么是壳？这是一种专门负责保护软件不被非法修改的程序，它会附加在原始程序上。当 Windows 加载器将程序载入内存后，这会先于原始程序执行，只有对原始的程序进行解密后才会把控制权交还给原始程序。

壳有什么作用？它防止破解者对程序文件进行非法修改，也可以防止程序进行静态反编译。

现如今的发展，出现了许多压缩壳，加密壳等等。并且逐渐将加壳技术运用到了虚拟机技术中。但是因为壳能够保护代码，所以许多病毒也喜欢使用壳来保护自己并且做到隐藏。所以一些杀毒软件对程序进行脱壳做检查，而有时直接查杀私人壳。

## 压缩壳

这种壳侧重于对源程序的压缩，它并不是用来保护代码的，而只是减小软件的体积。比如一些常用的值得推荐一下：

* UPX：一款以命令行方式操作的可执行文件的压缩程序
* ASPack：Win32 压缩软件，可以压缩可执行文件 EXE、DLL等。

## 加密壳

不同的加密壳，对程序的保护程度也不同，要么一些壳只负责保护程序，另一些壳则会提供一些额外的功能。

* ASProtect：Win32 上的保护工具，它拥有压缩、加密、反跟踪等保护手段。
* Armadillo：运用多种手段保护软件，比如给软件加上时间、次数限制。
* EXECryptor
* Themida

## 虚拟机保护软件

这里的虚拟机，指的是将一系列指令解释成字节码，然后放到一个解释引擎中执行，从而使得软件得到保护，这个区别于之前提到的虚拟机。

一个虚拟机引擎，必须有编译器、解释器和虚拟的 CPU 环境。在它运行的时候，需要将比如 x86 的指令解释为字节码，然后放在 PE 文件中，随后将原始代码删除。

这样做的目的是让跟踪者进入虚拟机后非常难理解原指令，这样提高了分析的成本，因此虚拟机技术称为了目前最流行的保护趋势。

### VMProtect

利用伪指令虚拟机的保护软件，它将指定的代码进行变形和虚拟化，这样能很好隐藏代码算法，防止算法被逆向。但是这样做代码执行效率会降低，所以对有效率要求的代码不适合用这个方法。

---

# 脱壳

下面开始将介绍如何脱壳，有加壳必然就有脱壳，脱壳成为了软件分析里面不可缺少的步骤。在此之前，先就要知道加壳软件试怎么加载的。

## 壳加载

壳和病毒是很类似的，也就说它比源程序代码更早获得控制权，壳程序修改了源程序执行的组织结构，它并不会影响源程序的运行。

1. 保存入口函数：保存各个寄存器中的值，直到外壳执行完，恢复现场。
2. 获取壳需要的 API
3. 解密源程序的各个区块数据
4. IAT 初始化：此时输入表由外壳程序填写，头目录中的指针指向自建输入表
5. 重定位：加壳程序需要修改 DLL 的重定位表。
6. Hook API
7. 跳转入口点

针对特定的壳所开发的脱壳软件是脱壳机，也就是将程序恢复到原来的状态。但是如果没有专门的脱壳机，因此考虑手动脱壳。

手动脱壳分为三步：

* 寻找真正的程序入口点
* 抓取内存映像文件
* 重建 PE 文件

### 寻找 OEP

因为加壳程序的控制权首先是壳程序，只有运行完相应的壳程序后才会继续跳转到真正的程序入口，这里把这个入口称为 OEP。

#### 跨段指令

绝大多数的壳程序都会在原本程序上加上一个或者多个区块，那么很有可能最后通过一个跨段的跳转指令才能找到对应的入口。

比如 RebPE 这个工具会让原本的程序多一个 .pediy 区块。**外壳会先用一次跨段指令从该区块跳转到外壳部分。**当程序完成了一系列初始化后，就会从外壳段跳转到代码段执行。比如：

```
push addr
retn
```

#### 内存访问断点

因为 OllyDbg 软件本身可以对代码段设断，所以可以免去上面提到的手动跟踪，需要在内存中设置断点。当设置断点后，一定会中断在外壳对代码进行读取的那句指令上。当外壳对代码解压完毕后，对代码段再设置断点，此时就会在跳入程序入口时触发中断。

#### 根据栈平衡

在编写加壳程序时，必须遵守栈平衡。所以通常使用 pushad/popad 等指令来保存现场。

那么在脱壳的过程中，只要根据栈平衡原理，对 esp 设断，就能够很快找到 OEP 了。

但是其实发现，大多数的程序第一句的指令都是 push，那就只需要对相应的地址设置硬件写断点就可以了。

#### 根据编程语言特点

各类语言经过编译后的文件入口点都有自己的特点，如果使用同一种编译器编译的程序入口代码都很类似。所以可以对这些类似的入口函数下断，或者对启动函数下断。**但是开发人员可以对启动源代码进行修改。**

### 抓取内存映像

什么是抓取内存映像，也就是把内存中某个地址的映像文件读出来，再以文件的形式保存。

在脱壳的时候抓取映像的时机是很讲究的，如果等到程序已经运行起来，一些变量已经发生了变化，此时就不适合 Dump 了。所以在外壳处理过程中，将压缩的代码数据释放到内存中，此时是一个好的抓取时机。

使用 LordPE 等等工具都能进行 Dump，它们使用 Module32Next 获取需要 Dump 的基本信息。在每次执行抓取的时候，都需要填一个 MODULEENTRY32 结构，这里面填充了进程映像的基址和大小，这样就可以通过 ReadProcessMemory 来读取进程内数据。

#### 反 Dump

Dump 是脱壳的关键，所以很多外壳会使用反 Dump 技术。为了绕过这些反 Dump 技术，需要对抓取过程进行一些小修改。

* 因为 Dump 的过程依赖于基址和大小，那么我们如果填入一些错误的值，就能让 Dump 软件无法正确读取进程中的数据。当然绕过的方法就是想办法找到类似这种代码，然后跳过。
* 当 PE 被加载，那么它的所有的段都是可读的。那么有的保护可能让类似 PE 文件头变得不可读。这种情况下就需要使用 OllyDbg 工具使得程序不可读的段设置为可读了。

## 重建输入表

外壳一个重要的步骤就是破坏源程序的输入表，而脱壳时，我们就得重建输入表。

输入表重要的而就是 IAT，那么而重建输入表就是根据外壳程序填充的 IAT 信息还原原本的输入表。

首先需要确定 IAT 的地址和大小，一般 IAT 是连续排列的，所以只需要确定 IAT 的一个点。我们最好的做法是查看程序中调用多少次输入函数。只要找到其中一个函数，向上找找到 00，就是 IAT 其实地址。而 IAT 的结尾也是 0 ，所以很好找到完整的 IAT。最后需要向映像文件中填入对应的数据，并且修改 IAT 指针的值。

那么输入表重建其实也有相应的工具，比如 Import REC。要使用它必须满足目标文件已经被 Dump，并且目标文件正在被运行，已经找到了入口的地址。那么具体的使用方法这里略去。

### 输入表加密

我们分析加壳程序会如何处理输入表，因为还原输入表是脱壳的一个非常关键的操作。

* 未加密，并且有完整的原输入表
* 完成输入表，但是进行了加密：需要在加密之前赶紧获取原地址
* 未加密，但是破坏了原输入表
* 加密且破坏输入表

## DLL 脱壳

上面介绍的基本上是 EXE 脱壳的过程，那么 DLL有的时候也要脱壳啊，DLL 脱壳的过程其实和 EXE 脱壳差不多，就多一个基址的重定位。

### 寻找 OEP

DLL 的运行有它自身的特殊性，在将 DLL 映射到进程地址空间时，会调用 DLLMain 函数，卸载时又会调用一次该函数。那么外壳代码也应该考虑到这一个问题。

寻找入口点的思路就有两种了，要么在载入的时候去寻找，要么在卸载的时候寻找。

### DUMP

当程序运行到入口处，使用 LoadPE 对映像文件进行抓取。

因为 DLL 服从操作系统给它动态分配基地址，所以加载到的位置并不一定时 DLL 中指定的。如果要在重定位后去抓取基地址，则需要在抓取时修正基址为当前环境的地址。

当然也可以在外壳中找到重定位的代码并且跳过它，使得 DLL 不被重定位。

### 重建输入表

使用 Import REC 就能实现。

### 重构重定位表

外壳很可能会破坏原始的重定位表，将重定位表换个形式存储。那么脱壳时，需要根据 PE 文档的定义重新构造一份合适的重定位表。

构造的方法就是将这些重定位过的 RVA 提取出来，根据重定位表的定义用这些 RVA 重新生成一份重定位表。

## 附加数据

如果观察地细致，我们会发现有的 PE 文件在区块正式数据后还会存在一些附加的数据，**这些数据不会被映射到内存。**

附加数据的起点是在最后一个区块的末尾，终点是文件的末尾。注意脱壳后要将附加数据贴回源程序，因为附加数据本身不会映射到内存，并且需要修正引用附加数据的指针。

## 优化 PE 文件

这一部分暂时先略过，因为脱壳后的程序其实并没有把外壳代码去除，所以脱壳后代码占用空间要比原先大。需要手动对 PE 文件优化：

* 优化输入表
* 重建资源
* 文件的装配
* 修改 PE 头

## 壳加密技术

加密壳技术是以加密保护为主要目的，它可能有各种的反跟踪技术，重点是要做到 OEP 隐藏和 IAT 加密，甚至是虚拟机加密技术。例如 ASProtect 是一个经典的加密壳软件，下面简单介绍一下这个软件使用的一些加密技术。

* ASProtect 可以将 API 入口处的一段代码抽出来并放到外壳里执行，从中调用系统 API。
* 外壳将程序的部分代码变形并搬到外壳段中。

---

## 静态脱壳技术

脱壳机技术一共有两类：动态和静态。静态脱壳技术需要完全分析出壳的引导过程及解压算法，把要脱壳的程序作为数据文件输入，然后自己实验壳的数据的解压、修正过程，**这种技术适合于进行病毒、木马的脱壳分析**。像上文中介绍的那些方法都是一些动态脱壳的方法。

实际的例子需要自行编写了，静态脱壳器的编写关键就是要找到正确的数据：

1. 数据位置的确定
2. 算法的还原
3. 输入表重定位表和资源的修复