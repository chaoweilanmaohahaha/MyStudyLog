# 加密算法

在软件保护中提到了使用序列号来保护软件的，那么序列号加密算法大都是软件开发者自己设计的。其实已经有很多现成的加密算法了，网上本来就有大量的源码和编译好的库。

## 单向散列算法

> 其实加密算法是一个老生常谈的问题，在一些安全类的书里面肯定都提到过，但是其实都不知道在具体使用中是怎么操作的，那么这里再简单回顾和补充一下了。

单向散列函数，是讲一个任意长度的信息都压缩成一个固定长度的函数，所以它可以又称为消息摘要函数。

在软件保护中，摘要函数是被经常用到的算法，因为 Hash 函数不可逆的运算，所以它只能作为软件保护的一个中间步骤，而作为攻击者，就需要识别到底使用了哪一种摘要函数。

### MD5

它的特征是会产生一个 128 位的消息摘要。

算法的流程是：

* 数据填充
* 数据添加长度
* 使用初始化变量
* 数据运算与处理
* 输出

不在这里详细展开了，因为暂时还不牵涉到内部实现的问题。

那么 MD5 一般会怎么用，如果使用的是 MD5 来进行保护的，那么一般都需要做一次序列号比较，这样很可能序列号的明文就出现在内存中。MD5 特征十分明显，比如说在代码中会出现 MD5 算法中需要用到的四个常数。

使用 PEiD中的插件 Krypto ANALyzer 可以帮助识别摘要算法。

### SHA 算法

安全散列算法是一个算法族，其中包括了许多如 SHA-1、SHA-256、SHA-384 和 SHA-512。其中分别产生的是 160 位、256 位、384 位和 512 位的散列值。

比如说 SHA-1 算法它的消息分组和填充方法和 MD5 算法是相同的。它也依靠固定的变换函数和固定的初始化数据来运算得到结果。所以要想在代码中识别出 SHA 系列的加密算法，跟踪一些初始化数据或者函数操作可以有所帮助。

同样使用 PEiD中的插件 Krypto ANALyzer 可以帮助识别 SHA 算法。

### SM3 杂凑算法

这个算法是由国家密码局发布的，这个密码能够生成 256 比特的杂凑值。

其实 Hash 算法还有很多比如 RIPEMD、HAVAL、Tiger 等等，但是目前已经验证了有很多的摘要算法已经是不安全的了。如果解密的过程中碰到 Hash 算法，则只需要识别是哪一种 Hash 算法，则通过这个算法的源代码就可以写成注册机。

## 对称加密算法

对称加密算法要求加密密钥和解密密钥实现同的，这就要求加密算法足够强，并且保证密钥的保密性。

在检验注册码的过程中，软件人员可能使用注册码作为密钥，这样攻击者只能使用穷举的方法来破解注册码了。

### RC4 流密码

RC4 生成的是一种称为密钥流的伪随机流，然后和明文进行异或操作，达到加密的目的。

密钥流需要通过两部分算法组成：

* KSA 算法
* PRGA 算法

### TEA 算法

TEA 需要进行密码分组，分组长度 64 位，密钥长度为 128 位，采用的是 Feistel 网络。TEA 算法和 RC4 算法都十分易懂，但是它有比较大的缺陷，就是**相关密钥攻击**。

### IDEA 算法

国际数据加密算法，分组密码的明文和密文的长度是 64 位，密钥长度是 128 位，这个算法的特点是使用了三种不同代数群上的操作。

### BlowFish 算法

是一个 64 位分组及可变密钥长度的分组密码。它基于 Feistel 网络，迭代 16 轮。算法需要将密钥扩展，然后再进行数据加密。

### AES 算法

AES 算法将分组长度固定为 128 位，仅仅支持 128 位、192 位和 256 位的密钥长度，分别称为 AES-128、AES-192 和 AES-256。

其实 AES 算法应该见的非常多了，具体算法也不细讲了，如果要真的碰到了，再详细分析。这个算法的加密过程比较复杂，里面还需要用比如 S 盒进行置换什么的。

### SM4 分组密码算法

这个算法也是由国家密码局发布的，分组长度 128 比特，密钥长度也为 128 比特。加密算法盒密钥扩展算法都是采用的 32 位非线性迭代结构。

其实对称加密算法还有许多，包括 DES、Twofish、Safer+等。如果要了解估计要另开一个专题了。

那么如果软件中遇到了对称加密算法，只需要知道**算法的类型和密钥**，就能够编写出注册机了。

## 公开密钥加密算法

对于对称加密算法有一个致命的问题，如果我们在途中知道了密钥，那么该算法的保护就失败了。所以这才有了公开密钥算法。

公开密钥算法的设计都是基于 NP 完全问题。

如果对于软件作者来说，他在生成注册码时采用解密算法(私钥)，而在检查注册码时使用加密算法(公钥)，那么即使能够找到公钥，也不一定能够计算出私钥，也就无法获得正确的注册码。

### RSA

算法的原理依靠着计算大素数乘积难以被分解而设计的。攻击 RSA 算法最有效的方法是求取计算过程中的模 n。

具体原理就此跳过，主要看这个算法具体的应用。

大多数的共享软甲的注册码算法设计的不是非常好，如果真要用这个加密算法，那么模数 n 必须要有一定的长度。并且生成的公私钥一定要尽可能随机，以免直接被猜到。

**注意的是以上的方法之恶能防止解密者写出注册机，但是没法防止修改跳转指令，因此要想办法对代码进行加密。**

攻击的手段是首先判断模数 n 是否很长，如果不长可以直接使用类似 RSATool 来破解，否则尝试使用另一种技术：替换模数。

### EIGamal

这是一种基于离散对数计算的公钥加密体系，密钥长生的方法需要运用到群的知识，那么具体就不详细阐述了。主要是使用下面这个公式：

```
 y = g^x mod p
```

x 为私钥，y、g、p 是公钥。

攻击也就是解密的思路就是根据这个公式来求出离散对数，最后获得 x 的值。

在实际应用中，模数 p 的位数一般都比较大，因此通过求离散对数解出私钥 x 通常不可行。**此时可以采取类似 RSA 中替换 n 的方法去尝试破解。**

### DSA 数字签名

这是美国国家标准与技术局在借鉴 EIGamal 和 Schnorr 签名算法的基础上公布的。目前一致没有充分的证据证明安全性存在很大的弱点。

### 椭圆曲线密码

这个是使用了代数几何学的一个重要的问题，与 RSA 等公钥算法相比它可以使用较短的密钥长度得到相同的安全性。

针对这个密码体系所运用到的数学知识，是数学中的群的知识。而最根本的就是使用了**椭圆曲线离散对数问题**。

ECDSA 算法在实际的商业应用中作为注册验证的主要部分，比如 Safecast、Flexlm。

### SM2 

这是国家密码局发布的一款椭圆曲线公钥密码算法。因为考虑到常用的 RSA 存在严重的安全威胁，所以我国尝试使用 SM2 来替换 RSA。

## 其他的一些编码算法

列举一下常见的可能出现的编码算法：

* CRC32：循环冗余校验码，这是用来生成的数据的校验值，常用于校验数据的完整性。
* BASE64：将二进制数据编码为可显示的字母和数字，这个用来传送一些非文本数据。其实它的一个典型特征就是在最后会使用 == 来填充。

---

## 最常用的加密库

* Miracl 大数运算库
* FGInt Delphi 下常见的用来实现公钥加密系统的库
* freeLIP
* LibTomCrypt
* GMP
* OpenSSL
* DCP 和 DEC
* Microsoft Crypto API
* NTL

