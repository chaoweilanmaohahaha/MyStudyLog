# 漏洞分析

这里将罗列软件漏洞，并且解释软件漏洞是如何被利用的，先从原理入手。

> 为什么要了解漏洞，是因为通过理解漏洞的原因和可被利用的过程，能够提升识别漏洞特征以及安全编程方面的知识。

## 漏洞

### 缓冲区溢出

有时在程序运行之前会预留出一些内存空间，而这些预留的内存空间被称为**缓冲区**。那么缓冲区溢出是指向缓冲区内填充的数据超过了本身的容量，那么就会把合法的数据覆盖。

这种问题主要出在一些开发人员假设长度总是和所分配的空间相匹配，并且假设传递数据的时候总是合法的。这样就不添加主动的合法性检测。

#### 栈溢出

栈里放什么就不用多说了，但是**强调的是栈是向低地址方向生长，而变量在栈中是向高地址生长(缓冲区内的)**。所以如果出现溢出现象，将覆盖前面压入栈的返回地址，使得函数返回发生错误。

#### 堆溢出

堆和栈不同，它由开发人员自行分配和释放，注意堆是向高地址扩展的不连续的内存区域。堆溢出一样，是给堆里分配的变量超过了其分配的大小的值，因此它的后续将会被覆盖。

### 整型溢出

在 32 位系统中，一个整数占 32 位；在 64 位系统中一个整数占64 位。我们也知道对于有符号整数，将第一位作为符号位，其余用来表示数字大小。

整型溢出问题主要是开发人员忽略了数字的范围，而默认属于整数的范围。

整型溢出问题主要分为三类：

* 存储溢出：由不同类型的存储转换构成；
* 运算溢出：就是指在运算过程中没有考虑数字边界问题，造成运算后的数值超过了存储空间。
* 符号问题：一般情况下，对长度变量都要求使用无符号整型数，开发人员可能忽略符号。

### UAF 漏洞

释放后重用漏洞。这样一个场景，A 调用了 B、C、D 三个子函数，如果 B 将 A 某个资源释放，C又开辟了一样的而空间，而 D 重新引用了 A 中的资源，则造成了悬空指针的引用。

## ShellCode

其实在之前注入和 Hook 都有可能需要运行自己编写后置入内存的代码。这就是 ShellCode。它是一段可以单独执行的代码，如果获取 eip 控制并让它指向了 ShellCode，则甚至可以控制计算机。

ShellCode 不能和在 IDE 中的代码一样，调用 API 函数名来实现功能。它需要通过主动查找 DLL 基址并动态获取 API 地址的方式实现 API 调用。

所以 ShellCode 编写的过程一般包括：

1. 获取 Kernel32 基址
2. 获取 API 地址(可能用到 LoadLibrary)
3. 实现功能
   1. 下载执行，即指定 URL 中下载 exe
   2. 捆绑
   3. 反弹 Shell，实现远程 Shell 攻击

### ShellCode 变形

一般 ShellCode 是一些 bin 数据，但是常见的 ShellCode 可能不是这样的数据，而是一些变形后的数据。

* 格式：可能使用 unescape，hextoascii 和 其他语言格式。
* 字符串化：纯字母 ShellCode
* 加密：将代码加密

## 漏洞利用技术

漏洞利用的主要目的是控制 eip 来运行 ShellCode，那么一般 ShellCode 可能出现的位置包括了：

* jmp esp/call esp：0x7FFA4512
* jmp ebx：如果返回地址异常，则 Windows 可能会抛出这样的异常，那么就会查找一次帮处理链表，从中刚找到对应的处理函数。**而 ebx 指向的是下一个异常处理地址。**
* 堆喷射：采用脚本循环申请来填充连续内存使 ShellCode 被相对固定地写入某段内存。

上面三种算是比较常用地方法，下面介绍的这些方法属于比较高级的方法：
**利用漏洞的核心思想是控制 eip 在漏洞进程中注入 ShellCode。**防止这种攻击就是要使所谓 ShellCode 无法执行，这被称为 DEP(数据执行保护)。它将非代码段的页表属性设置为不可执行，栈空间也是类似。

绕过 DEP 的方法就是 ROP。思想就是要在可执行的位置上找到符合要求的指令片段，让这些指令替代 ShellCode 完成准备工作。**为了控制程序的流程，在指令片段的最后要有一条返回指令来收回程序控制权。**

那么在此基础上，ASLR 是针对以上缓冲区溢出攻击的安全保护措施，它的目的是让线性布局随机化。目前的可能的攻击方法是尝试使用未启用 ASLR 保护的程序，在其中寻找跳板。

## 漏洞样本

漏洞样本是证明软件漏洞的最直接的证据，一类样本是证明软件有漏洞，另一类是漏洞利用样本。

那么所谓漏洞分析，就是对已知的漏洞样本进行分析，而大部分直到的漏洞样本是不带漏洞信息的，需要通过静态与动态分析来确定信息。

那么一般这样的漏洞样本可以从许多如 exploit-db 站点找到。

一般我们能够得到的最重要的信息就是漏洞编号，直到漏洞编号，就能够通过搜索引擎查找其他分析人员的分析成果。

通过一系列的静态分析和动态调试，你会对样本本身的 ShellCode 的功能，以及对漏洞样本的利用方式有一个定论。