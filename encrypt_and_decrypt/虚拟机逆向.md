# 虚拟机保护逆向

这一部分的内容针对的是虚拟机保护技术，在虚拟机保护技术中看来了，该技术使用了自己编写虚拟指令，将原本的真实指令转变为字节码然后执行。那么本部分就 VMProtect 来对它进行逆向分析。

## VMProtect 分析

如果采用传统的比如 OllyDbg，IDA 这种软件来分析代码是一个十分复杂的事情，因为虚拟机代码会有很多无用的跳转或者代码乱序，会对分析造成很大困难。

VMProtect 的本质是以基本代码块为单位，在原始的代码中插入许多无条件跳转和条件跳转。无条件跳转的作用是用来分割代码块，条件跳转的作用是生成副本。

回忆虚拟机保护技术的流程，我们直到所有的被虚拟化的原始函数都被清除了，**变成了例如 jmp VMEntry 这种跳转到虚拟机代码的指令。**

分析所有的跳转指令，能够获取这个程序的大致的控制流。虚拟机代码有一个核心基本块 VMDispatcher 用来调度指令，而它基于一个调度表来指示所有 Handler 的地址。

想要继续进行分析就需要将所有表中的句柄都解码，获得各个句柄的地址。

当获得了各个函数地址时，就可以继续分析函数的控制流了。

## VM 还原

注意，VMP 生成的虚拟指令退回成员来的指令、二进制值等几乎是不可能的。从生成的过程中就可以看到，它本身没有 CPU 寄存器的概念，它将寄存器转换成了静态单赋值形式。不过将 VMP 退回到原始的**相同功能**的汇编指令是可行的，在转换的时候只要避免出现寄存器冲突就可以了。

### 分析

我们不能单纯使用静态分析技术或者动态分析技术，我们想要达到的目标是输出全部可能执行的指令。所以这里需要打击那一个虚拟执行环境，在当前的进程环境中加载可执行文件，允许其直接运行。该执行的目的是将字节码转换为可读的中间语言。

针对这样的执行，需要跟踪所有可能执行的分支虚拟指令 vJMP，它几乎可以实现所有的跳转。其次我们要实现执行不同的分支，要用到 Windows 中的**纤程概念**。它比线程小，但是也拥有独立的堆栈和 CPU 寄存器。使用这个就能够执行所有的分支指令，构建一个基本的流程图了。

接下来需要对 Handler 进行识别，也就是说在执行这个 Handler 时需要的参数和结果。在 VMProtect 中可以使用原始的指令作为模板，对每个 Handler 进行匹配。

下一步，需要将虚拟指令转换为不依赖堆栈而依赖变量的多元表达式。可以为这些虚拟指令创建一些临时变量。

接着就是对指令序列做一些处理了，首先要删除一些垃圾代码，这里采用的方法是考察临时变量的引用计数(但是很奇怪的是，这些方法都像是在人为的检查)。随后通过真值表来化简一些逻辑上的指令序列，而完成上述两步就已经拿到了真正有用的指令了，此时我们需要分析寄存器的映射信息。

如果我们可以从代码中获取每个指令中的虚拟寄存器都和哪些真实寄存器映射，那么转换后的指令将更真实。我们可以从如下四个位置来尝试确定：

* 入口：根据物理寄存器中的堆栈模型，我们可以对初始化后的虚拟指令进行分析。
* 出口：正好和入口相反，通过专门数据流查看压入堆栈的顺序产生映射。
* 指令依赖：通过原指令对寄存器的隐式调用来查看依赖关系。
* 通过交汇点传染确定寄存器。

最后使用 DAG 有向无环图来生成指令。

> 中间先跳过很多和编译原理有关的话题，因为这些算法和复杂的编译原理密切相关。所以暂时先跳过。

---

## 一些其他问题

其实上面讲的那些都比较条框化。当然在处理的时候还有一些细节问题。

### call

如果说在分析的过程中存在 call 指令，那么分析就回到当前位置结束。如果硬是要分析的话，就需要对 vRet 和 vJmp 指令进行 DAG 识别，然后对子函数进行分析。

其他还有：

* 产生多余计算指令
* 过度的优化

### 异常

和之前一样，需要考虑不同的编译器对底层 SEH 异常的封装，根据可执行文件中指示的编译器是哪个版本的实现的。根据版本信息对底层指令分析得到真正的异常例程地址，随后分析异常例程的代码，如果符合进入 VMP 虚拟机的特征，就从这里分析出异常历程的虚拟指令。

