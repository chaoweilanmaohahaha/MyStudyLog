# .NET 平台

Win32 平台逐渐过时，微软开始使用新一代的软件开发平台和运行平台，它支持多种编程语言，多种操作系统，多种用途，兼容多种硬件平台，它就是 .NET 平台。

## 概述

.NET 是什么？它是一个软件开发平台，它既可以运行在操作系统之上，又独立于操作系统。可以将它的功能和虚拟机的功能进行类比，只要安装了 .NET 框架，就可以运行 .NET 可执行程序。

如果从系统的角度来看，.NET 就是一系列运行在 Ring 3 级别的 DLL 文件。

所以对于这个平台而言，它又几个特点：

* 最终会被编译为 .NET 中间语言 IL
* 可执行文件变为保存 IL 指令和元数据，结构也发生改变
* 程序将不由 Windows 运行，而由框架运行，由 JIT 引擎负责在运行时进行编译再执行。

接下去将知道这个平台的一系列知识点。

## 介绍

首先要接触一些新的名词：

* MSIL：微软中间语言，大多数时候会被简称为 IL。在这个平台下可以运行许多种高级语言，但是编译后都会生成这种中间语言。那么对这个平台的代码进行分析，就是对 IL 进行跟踪和分析。
* CLR：通用语言运行时，这可以看程时一套标准资源。它是 IL 语言的运行环境，就像 Windows 是 PE 的运行环境一样。CLR 包括了面向对象的编程模型、安全模型、所有 .NET 基类、程序执行等等内容。
* 元数据和令牌：元数据代表了一个可执行文件所有的信息。而令牌用来标识唯一的一个元数据。
* JIT：即时编译，这是平台运行可执行程序的基本方式，这会将 IL 代码编译为本机指令。
* 程序集和模块：一个或者多个可执行代码的模块，加上一些必要的控制信息，就构成了一个程序集，程序集是 .NET 种可执行程序的基本单元。
* 类型与方法：这是面向对象程序设计中的概念。
* AppDomain：应用程序域，也就是类似进程的概念，让多个程序集构成一个应用程序域，随后代码只能访问本域内的数据。

## MSIL 和元数据

这两个概念是比较重要的，IL 会对元数据进行操作，而 IL 本身又是由元数据定义的。

在 PE 结构中，还有几个数据目录项是没有使用的，那么 .NET 平台就对它进行了扩展，其中有一项 Common Language Runtime Header。这个头部指向 .text 区块，这里存放的不再是汇编指令，而是 IL 代码和元数据。

CLR 头部藏在 .text 的第二项。

![CLR](..\img\CLR.png)

在这个头部中最重要的，就是元数据信息，MetaData 结构会以一个元数据头开始，其中罗列了有关这个元数据的各个信息。

紧跟着头部份的是几个数据流的头，其中分为堆和表。元数据头会指明这些数据流的偏移。其中包括 #String、#US、#~ 等等。这些数据流头部就是指明了存储的偏移、大小和名称。

像对于 #~ 来说，也就是元数据表流，已定义的表有 45 个，而每个表都代表了不同的记录功能。如果一开始不清楚，借助一些工具，比如 Dotnet Explorer 等等就能探索在 .NET 下的 PE 结构和元数据了。

### IL

IL 相对于高级语言，它更为底层，但是它又不和内存地址打交道。如果对 .NET 平台进行加解密，IL 不得不学。

它最大的特点是以栈为基础进行操作，而不会直接使用寄存器和内存。在编写 IL 的时候一定要注意栈平衡，并且部分的执行是直接对栈进行操作的。

对于解密人员来说，使用 IL 的机会会更多一些，比如说可以使用 ILDASM 对源程序反汇编，然后使用其中的代码编写注册机。

元数据在 IL 中使用令牌来定位，Token 是一个类似于 AABBBBBBh 的值，其中 AA 代表的是对应的表，BBBBBB 代表在表中的位置，也就是索引。

而每个 method 还会有相应的签名，方法由令牌和签名确定，方法的代码根据令牌来查找，方法的调用方式、参数个数和返回值类型由签名确定。

## 分析方法

### 静态分析

静态分析的要求是使用反汇编工具将程序的至零字节反汇编为 IL 或者高级语言。反汇编工具中最强大的就是 SDK 自带的 ILDASM。并且经过反汇编的代码得到 IL 后，通过修改，就可以直接用 ilasm.exe 编译成可执行程序。

而最好用的反汇编工具是 Reflector，它可以将反汇编的结果变为高级语言。

### 动态分析

最简单的方法是直接使用调试工具，比如 PEBrowseDbg 或者 OllyDbg。

### 代码修改

在 .NET 中 PE 文件有三种方式加补丁。

1. 使用 ILDASM 将代码反编译成 .il 文件，然后修改 IL 代码，再用 ILASM 编译回可执行文件。
2. 二是直接在 PE 文件中找到 IL 代码所反映的数据，用十六进制工具来修改。
3. 利用工具将反编译代码导出为 C# 工程(修改量大)。

## .NET 代码保护技术及逆向技术

### 强名称

强名称是一种 .NET 提供的认证机制，而不是和代码有关的什么命名规则，这种认证主要包括标识版本和原作者。**标识版本是为了让多个不同版本的 DLL 在平台中可以共存**；**标识原作者是为了验证程序是否被篡改**。

假设有幸使用，然后在 sdk 命令行中生成 xxx.snk 密钥文件，随后用这个签署目标文件，你会发现反汇编的文件中 .assembly 中会多出 .publickey 和 .hash alogrith。这两个项就是这个程序集的**强名称和使用算法**。如果对这样的文件直接修改内容就会报”**强名称错误**“。

#### 补丁

对于这种程序集打补丁，必须想办法绕过强名称机制。那么我们必须知道一个文件中哪里标识了这个文件使用了强名称。

* CLR 头中的 Flags 位
* CLR 头中的 StrongNameSignature
* Assembly 表中的 Flags 项
* Assembly 表中的 PublicKey 项

事实上已经有专门的工具 Strong Name Remove 工具直接移除强名称。并且关于替换强名称也有现成的工具，比如 RE-Sign。

### 名称混淆

混淆器 Obfuscator 的目的是为了将所有的名称都变为无意义的字符，这个方法增加了反编译代码的阅读难度。最简单的名称混淆原理是改变 PE 文件中的 #Strings 流的数据。

混淆器能将名称变得面目全非，但是程序仍然能正常运行，**为什么呢？对于 .NET 上的程序集，只需要保证元数据中关于方法的表中的代码偏移和大小不错就对代码没有影响，名称就是给人看的而已**。除了一些特殊的函数。

针对名称混淆，其实并不会影响静态分析，但是只不过增加了分析的难度。**需要注意的是混淆并无法保护原始的代码，只会提高原始代码的阅读难度。**

### 流程混淆

流程混淆的目的是打乱程序执行流程，隐藏程序的逻辑。**这种混淆的层次可以分为方法级别的混淆和 IL 级别的混淆**。

关于方法级别的混淆参考工具 Anonymization；代码级别的混淆就是将原方法的 IL 代码次序打乱，这样在一定程度上可以防止反编译工具直接翻译为高级语言。

那怎么对付流程混淆呢？你可以在静态分析的工具来进行流程分析，特别是使用像 IDA 这种带有可视化界面的工具；并且一般这种流程混淆，都有明确的算法，我们只需要分析其对应的算法就可以了。

### 压缩

这里的压缩，特别的值对源程序添加一个压缩壳。比如说使用纯 .NET 编写的压缩壳包括 Sixxpack 软件，这个程序会把源程序压缩后存储到一个新闻间，随后在执行的过程中会通过解压还原源程序(Assembly.Load)。

### 加密

如果一个程序声明必须在 .NET 下运行，但用 PEiD 检测发现它是一个 Win32 程序，那么这个程序多半是被加密了。最流行的平台的保护措施之一就是利用 Win32 的本地代码通过加密元数据、挂钩系统内核等手段保护源程序。

因为 mscorwks 和 JIT 在整个 .NET 中的核心第位，所以大多数加密软件都以这两个 DLL 为突破口，或进行挂钩或者包装。**目的是在 JIT 前将加密的 IL 代码和元数据恢复正常，并在方法结束后将元数据和 IL 代码销毁。**

> 具体的加密分析按照具体的例子来分析

### 其他手段

* 反检测：在程序保存注册信息时，比较忌讳 Spy 软件的检测，因此在进行关键操作时，往往会检测是否有 Spy 软件正在运行。
* 反调试跟踪：在 .NET 下则通过 System.Diagnostics.Debugger 来检测。
* 网络验证
* 虚拟机
* 加密锁