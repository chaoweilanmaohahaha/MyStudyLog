# 虚拟机保护技术

这个区别于虚拟机技术(VT)，这里的虚拟机保护技术是用基于虚拟机的代码保护技术。这里的虚拟机，是一种解释执行系统。

## 原理

虚拟机保护技术是将基于 x86 汇编系统的可执行代码转换为字节码指令系统的代码，来达到保护原有指令不被轻易逆向和篡改的目的。

**字节码**是由指令执行系统定义的一套指令和数据组成的一串数据流。类似于 JVM 中的字节码一样。那么一般来说虚拟机在运行的时候大致如下：

虚拟机从 VStartVM 开始初始化虚拟机，由 VMDispatcher 调度许多 Handler，而每一个 Handler 对应了一条字节码中的指令。

### 准备

本来的代码在最后会转换为 8086 指令。那么在我们执行虚拟机保护技术，它必须把 8086 的指令反汇编为可读的代码结构。也就是使用现成的反汇编引擎。

当前主流的动态语言的虚拟机一般基于 Stack-Based 和 Register-Based 两种模式，目前除了 Lua 的是基于寄存器结构的，其他都属于栈结构的。

## 启动和调用

VStartVM 将真实的环境压入栈中，然后生成一个 VMDispatcher 标签，当句柄执行完毕会跳回这里形成循环。

它将所有寄存器的符号压入栈中，比如使得 esi 指向字节码起始地址，ebp 指向真实的栈，edi 指向了 VMContext，esp 指向 VM 使用的栈地址。当你读取一段字节码之后，就用 jmp 指令跳到句柄表中的相应的句柄。

所谓的 VMContext 是虚拟的环境结构，里面存放许多寄存器的值，除了 esp 寄存器。(esp 寄存器的值存放在了 ebp 寄存器中了)

在所有的 Handler 中应该存在一个 vBegin 句柄用来平衡栈，当执行完这个平衡栈操作后，就可以开始执行真正的代码了。同时要注意，在 Handler 中加入一个对栈的处理，因为所有的数据都是压入栈中的，而虚拟机环境也是压入栈中的，所以如果有将数据需要被压入栈中，需要检测当前的数据是否已经到达了虚拟机环境中了。

## Handler

这里的 handler，是专门给虚拟机单独调用的一小段程序，那么一般普通的 Handler 就是执行普通的 x86 指令，但是不乏一些如 vBegin 这样的句柄，它纯粹做到一些辅助的功能。

其实辅助函数大部分的作用都是处理栈中的问题，压栈弹栈，以及检查栈内的情况。主要看一下普通的 Handler 是怎么处理的

### 指令拆解

我们模拟函数调用的方法，当某条指令需要执行时，如 add a，b。此时先通过压栈的 Handler 将参数压到栈内，那么在调用这个 vadd Handler 的时候只需要从栈中拿到对应的参数就行了。例如可以写成：

```
vPushReg eax_index
vPushReg esi_index
vadd
vPopReg esi_index
```

注意有很多指令是会设置或者判断标志位的，比如 adc 指令，则在相关的 Handler 执行前需要保存标志位，在执行后恢复。

#### 转移指令

转移指令在这里面包括了条件转移、无条件转移、call 和 retn。

当我们遇到条件转移的时候，我们一般使用 esi 指向当前的字节码的地址。所以这样可以参考真实情况下的跳转。另一种方法是根据标志位来判断是否跳转，然后模拟跳转就可以了，**需要多加一步取标志位的操作**。

对于 call 指令，目前的这些指令都是在一个栈空间内执行的，那么当遇到 call 指令的时候这些代码是无法由虚拟机控制的，所以需要在此时退出虚拟机。**模仿 call 其实就是模仿调用时的过程，只不过最后要返回到虚拟机控制代码中**。

对于 retn 指令，在这里虚拟机要把它当成一个退出函数，让它返回到原本的地址处。

## 异常处理

要做到对执行流程的绝对控制，就必须处理异常控制，也就是防止它打破原本的执行控制流。单纯模拟异常处理不能很好解决这个问题，所以只能针对编译器来模拟。

我们的实际做法是，先反汇编某个编译器的异常处理程序代码，然后查看它的做法，随后模拟其做法就可以完成异常处理了。