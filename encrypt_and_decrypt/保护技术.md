# 保护技术

## 序列号保护技术

序列号或者说注册码技术，使保证网上的一些共享软件在一般都有使用时间或功能上存在限制。只有把自己的信息告诉软件公司或者缴纳费用后，软件公司计算出一个序列号，随后发给用户，从而解除时间和功能限制。

所以在软件启动的时候，一般会从磁盘或者注册表中读取注册信息并对其进行检查。

验证序列号的过程，其实使验证用户名和序列号的映射的正确性，一般有如下方法：

* 用户名等信息作为自变量，通过函数 F 变换得到注册码。(这种方法会把注册码生成的过程暴露出来)
* 使用注册码验证用户名，也就是这个函数 F  是可逆变换，而注册码此时不会出现在内存中。(要么猜出变换，要么根据给定验证码，推出用户名)
* 使用对等函数检查注册码
* 同时使用用户名和注册码作为变量生成特定的值。这种方法会失去一一映射关系。

### 如何攻击

如果要找到序列号，或者说修改判断序列号之后的跳转指令，则最重要的是要定位判断序列号的地方。

一种方法是跟踪输入的注册码，而且一般用户会在一个编辑框中输入注册码。比较常用的 API 包括 GetWindowTextA、GetDlgItemTextA、GetDlgItemInt、hmemcpy等。当然最后显示的对话框，告诉注册码是否正确也是一个切入点。

另一种是跟踪程序启动时对注册码的判断过程。

#### 数据约束性

数据约束性或者密码相邻性保证，一般内存中序列号会存放在用户输入序列号的内存地址 +-90h 字节的地方。

#### hmemcpy函数

是最有用的函数，目的是将内存中的一块数据复制到另一个地方。

#### 利用提示信息

即查询人机对话过程中的提示信息在内存中的位置。

### 制作注册机

对于明码比较的软件，攻击很容易，利用 keymaker 软件，它能够拦截程序指令并将出现的明码直接显示出来。所以使用 keymaker 软件可以制作出相应的注册机。

如果使用的是非明码的算法，就需要提取生成序列号所用的算法了。

## 警告窗口

这里的警告窗口的意思是，软件设计者会时不时提醒用户购买正式版本的窗口。

去除警告窗口的常用方法是：修改程序的资源(改成透明或者不可见)，静态分析和动态分析。

如果是调用资源来显示资源中的对话框，则可以使用 eXeScope 或者 Res Hacker 打开。

如果说不是以资源形式存在的，则需要尝试使用消息断点。

## 时间限制

有关时间限制的程序有两种，一种是限制每次运行的时长，一种是有类似使用 30 天的时间限制。

### 计时器

如果说每次运行都有时间限制，那么说明程序中存在着计时器来统计程序运行的时间。一般在 Windows 中计时器有如下选择：

* setTimer
* timeSetEvent
* GetTickCount
* timeGetTime

### 时间限制

这种程序的套路一般就是，在安装程序的时候获得了当前系统的日期，然后记录在了系统的某个地方，每次运行时和该记录比较一下就行了。对于某些情况处理不够周全，我们有的时候故意把机器时间调回去。

如果考虑比较周全，软件必然会保存两个时间值。一个是安装时间，这个时间会在最初保存下来并且可能存储在多处；二是最近一次运行时间。所以你需要监视系统中获取时间的 API 函数，或者监视读取需要频繁修改的系统文件。揭密者通常使用 RegMon 或者 FileMon 监视软件。

辅助工具变速齿轮可以加快和减慢应用程序的时间，一般和动态分析配合使用。

## 菜单功能限制

这种程序主要现象是菜单或者窗口中的某些选项是灰色的。但是这种限制也分成两种可能。

一种是试用版和正式版的软件是两个完全不同的版本。那么解密者想在试用版中用到正式版一样的功能几乎是不可能的。

另一种是试用版和正式版是同一个文件，那么那些被禁止的代码是在程序之中的。那么我们需要考虑如下一些函数：

* EnableMenuItem
* EnableWindow

## KeyFile

这是一种用文件来注册软件的保护方式，它的内容一般是一些加密或者未加密的数据。试用版中一般没有这个文件，只有在购买正式版后才会给出这个文件。

所以一般而言软件启动的时候需要从文件中读取数据，然后判断是否是正确的注册文件。对于软件作者，通常可以在文件中添加一些垃圾信息来干扰解密者。对注册文件的合法性检查可以分成几部分，也可以让注册文件的部分数据和软件中的关键代码或者数据发生关系。

因为这和读写文件有关，所以在破解时要关注和文件有关的 API 函数！

### 攻击手法

用 Process Monitor 等工具来监视软件文件的操作，来找到 KeyFile 文件名；然后伪造对应的文件，这需要分析对于文件的什么内容进行了判断。

## 网络验证

网络验证是目前很流行的一种保护技术，这样关键的这些数据就在服务器上，软件必须从服务器中取得这些数据才能运行。

要破解必须要拦截服务器上返回的数据包。

与之相关的函数就是 send 和 recv 两个函数。

### 破解的方法

如果分析完了发送和接收的步骤，比较简单的一个解决方法是编写一个服务端，然后模拟服务器来接收数据；如果软件是用域名登录服务器，那么可以修改 hosts 文件。

当然除了编写服务端，也可以直接修改客户端程序，比如把 send 功能去除，然后再填充读写内存区域的数据。

## 光盘检测

有部分以光盘形式发行的软件，会在使用时要求检查光盘是否插在光驱中。如果没有的话就拒绝运行。目的是为了防止用户将软件拷贝下来然后在多台机器上使用。

一种最简单的最常见的就是在程序启动的时候判断光驱中是否有特定的文件。如果是使用了这种方法，则程序的实现方法一般是：

1. 使用 GetLogicalDriveStrings 或者 GetLogicalDrives 函数得到系统安装所有驱动器的列表。
2. 使用 GetDriveType 函数检查每个驱动器
3. 使用 CreateFile 或 FindFirstFile 检查特定的文件是否存在

但是有一种增强手段，会把程序运行时需要的重要的数据也放在光盘中。但是这种方法也有破解方式，只需要用虚拟光驱程序模拟正版光盘就可以了。

## 只运行一个实例

理论上一个应用程序可以多次运行，形成多个运行实例，但是有时候基于安全，只要求程序一次运行一个实例。

程序中一种做法是在运行前，使用 FindWindow 等函数查找是否有同名的窗口。

当然有的时候会判断是否有互斥对象，使用 CreateMutex 函数实现。



