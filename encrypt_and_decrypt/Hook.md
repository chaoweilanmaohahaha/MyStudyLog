# Hook

Hook 直接翻译是钩子的意思。我们想象一下，如果我们现在有一个指令流，**我们需要对该程序进行监控、拦截**，我们必然要在某个地方设置一个网来拦截，所以 Hook 技术就是帮助我们完成这个功能。

既然称为钩子技术，那么必须使用某种手段来下钩，这是对某个特殊的过程进行干预。

比如说我们可以使用 IAT Hook 技术篡改 MessageBox 的消息。

## 分类

其实对于一个程序而言，无非就是一些数据和指令，它们都能够影响程序的执行，因此根据这个特点就分为两类 Hook，一种修改数据，一种修改指令。(映射到指针，你可以想象一个是修改指针，一个是修改指针指向的内容)

### Address Hook

这种方法是通过修改数据达到 Hook 的效果，当然主要是指修改一些函数的**地址**。所以这个方法的本质需要找到跳转到的函数的地址存放在哪里。那么一般这些地址都在哪里呢？

#### IAT

PE 文件的输入表，我们在研究输入表的时候确实知道，IAT 存放的是外部导入的函数地址，但是这种方法存在局限：**作用范围只针对被 Hook 的模块，并且必须是以静态链接的方法调用 API**

#### EAT

PE 文件的输出表，这里存放了函数地址的偏移，而不是实际的地址。因此如果要进行 Hook，需要使用函数地址减去模块的基址。这种 Hook 方法只有在对 Hook 掉的函数调用时起效。

#### user32.dll 回调表

这里面存放了一个 USER32!apfnDispatch 的回调函数表，这通常和 KeUserModeCallback 函数。

#### IDT

中断描述符表，只有发生中断时，指出需要交给哪一个中断处理程序去处理。

#### SSDT

系统服务描述符表，应用程序调用了 API 后控制流首先就是到这个表中。

#### C++ 的虚函数表

在之前涉及 C++ 的分析中指出过，编译器会专门使用一个虚函数表来存放各个虚函数的地址。

#### COM 接口功能函数表

COM 技术是 Windows 中常用的一种技术，可以使用不同的语言编写 COM 组件，然后在二进制层面暴露统一的接口。同一个 COM 接口的所有接口函数都放在一个表中。

---

以上是一些经典的表结构，但是不乏其他场所也会出现对应的函数地址：

* 处理例程地址
  * 驱动的 MajorFunction 和 FastIo
  * StartIo 等地址
  * OBJECT_TYPE 中的 _OBJECT_TYPE_INITIALIZER
* 特殊寄存器地址：比如说寄存器组中的 IA32_SYSENTER_EIP
* 一些特定的函数指针：这个散布在许多程序之中都会有相应的函数，一个有名的函数时 KiDebugRoutine，它时内核调试引擎的异常处理函数，所以这个 Hook 可以起到反内核调试的作用。

### Inline Hook

这个方法直接修改指令，也就是说它的关键在于转移程序的执行流程，根据具体架构的转移指令，比如 jmp，push，retn；还有一种 HotPatch 方式，专门实现 Hook。

### 基于异常处理

在之前也提到过 SEH 和 VEH，那么只要在系统中自行安装 SEH，然后向 Hook 的位置写入引发异常的指令，或者直接让 Hook 的模块产生内存访问异常。

通常来说，使用 VEH + INT 3 的方法更有实用性。当然在 CPU 虚拟化技术中也能用这种技术捕获 Guest OS 执行特权指令引发的异常事件。

### 其他 Hook

那我们发现，其实 Hook 的本质，就是控制程序的执行流，然后执行自己的一些处理。其实一些病毒本身也是做的这些工作。

对于一个病毒而说，它可以修改执行入口后，重新回到原始的执行顺序。

当然操作系统本身也提供了许多钩子函数，来专门做回调函数。

## Hook 的位置

在调用 API 这一操作上，控制流必定会经过许多层，那么其实在每一个层面上都可以进行 Hook。

所以在 Hook 之前一定要先弄清整个调用过程，并且对每个位置的拦截范围和内容有一个认识。从控制流由上至下，可以知道影响程度在逐渐增大。

## Hook 的过程

无论使用那种方法，都需要一个自定义的函数来替代被 Hook 函数。

对于 Address Hook，首先需要定义一个和被 Hook 函数原型一致的函数指针，接下去根据不同的 Hook 类型，查表替换原地址，关闭写保护，然后写入函数地址。

对于 Inline Hook，有一个 Trampoline 函数的概念，这个函数给出了定义原函数的入口。该函数执行了被替换的前几条指令，也就是说 Trampoline 函数和 目标函数中被 Hook 位置之后的部分构成了完整函数。首先观察要被修改的指令，如果对这些指令进行替换，就需要在 Trampoline 函数中执行这几条指令来确保原函数的功能；接下去准备好 Trampoline 函数，然后写入 Hook 指令就行了。

## Detour 函数

Detour 函数，也就是我们自己编写的 Hook 函数。一般 Detour 函数的编写都是为了 Hook 的目的，对感兴趣的内容进行拦截、复制、记录等等。那么 Detour 函数无非这些操作：

* 检查参数：特别是检查 _in 型参数
* 检查结果：特别是检查 _out 型参数
* 拦截调用或下发：重过程的函数必须在调用前就拦截，而其他函数可前可后。

## 注意

* 多线程安全：在 Hook 代码中，要避免其他线程到达这里，造成程序崩溃。针对这种情况，要么你让其他线程暂停，要么使用 CPU 提供的 lock 指令。
* Detour 的多线程安全
* 指令碎屑：用不到的指令字节用 nop 填充
* 恢复现场
* 注意返回值
* 避免重入：也就是无限递归

## 应用

1. 实现增强的二次开发或补丁
2. 信息拦截
3. 安全防护

