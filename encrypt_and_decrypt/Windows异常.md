# Windows 异常处理

异常时操作系统处理程序错误或异常的技术总称。那么这里需要介绍一下在 Windows 中出现的数据结构，以及异常处理使用的技术 SEH 和 VEH。

## 异常

老生常谈一下，从 386 开始处理器引入了中断和异常。中断指的是外部硬件设备或者异步事件，异常则是内部事件产生的，分为故障、陷阱和终止。

从 2000 系列开始，Windows 就是用如下的异常处理过程。

### Windows 中的异常概念

异常就是在应用程序正常执行过程中发生的不正常事件。当然异常也分硬件和软件，由 CPU 引发的是硬件异常，由操作系统或者应用程序发生的是软件异常，那么在系统中存放了一个**异常列表**。

在 Windows 启动之后，会运行在保护模式下，这样 CPU 必须通过中断描述符来寻找处理函数。**IDT** 是在物理内存中的一个线性表，一共有 256 项。每个 CPU 都有一份拷贝，其实这个设计和 Linux 中几乎一样。

IDT 每一项都是门结构，这是中断和异常的必经之路，包括：

* 任务门：CPU 任务切换
* 中断门：描述中断处理程序入口
* 陷阱门：处理异常处理程序入口

如果我们把异常看成一种中断，则发生异常时会根据中断类型号来执行对应的中断处理程序。Windows 内部会将异常信息封装，并且生成一个异常帧来封装线程状态。在包装完成后就会调用内核的 DispatchException 来处理异常。

#### 内核态处理异常

也就是内核中出现异常，那么：

1. 检测当前系统是否正在被内核调试器调试。如果存在，则系统把它交给内核调试器，并且注明这是第一次机会，看是否能处理这个异常，如果无法确定该异常是否处理，则会通知用户是否处理，否则由调试器处理异常后返回现场。
2. 如果不存在所谓的内核调试器，则系统调用 DisatchException 函数，根据 SEH 来处理异常。
3. 如果上面一步依旧没有处理该异常，则系统会给调试器第二次处理机会。
4. 如果仍然不存在，则为了避免出现更加严重的问题，系统会生成 BSOD 错误。

#### 用户态处理异常

如果是用户模式下出现了异常，则：

1. DispatchException 函数会检测内核调试器是否存在，如果存在则交给内核调试器，但是可能出现内核调试器不接受该异常，此时：
2. 如果此时异常程序正在被调试，则将异常信息发送给用户态调试器，这是第一次机会；
3. 如果不存在这样的调试器，就需要将控制权交给用户模式下的 ntdll.dll 去处理用户态异常，这一部分使用到了 SEH 和 VEH 两种异常处理机。
4. 如果仍然没有处理该异常，那么就会再次将该异常发送给用户态调试器，这是第二次机会。
5. 如果仍然无法处理，则会将异常发送给异常端口，该端口由子进程 csrss.exe 监听，此时就会弹出**应用程序错误这样的对话框**。

## SEH

SEH 结构化异常处理，它是 Windows 操作系统的一种错误保护和修复机制。从程序设计来看，它就是系统在终结程序之前给程序提供一个执行它预先设定的回调函数的机会。

### 数据结构

#### TIB

线程信息块，藏在 TEB 的头部，保存线程基本信息。而该结构中，与异常相关的项指向 EXCEPTION_REGISTRATION_RECORD 结构的指针中，它就在 TIB 的第一项中。

#### EXCEPTION_REGISTRATION_RECORD

该结构描述了线程异常处理过程的地址，其中该结构中还有 Handler 是指向了异常处理回调函数，而 next 指向下一项异常处理过程函数。

#### EXCEPTION_RECORD 结构和 CONTEXT 结构

这两个结构描述了异常发生的异常相关信息和线程状态信息。

#### EXCEPTION_POINTERS

为了能够让用户态异常处理程序能够访问相关的数据，这个存放了上述的两个结构。

### 安装与卸载

其实 SEH 的安装和卸载很简单，fs:[0]  总是指向异常处理程序的链表头，那么如果要安装一个新的 SEH 异常处理程序，主要填一个新的 EXCEPTION_REGISTRATION_RECORD 结构就可以了。也就是一个链表的头插法。

那卸载就是恢复 fs:0 的原始值就可以了。

### SEH 异常处理程序

异常是怎么分发的？异常处理的过程是系统将异常发送到各个异常处理单元进行处理。用户态异常分发从 ntdll!KiUserExceptionDispatcher 函数开始的。此时我们已经知道栈中有 EXCEPTION_RECORD 和 CONTEXT 两个结构了。

在这个函数中 ntdll!RtlDispatchException 函数用来具体分发异常，只有被处理，才会返回正常额程序，否则将给出第二次机会。

而 ntdll!RtlDispatchException 中做的主要是调用 VEH 的异常句柄来处理异常，如果失败则继续进行 SEH；否则就要遍历当前线程的异常链表，也就是上面提到的 SEH 的处理函数。最后需要调用 VEH ContinueHandler 进行异常处理。

这里要提及一点，仔细研究异常句柄的加载过程，可以发现异常处理指针总是指向最新的处理方法，而只有当前的处理方法解决不了异常才会继续，知道最后一个结点，这是系统设置的一个终结处理函数，他总是会选择处理异常。

#### 栈展开

先讲一下什么是栈展开，在程序发生异常，但是所有的异常处理回调函数都不处理异常的时候，**系统会在终结程序之前给发生异常线程中所有注册的回调函数一个调用，这是给它们一个清理机会，做类似释放资源的工作。**

那么只有在终结程序的时候才会实施栈展开，(具体为什么没搞懂，大概是因为嵌套调用了回调函数的原因），原因是外层的回调函数可能改变执行地址，比如转到一个安全的执行地址或者栈指针的情况下，就可能造成潜在的错误，所以需要让 fs:[0] 指向的回调函数开始在执行一遍，来清理现场。

那么在比如 C 语言这种高级语言中，C编译器就提供了类似的异常处理机制，那么对 SEH 异常帧进行了封装，使用的真正结构是 CPPEH_RECORD。同时像 MSC 引入了 try，except 和 finally 关键字。

但是像 MSC 这样的编译器很奇怪，一个函数中无论使用多少个嵌套的或者重复使用 Try 块，它都只会注册一个 ERR 结构挂入异常链表中。那么这里 MSC 会提供一个代理函数，即其中的 Handler 设置为 MSC 的某个库函数，这个存在在 ERR 的 ScopeTable 数组中，而这个由编译器提供的异常处理函数叫 _except_handler3，而这个函数又会执行编译时生成的在 ScopeTable 中的 FilterFunc(用来过滤处理什么异常) 和 HandleFunc(异常处理代码或者终结代码)。

编译器会给每个触发的 try 块一个索引。进入每一个 try 块时设置当前 try 块的索引值，然后执行代码。

VS 2010 中它的 SEH 具体实现和 VC 6.0 几乎一样，唯一的区别是它在 SCOPETABLE 中增加了防止缓冲区溢出的栈验证机制。C++ 中多了 throw 关键字，其机制是内部调用了 kernel32!RaiseException。

### 顶层设计

顶层设计是系统设置的一个默认异常处理程序，对于所有线程来说，如果线程异常得不到处理，最终都会到这里。

**我们首先要知道在执行一个 exe 的时候，进程并不是从 exe 入口点直接开始运行的。**ntdll.dll 做了一些准备工作。在这个过程中，操作系统在执行任意一个用户线程的之前，都已经为它安装好了一个默认的 SEH 处理程序，这也是第一个 SEH 处理程序。其中使用的回调函数是 kernel32!_except_handler3，过滤函数是 kernel32!UnhandledExceptionFilter。

而普通的顶层异常处理就是在线程结束之前给用户展示一些异常信息等等的处理。

主要来看一下它使用的 UnhandledExceptionFilter 函数，这个函数非常重要。

1. 首先这个函数会对错误进行预处理，它会检测异常中是否嵌套异常；检测当前代码是不是 EXCEPTION_ACCESS_VIOLATION和引起异常的操作是不是写操作；检测当前进程是否正在被调试。
2. 这时微软提供了用户一个干预的机会，微软提供了一个 API 函数 SetUnhandledExceptionFilter 函数，用户由此设置一个顶层异常过滤回调函数，这才是本质的顶层异常回调函数(这里不知道具体是什么函数)，而且这个函数会保存为全局。
3. 最后进行终结处理，依赖于用户的设置：
   * 检测应用程序是否使用 SetErrorMode()，如果设置，不给出任何错误提示。
   * 判断当前进程是否在 Job 中，考虑直接结束进程。
   * 读取 JIT 调试器，看是否需要交给调试器。
   * 如果不需要自动调用调试器，则会以异常信息作为参数调用它的 ReportFault 函数，**并根据设置不同，调用 DwWin.exe 不同类型的弹窗**。

Windows xp 的入口是 kernel32!BaseProcessStartThunk，但是从 Vista 开始入口点编程了 ntdll!RtUserThreadStart。

**所以使用的一般模式是：使用 SEH 捕获异常，并对那些预料之中的异常进行处理，其他无法处理的异常都会到达 UEF 函数处，由用户设置的回调函数进行收尾处理。那么对于这些没法处理的这些异常，开发人员使用了快照的方法，也就是使用 Dump 文件保存了现场，然后发送给开发人员。**

### 安全性

#### SafeSEH

这是从 XP SP2 开始引入的一种安全机制，由操作系统和编译器联合提供。

编译器在编译 PE 文件时加入一个 SafeSEH 开关，这会在编译阶段提取所有异常处理程序的相对虚拟地址，存入一个表中，而这个表的位置存在于 PE 头部。当 PE 文件载入内存，与这个表有关的所有的信息都会存入内存，异常发生时只要从这个表中去找就行了。而操作系统存在机制专门验证这些执行这些执行函数的真实性，如果不是在上述的表格中的，则退出。

#### SEHOP

覆写保护机制，用来检测是否被覆写。

这个的核心主要有两点：

* 检测 SEH 的完整性，即是否每一个结点在栈中；
* 检测最后一个结点是否在 ntdll 的ntdll!FinalExceptionHandler中。

只要 SEH 结构链表的完整性被破坏，SEHOP 就能检测出异常。开启 SEHOP 后会在链的最后加一个节点，这个节点就是 ntdll!FinalExceptionHandler，它不会影响到异常处理顶层设计。

## VEH

XP 以上版本引入了一种异常处理机制，向量化异常处理。

VEH 和 SEH 类似，也是注册一个回调函数，可以使用 AddVectoredExceptionHandler 注册 VEH 回调函数。VEH 也构成一个链表但是其中除了回调函数之外，还有另一个参数不是 next 指针而是一个数字参数 FirstHandler。根据注册函数的返回值，卸载对应句柄。

理论上在异常发生时，VEH 会优先于 SEH 获得控制权。VEH 的相关信息存储子在 ntdll 中，并且 VEH 对整个进程范围都有效，所以 VEH 不需要栈展开。

在 Vista 后，微软推出了新的方案 VCH。

## 64 位异常处理

对于原生的 x64 程序，它的异常分发流程和 x86 完全一致，只不过相关的数据结构变了，存储位置变了。

在编译阶段，确定所有异常处理 Handler 的地址并将其放到一个只读的表中，在异常发生的时候就去表中寻找 Handler。所以就变成了基于表结构的异常分发机制。

WOW64 是 x64 平台上运行 32 位程序的机制，它通过 64 位的 ntdll.dll 的 KiUserExceptionDispatcher 勾住异常分发过程。它能捕获用户模式下的环境记录，然后转换为 32 位的异常环境记录，最后交给 32 位 ntdll.dll 的 KiUserExceptionDispatcher，接下去就是与 32 位程序中的异常分发过程一致。

---

**事实上，大量的程序错误都源于对输入数据的有效性验证不够导致的内存访问错误。**

通常在应用程序中，对用户输入做合法性验证要用到异常机制(IsBadxx)和驱动层上的输入合法性验证(ProbeForRead/Write)。

而在加密与揭秘中常常会使用 SEH 来实现一些隐蔽的调用和功能，比如说主动制造异常达到反调试的目的、改变程序流程达到反跟踪目的。