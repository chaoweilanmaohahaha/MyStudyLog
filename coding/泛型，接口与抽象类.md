# 泛型、接口与抽象类

## 泛型

泛型的概念本质是让类型也变得参数化。如果我们可以定义一种数据结构，在这个数据结构中添加得数据类型根据我们得需求来指定，那么这个数据结构就有很高的扩展性。就比如说我们写了一个线性表，如果这个线性表中的数组是int，那么这个线性表的作用局限于对于整数进行操作了。

因此泛型的本质就是**参数化类型**。我们可以在定义或者操作的过程中指定它操作的类型。那么在Java中常见的有包括泛型类，泛型方法和泛型接口。

那么首先知道，泛型在定义后是否就已经区分类型了呢？尝试一下：

```java
List<String> a = new ArrayList<>();
List<Integer> b = new ArrayList<>();
Class c = a.getClass();
Class d = b.getClass();
System.out.println(c.equals(d)); // true
```

**java中的泛型只在编译阶段有效，当检验完泛型的类型之后，就会将泛型的信息擦除，也就是说在运行时，泛型信息不会带入。泛型在逻辑上看成了多个不同的类型，实际上都是相同的基本类型（Object），可以看一下源码。**

### 泛型类

```
public class A<T> {
    ...
    private T key; // T类型和外边定义的类型相同
}

//实例化
A<Integer> b = new A<>();
```

当然并没有说定义了泛型之后，在实例化的时候必须指定类型，比如下面使用List的一个实例：

```java
List g = new ArrayList();
g.add('a');
g.add(1);
```

这个照样是对的。**也就是说使用泛型时，只有传入了类型，后面操作才会有类型的限制，否则就可以是任何的类型。**

### 泛型接口

```
public interface A<T> {
    public T next();
}
```

未传入类型参数时，在实现这个接口的时候也需要和接口的泛型相同：

```
class B<T> implements A<T> {
    ...
}
```

如果已经传入了类型参数，则需要将所有使用到这个类型的地方替换成对应的类型：

```
class B implements A<String> {
    @Override
    public String next();
}
```

### 泛型方法

泛型方法，是指在调用方法的时候指明了泛型的具体类型。

```
public <T> T A() {
    ...
} // <T> 是必不可少的一部分，这就是说明这个方法属于一个泛型方法
```

### 泛型通配符和泛型上下边界

我们可能会遇到：

```
List<?> list
```

这种形式，这个是一种无边界通配符，但是它本身是持有某种类型但是不知到具体是什么类型的，而如果定义位List list的话，那它的意思是指定了每一个元素都是Object类型，这就是为什么之前发现不指定泛型什么类型都可以添加。

那么更上一级，我们还遇到过：

```
List<? extends Number> A;
```

这个称为上边界限定通配符，意思是说list的类型必须是Number或者Number的子类，但是这个泛型的类型还是没有具体的确定。

那么既然有了上边界通配符就会有下边界通配符：

```
List<? super Number> A;
```

它的意思很显然就是只能指定为Number或者Number的父类类型了。

---

## 接口

接口是一系列方法的声明，方法中没有方法的具体实现，这些方法可以在不同的地方实现。接口中只有两个东西，一个是全局常量，一个是公共的抽象方法，也就是说这个接口中的方法一定是final，public并且static的。

所以一个接口就应该是像下面这样：

```
interface a1 {
    final int a = 10;
    void func();
}
```

在实现这个接口时，必须要把接口中所有的方法都实现，这样才算是使用该接口。

```
class a2 implements a1 {
    public void func() {
        ...
    }
}
```

对于接口而言有一些注意点：

**接口不能被实例化，但是它可以指向一个实现它的类实例；一个类可以实现多个接口；一个接口可以继承另一个接口。**

---

## 抽象类

抽象类是一个类，如果实现的时候并不需要实例化这个类，我们可以把它定义为一个抽象类，它并不能完全描述一个对象的具体信息，但是其他对象在描述自己时可以借助这样一个抽象类。

抽象类本身也不能被实例化，但是对于它而言成员变量、成员方法和构造方法等都和普通的类是一样的。那么抽象类的作用就是被继承：

```
public abstract class A {
    ...
}
```

那么在抽象类里可能存在抽象方法，这种方法的具体实现只有在子类继承以后才能添加上去，而抽象方法也需要用标识abstract描述：

```
public abstract int func() {
    ....
}
```

那么此时如果类中包含抽象方法，那么这个类必然是抽象类，并且作为子类必须重写父类所有的抽象方法，否则子类也必须声明为抽象类。

所以对于抽象类而言，**抽象类中不一定非要有抽象方法，并且其中的构造方法和类方法不能被声明为抽象方法。**