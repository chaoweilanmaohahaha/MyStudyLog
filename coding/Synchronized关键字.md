# Synchronized

在之前的关于JVM的学习中也简单的提到了一下，java中使用了synchronized这个关键字来实现同步互斥的问题，实际上是在为对象加锁以及解锁的一个过程，但是synchronized的加锁机制本身是一个较为重量级的锁，所以使用这个关键字实现同步互斥对性能的消耗是比较明显的。

在java中，synchronized能够把任何一个非空对象作为一个锁，在有的虚拟机里把这个对象称为对象监视器。

编写代码的过程中synchronized关键字可能会出现在如下的场景中：

* 使用synchronized修饰一个实例方法，那么当前的监视器对象就是this对象；
* 使用synchronized修饰一个静态方法，那么当前的监视器对象就是class实例对象；
* 使用synchronized修饰一个代码块时，那么当前的监视器对象就是用花括号括起来的对象；

**所以很明显可以看到，使用synchronized进行上锁的操作，锁上的是对象，而不是对象里的变量**

这么一说，synchronized的使用方法就很明显了，也就不需要再赘述了，举个例子就可以知道了：

```
	public synchronized void increase(){
        i++;
    }
```

那么主要来看一下究竟是如何锁上这个对象的呢？

如果有兴趣将该函数进行一个反编译的话，查看执行的指令集，你可以发现在虚拟机中，针对synchronized修饰符修饰的对象会多出这两个指令：**monitorenter**和**monitorexit**。前者认为如果某一个线程已经进入到了监视区域（对象），那么就让计数加1，如果是同一个线程又一次进入，那么计数会累计加，如果是别的线程想要进入则会阻塞在外，直到计数变为0。那么后者就是逆操作，如果当计数变为0时，则证明当前线程已经不再是对象的而拥有者了。同步方法实现的也大同小异，方法的**ACC_SYNCHRONIZED**标志会被置为，如果被置位，则对方法所在的实例对象上锁。

为什么说synchronized开销很大，因为最底层的实现是借助了操作系统的原语实现的，这样需要从用户态和内核态之间做切换，因此增加了开销。

最后讲一下，真正对对象进行上锁的过程，其实和对象在虚拟机中存在的结构有关，这一点需要从虚拟机中理解，像monitor对象和锁的状态都被保存在了每个对象的对象头中。相关的实现请看JVM中的介绍。