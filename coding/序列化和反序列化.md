# 序列化与反序列化

看jdk库源代码的时候，很好奇里面的一些实现，比如为什么在类里面会有一个叫做**serialVersionUID**的变量，还有的变量为什么用transient修饰符修饰了等等，这些都和序列化和反序列化有关。

### 为什么？

我们先从什么是序列化和反序列化说起，序列化的意思是将对象转换为字节流存入磁盘中，那么反序列化就是从磁盘中读取字节流信息然后将它还原成对象本身。那这么存储和普通的存储有什么不同呢，其实简单的说，就是在存储对象的同时，把对象的当前状态保存了下来，就是将对象当前的一些数据持久保存下来。一般而言使用序列化和反序列化的场景在于网络和保存文件的场景中。

### 使用

在java中使用Serializable接口来实现， 例如我们可以看到哦arraylist这个类就实现了这个接口。那么我们下来解释几个问题，首先是transient修饰符。我们可以发现在这个类中arraylist被transient修饰符修饰了，那么说明这个参数本身不能被序列化。transient修饰符只能修饰变量，不能修饰方法和类，JVM会跳过被transient修饰的，将他原始值压入文件中。那么就比如这个arraylist中的elementdata就是不能被序列化的，那么是不是这个成员就不会被序列化了呢？其实也不是，只不过在该类里还实现了readObject和writeObject两个函数用来序列化elementData，所以这里相当于自定义了序列化的操作（节省空间）。

当然还有一个问题是，为什么类中会出现一个叫serialVersionUID的变量呢？这个变量相当于是被序列化对象的一个版本号。该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类，否则反序列化会爆出异常。于是可序列化的类可以显式地在类中声明序列号，如果没有声明那就会在序列化中根据类中的信息计算序列号，这样可能会导致误差。