# AFL

AFL：American Fuzzy Lop 是一款开源的fuzzing小工具，是一个使用暴力法的fuzzer。

###### INTRODUCTION

这里的操作分为对于有源码的程序操作和无源码的程序操作。

对于有源码的程序中，原本程序运行需要使用gcc或者g++先进行编译，然后在安装执行。那么一般大型的源程序软件为了方便都会编写makefile文件帮助更快捷的编译。而使用afl需要在源程序在编译过程中进行插桩，从而帮助它完成后续工作，因此需要修改其中使用的编译器为afl_gcc和afl_g++，这两个程序应该是对于gcc和g++的一次封装。

```
CC=/path/to/afl/afl-gcc ./configure
```

对于无源码的程序，则这个相当于是一个黑盒测试，这个需要通过qemu的用户级仿真实现，在afl中实现了这个功能。但是需要编译qemu。不过对于afl来说，测试无源码的程序的效率通常会比测试有源码的程序的效率低，因此使用这个软件最好测试有源码的软件比较合适。

然后有了目标程序，需要提供一个文件夹专门用作输入的文件（参数）来使用，还有一个文件夹用作输出文件来使用。然后我们就可以启动fuzz工具了

对于使用stdin来作为参数输入的命令：

```
./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]
```

对于使用文件读取作为目标程序的命令：

```
./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@
```

###### ALGORITHM

afl这个工具使用的算法如下：

1. 将用户给的初始测试用例加载入队列中；
2. 取走队列中下一个需要使用的输入文件；
3. 尝试将测试用例缩减为最小，去除那些并不会改变程序执行的东西；
4. 使用一个传统fuzzing对策来改动文件；
5. 如果变动引起了一个新的状态变化，就将该分支记录下来，随后将这个这个变动重新插入队列中；
6. 回到第二步重复执行。

###### DETAIL

如果是开源的程序，那么需要对程序进行插装，主要在程序的分支处插入桩代码，这一步是在将源文件转化为汇编语言后完成的，使用了afl-as这个汇编编译工具。

那么在分支处插桩后，就可以捕获分支的覆盖率，也可以检测到粗略的分支命中率。代码覆盖率可以用来评估和改进测试过程，意思是说执行到的代码越多，那么找到bug的可能性也越大。那么对于代码覆盖率而言，一般会提供函数级别，代码基本块级别（代码基本块可以理解为编程的时候一个花括号内的内容，他要求只有一个入口，只有一个出口）和边界级别（控制流图中每个节点就是一个代码基本块，边就是跳转的连线）三种级别的覆盖率检测。那么afl中使用的就是边界级别的代码覆盖率。具体到afl中它使用了一个二元组来记录当前基本块+前一基本块的信息，来获取执行流程和代码覆盖情况。

A -> B -> C -> D -> E (tuples: AB, BC, CD, DE)

AFL如果发现了一个新的路径会怎么做？它是用了一个全局的bitmap来保存了之前执行时所遇到的路径，

```
static const u8 count_class_lookup8[256] = {

  [0]           = 0, 
  [1]           = 1, 
  [2]           = 2, 
  [3]           = 4, 
  [4 ... 7]     = 8, 
  [8 ... 15]    = 16,
  [16 ... 31]   = 32,
  [32 ... 127]  = 64,
  [128 ... 255] = 128

};
```

afl将代码执行次数映射为一个8bit的数据，然后存入上述的桶中。如果某一次代码运行的过程中，出现了桶到桶之间的跳跃，则认为是一个感兴趣的数据。

接下来看输入文件是如何变异的，对于一个输入文件，则变异的过程是暴力的，其中包括对源文件的按位翻转，整数的加减，向原文件中添加入特殊内容，添加用户自定义或者系统自动生成的标记。

然后看一下多线程的操作。现在对于fuzz的流程有了一个大致的了解了，最后这个和AFL fuzz的过程的性能有关。对于afl来说，它本身有一个叫做fork server的。那么当启动fuzz的时候，这个fuzzer会和这个server进行通信，由这个server fork出多个进程，并且通过写时拷贝技术将已经停止的fuzz进程直接进行拷贝。

---

### 代码分析：

###### afl-gcc：

对于这个程序的main函数，一共做了几个操作：

首先是常规的判断，判断设备合法性，判断参数合法性，随后开始分别调用了find_as，edit_params，和execvp(cc_params[0], (char** cc_params))这三个操作。

find_as的目的顾名思义，就是从系统中查找汇编编译器，一共需要查看三个地方，分别是环境变量中，指定路径中，或者是指定的AFL_PATH变量中。

edit_params是编辑了参数之后喂给系统调用execvp来最终执行这个命令。其中有一步操作，gcc -B <目录>            将 <目录> 添加到编译器的搜索路径中。这样就可以指定汇编编译器，从而使用自己的编译器完成插桩。

###### afl-as

这个程序就是和编译汇编有点关系了，在afl-gcc中制定了编译程序的地址。这个程序比上面的gcc要庞大，先从main函数结构入手了。在经过了一些对于参数的判断之后，函数的一开始是通过当前的时间以及当前的进程号来设定了一个随机种子。然后同样需要一个edit_params的函数来编辑一下参数形式。接下去会进行一系列全局变量的设置，随后进入一个分支，如果在编辑参数时发现是调用了--version则进行一个分支操作，否则会调用一个叫做add_instrumentation的函数，然后就fork出一个新的进程来执行编译的操作了。这个add_instrumentation函数在做什么呢？

这一步就是在进行插桩，而插桩的内容就在afl-as.h中，它获取需要使用汇编编译的输入文件，然后将该文件读入一个临时文件中，而在这个文件中，在开始阶段会插入一部分的桩汇编代码，同时在每个分支处也会插入桩代码，然后就使用as去编译该临时文件来生成.o文件，从而完成了所谓的插桩。具体的插桩到底它做了什么这个需要具体再看一下代码。

具体以下面的例子来看：

```
#include<stdio.h>
int main() {
    int a;
    scanf("%d", &a);
}
```



###### afl-fuzz

这应该是这个程序的主入口了，首先有一个大的while循环用来从命令行获取参数，使用的是unistd.h的getopt函数。下面来看一下各个选项在这个它的大main函数里是怎么操作的：

* i选项：全局变量中in_dir表示了输入数据存放的文件夹，在这个case中进行赋值。
* o选项：全局变量中out_dir表示了输出数据存放的文件夹，在这个case中进行赋值。
* M和S选项： 设置masterid，也就是全局变量sync_id，这个选项和分布式模式有关，可能用来进行分布式的fuzz，具体需要查看文件parallel fuzzing.txt这个文件。
* f选项：设置一个全局变量out_file，功能我们后面来看
* x选项：设置读入的字典的位置extras_dir，这个是afl特有的一个功能，它可以由使用者指定输入的种子通过用户指定的字典来修改。
* t选项：设置延时，用户在这个后面添加对应的msec时间。
* m选项：设置每个子进程的内存限制，最大50M。
* d选项：暂时不知道是什么作用。
* B选项：这个选项在说明书中并没有展示，这个可以加载在fuzz过程中之前遇到的某个bitmap，然后使用它来进行修改再进行fuzz。
* C选项：crash模式。
* n选项：dumb模式。
* T选项：设置text banner语句在屏幕上，具体有什么用还不得而知。
* Q选项：使用qemu模式，也就是进行闭源二进制测试时使用。

这个函数真能正要做的第一步就是设置信号（setup_signal_handlers）,这个函数设置不同信号触发不同的信号句柄，使用的是signation。然后第二步是使用check_asan_opts()函数，似乎在查看是否在环境变量中设置了asan和msan的这两个东西。如果使用了-S选项，即使用了分布式模式，则需要对该模式的输出文件夹路径另外进行设置。

接下去程序设置了一堆有关环境变量的东西，随后保存了命令行输入命令的一个副本。然后设置一个叫banner的东西，并且检测程序是否跑在了终端上。然后获取cpu的核数，等等都是一系列在运行之前的必备检查。其中read_testcases就把所有输入队列中的文件添加到了一个队列当中，随后就是一个大的while循环。初步的猜测，在cull_queue中会消耗输入队列中的一个用例，然后使用这个用例去跑相应的程序，如果在输入队列中还有东西，就通过show_stats去刷新并且显示一些数据，如果发现已经到头了，那么就要改变策略了。（这个函数可能要通过实例才能具体得知里面的细节。）

###### afl-analyze

这个工具是用来分析要使用的用例的，这个很有意思，使用的方法依旧是afl-analyze [选项] programme。

* i选项：选择输入文件的文件名，也就是某个测试文件。
* f选项：选择该programme需要使用的文件。
* e选项：只关注边的覆盖率，但是不关注边击中的次数；
* m选项：限制内存；
* t选项：限制时间；
* Q选项：qemu模式；

这个函数的总体的做法是使用了read_initial_file函数来读取相应的文件内容，随后使用了run_target函数来运行相应的程序，随后调用analyze函数对输入的文件分析。

###### afl-tmin

这个工具的作用是对输入进去的用例进行简化，在涉及的参数上，和下面的showmap和analyze类似，其中最主要的一个函数是minimize函数，这个函数就是简化了使用的实例。

###### afl-showmap

这个函数的功能是显示被afl捕获的原始数据，总体的使用是afl-showmap [选项] programme。在这个函数中依旧有一个解析命令行的函数，稍微来看一下功能。

* o选项：选择输出的文件名，将元祖信息输出到这个文件中。
* m选项：限制内存
* t选项：限制时间
* q选项：不显示信息
* e选项：值显示边，不现实对应的击中次数。
* Q选项：qemu模式
* b选项（隐藏项）：用二进制格式写入文件
* Z和A选项（隐藏项）：在cmin中会用到

这个main函数在前面依旧是设置许多的参数并且对一些功能进行检查，随后的主要的函数是run_target函数，然后把结果通过write_results函数写入文件，因此这两个函数是这个里面的核心。