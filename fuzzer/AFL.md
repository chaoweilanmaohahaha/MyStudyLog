# AFL

AFL：American Fuzzy Lop 是一款开源的fuzzing小工具，是一个使用暴力法的fuzzer。

###### INTRODUCTION

这里的操作分为对于有源码的程序操作和无源码的程序操作。

对于有源码的程序中，原本程序运行需要使用gcc或者g++先进行编译，然后在安装执行。那么一般大型的源程序软件为了方便都会编写makefile文件帮助更快捷的编译。而使用afl需要在源程序在编译过程中进行插桩，从而帮助它完成后续工作，因此需要修改其中使用的编译器为afl_gcc和afl_g++，这两个程序应该是对于gcc和g++的一次封装。

```
CC=/path/to/afl/afl-gcc ./configure
```

对于无源码的程序，则这个相当于是一个黑盒测试，这个需要通过qemu的用户级仿真实现，在afl中实现了这个功能。但是需要编译qemu。不过对于afl来说，测试无源码的程序的效率通常会比测试有源码的程序的效率低，因此使用这个软件最好测试有源码的软件比较合适。

然后有了目标程序，需要提供一个文件夹专门用作输入的文件（参数）来使用，还有一个文件夹用作输出文件来使用。然后我们就可以启动fuzz工具了

对于使用stdin来作为参数输入的命令：

```
./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]
```

对于使用文件读取作为目标程序的命令：

```
./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@
```

###### ALGORITHM

afl这个工具使用的算法如下：

1. 将用户给的初始测试用例加载入队列中；
2. 取走队列中下一个需要使用的输入文件；
3. 尝试将测试用例缩减为最小，去除那些并不会改变程序执行的东西；
4. 使用一个传统fuzzing对策来改动文件；
5. 如果变动引起了一个新的状态变化，就将该分支记录下来，随后将这个这个变动重新插入队列中；
6. 回到第二步重复执行。

###### DETAIL

如果是开源的程序，那么需要对程序进行插装，主要在程序的分支处插入桩代码，这一步是在将源文件转化为汇编语言后完成的，使用了afl-as这个汇编编译工具。

那么在分支处插桩后，就可以捕获分支的覆盖率，也可以检测到粗略的分支命中率。代码覆盖率可以用来评估和改进测试过程，意思是说执行到的代码越多，那么找到bug的可能性也越大。那么对于代码覆盖率而言，一般会提供函数级别，代码基本块级别（代码基本块可以理解为编程的时候一个花括号内的内容，他要求只有一个入口，只有一个出口）和边界级别（控制流图中每个节点就是一个代码基本块，边就是跳转的连线）三种级别的覆盖率检测。那么afl中使用的就是边界级别的代码覆盖率。具体到afl中它使用了一个二元组来记录当前基本块+前一基本块的信息，来获取执行流程和代码覆盖情况。

A -> B -> C -> D -> E (tuples: AB, BC, CD, DE)

AFL如果发现了一个新的路径会怎么做？它是用了一个全局的bitmap来保存了之前执行时所遇到的路径，

```
static const u8 count_class_lookup8[256] = {

  [0]           = 0, 
  [1]           = 1, 
  [2]           = 2, 
  [3]           = 4, 
  [4 ... 7]     = 8, 
  [8 ... 15]    = 16,
  [16 ... 31]   = 32,
  [32 ... 127]  = 64,
  [128 ... 255] = 128

};
```

afl将代码执行次数映射为一个8bit的数据，然后存入上述的桶中。如果某一次代码运行的过程中，出现了桶到桶之间的跳跃，则认为是一个感兴趣的数据。

接下来看输入文件是如何变异的，对于一个输入文件，则变异的过程是暴力的，其中包括对源文件的按位翻转，整数的加减，向原文件中添加入特殊内容，添加用户自定义或者系统自动生成的标记。

然后看一下多线程的操作。现在对于fuzz的流程有了一个大致的了解了，最后这个和AFL fuzz的过程的性能有关。对于afl来说，它本身有一个叫做fork server的。那么当启动fuzz的时候，这个fuzzer会和这个server进行通信，由这个server fork出多个进程，并且通过写时拷贝技术将已经停止的fuzz进程直接进行拷贝。